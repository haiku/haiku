# BeOS specific rules


rule AddStringDataResource
{
	# AddStringDataResource <target> : <resourceID> : <dataString>
	# Adds a single resource to the resources of an executable/library.
	# <target>: The executable/library.
	# <resourceID>: A resource ID string as understood by xres (type:id[:name]).
	# <dataString>: The string <dataString> will be written to the resource.
	#               Defaults to "".
	#
	local target = $(1) ;
	local resourceID = $(2) ;
	local dataString = $(3:E="") ;

	# the resource file
	local resources
		= [ FGristFiles $(target:B)-added-string-data-resources.rsrc ] ;

	# add the resource file to the target, if not yet done
	if ! [ on $(resources) return $(RESOURCES_ADDED) ] {
		RESOURCES_ADDED on $(resources) = true ;
		MakeLocateArch $(resources) ;
		Depends $(resources) : <build>xres ;
		AddStringDataResource1 $(resources) : <build>xres ;
		AddResources $(target) : $(resources) ;
	}

	RESOURCE_STRINGS on $(resources)
		+= "-a "$(resourceID)" -s \""$(dataString)"\"" ;
}

actions together AddStringDataResource1
{
	$(HOST_ADD_BUILD_COMPATIBILITY_LIB_DIR)
	$(2[1]) -o "$(1)" $(RESOURCE_STRINGS)
}


rule AddFileDataResource
{
	# AddFileDataResource <target> : <resourceID> : [ <dataFile> ]
	# Adds a single resource to the resources of an executable/library.
	# <target>: The executable/library.
	# <resourceID>: A resource ID string as understood by xres (type:id[:name]).
	# <dataFile>: The data to be written into the resource will be read from
	#             that file.
	#             Note that this is supposed to be a build target, not a path
	#             name - if you need to add a data file in a different path, you
	#             have to locate it first.
	#
	local target = $(1) ;
	local resourceID = $(2) ;
	local dataFile = $(3) ;

	# the resource file
	local resources
		= <added-resources>file-data-$(resourceID)-$(dataFile).rsrc ;

	# add it to the resources of the given target
	AddResources $(target) : $(resources) ;

	# if the rule for creating the resource file has not been invoked yet, do it
	if ! [ on $(resources) return $(RESOURCES_DEFINED) ] {
		RESOURCES_DEFINED on $(resources) = true ;
		RESOURCE_ID on $(resources) = $(resourceID) ;
		MakeLocateArch $(resources) ;

		Depends $(resources) : <build>xres $(dataFile) ;
		AddFileDataResource1 $(resources) : <build>xres $(dataFile) ;
	}
}

actions AddFileDataResource1
{
	$(HOST_ADD_BUILD_COMPATIBILITY_LIB_DIR)
	$(2[1]) -o "$(1)" -a "$(RESOURCE_ID)" "$(2[2])" ;
}

rule XRes
{
	# XRes <target> : <resource files>
	if $(2)
	{
		Depends $(1) : <build>xres $(2) ;
		XRes1 $(1) : <build>xres $(2) ;
	}
}

actions XRes1
{
	$(HOST_ADD_BUILD_COMPATIBILITY_LIB_DIR)
	$(2[1]) -o "$(1)" "$(2[2-])" ;
}

rule SetVersion
{
	# SetVersion <target>

	Depends $(1) : <build>setversion ;
	SetVersion1 $(1) : <build>setversion ;
}

actions SetVersion1
{
	$(HOST_ADD_BUILD_COMPATIBILITY_LIB_DIR)
	$(2[1]) "$(1)" -system $(HAIKU_BUILD_VERSION) -short "$(HAIKU_BUILD_DESCRIPTION)" ;
}

rule SetType
{
	# SetType <target>

	Depends $(1) : <build>settype ;
	SetType1 $(1) : <build>settype ;
}

actions SetType1
{
	$(HOST_ADD_BUILD_COMPATIBILITY_LIB_DIR)
	$(2[1]) -t $(TARGET_EXECUTABLE_MIME_TYPE) "$(1)" ;
}

rule MimeSet
{
	# MimeSet <target>

	Depends $(1) : <build>mimeset ;
	MimeSet1 $(1) : <build>mimeset ;
}

actions MimeSet1
{
	$(HOST_ADD_BUILD_COMPATIBILITY_LIB_DIR)
	$(2[1]) -f "$(1)" ;
}

rule ResComp
{
	# ResComp <resource file> : <rdef file> ;
	#
	# <resource file> and <rdef file> must be gristed.

	# get compiler and defines for the platform
	local cc ;
	local defines ;
	local localIncludesOption ;
	
	on $(1) { # use on $(1) variable values
		defines = $(DEFINES) ;

		if $(PLATFORM) = host {
			defines += $(HOST_DEFINES) ;
			cc = $(HOST_CC) ;
			localIncludesOption = $(HOST_LOCAL_INCLUDES_OPTION) ;
		} else {
			defines += $(TARGET_DEFINES) ;
			cc = $(TARGET_CC) ;
			localIncludesOption = $(TARGET_LOCAL_INCLUDES_OPTION) ;
		}
	}

	DEFINES on $(1) = $(defines) ;
	CCDEFS on $(1) = [ FDefines $(defines) ] ;
	HDRS on $(1) = [ FIncludes $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) : $(localIncludesOption) ] ;
	RCHDRS on $(1) = [ FIncludes $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) : "-I " ] ;
	CC on $(1) = $(cc) ;

	# set up other vars
	SEARCH on $(2) += $(SEARCH_SOURCE) ;
	MakeLocateArch $(1) ;
	Depends $(1) : $(2) <build>rc ;
	LocalClean clean : $(1) ;
	ResComp1 $(1) : <build>rc $(2) ;
}

# Note: We pipe the file into the preprocessor, since *.rdef files are
# considered linker scripts.
actions ResComp1
{
	$(HOST_ADD_BUILD_COMPATIBILITY_LIB_DIR)
	cat $(2[2]) | $(CC) -E $(CCDEFS) $(HDRS) - | egrep -v '^#' | $(2[1]) $(RCHDRS) --auto-names -o $(1) -
}
