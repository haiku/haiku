
rule AddSharedObjectGlueCode
{
	# AddSharedObjectGlueCode <target> : <isExecutable> ;
	
	# we link with -nostdlib and add the required libs manually, when building
	# for Haiku
	local platform ;
	on $(1) {
		platform = $(PLATFORM) ;
		if $(platform) = haiku {
			local stdLibs = libroot.so ;
			local beginGlue ;
			local endGlue ;
			if $(2) = true {
				beginGlue += $(HAIKU_EXECUTABLE_BEGIN_GLUE_CODE) ;
				endGlue += $(HAIKU_EXECUTABLE_END_GLUE_CODE) ;
			} else {
				beginGlue += $(HAIKU_LIBRARY_BEGIN_GLUE_CODE) ;
				endGlue += $(HAIKU_LIBRARY_END_GLUE_CODE) ;

				# special case for libroot: don't link it against itself
				if $(DONT_LINK_AGAINST_LIBROOT) {
					stdLibs = ;
				}
			}

			LINK_BEGIN_GLUE on $(1) = $(beginGlue) ;
			LINK_END_GLUE on $(1) = $(endGlue) ;

			NEEDLIBS on $(1) =  [ on $(1) return $(NEEDLIBS) ] $(stdLibs) ;
			Depends $(1) : $(stdLibs) $(beginGlue) $(endGlue) ;
			LINKFLAGS on $(1) = [ on $(1) return $(LINKFLAGS) ] -nostdlib ;
		}
	}

	# link against the compatibility libraries needed for the target
	if $(platform) != host && $(TARGET_HAIKU_COMPATIBILITY_LIBS) {
		LinkAgainst $(1) : $(TARGET_HAIKU_COMPATIBILITY_LIBS) ;
	}
}

rule Executable
{
	# Executable <name> : <sources> : <libraries> : <res> ;
	#
	if ! [ IsPlatformSupportedForTarget $(1) ] {
		return ;
	}

	AddResources $(1) : $(4) ;
	Main $(1) : $(2) ;
	LinkAgainst $(1) : $(3) ;
	LINKFLAGS on $(1) = [ on $(1) return $(LINKFLAGS) ]
		-Xlinker -soname=_APP_ ;

	# we link with -nostdlib and add the required libs manually, when building
	# for Haiku
	AddSharedObjectGlueCode $(1) : true ;
}

rule Application
{
	# Application <name> : <sources> : <libraries> : <res> ;
	Executable $(1) : $(2) : $(3) : $(4) ;
}

rule BinCommand
{
	# BinCommand <name> : <sources> : <libraries> : <res> ;
	Executable $(1) : $(2) : $(3) : $(4) ;
}

rule StdBinCommands
{
	# StdBinCommands <sources> : <libs> : <res> ;
	local libs = $(2) ;
	local ress = $(3) ;
	local source ;
	for source in $(1)
	{
		local target = $(source:S=) ;

		BinCommand $(target) : $(source) : $(libs) : $(ress) ;
	}
}

rule Preference
{
	# Preference <name> : <sources> : <libraries> : <res> ;
	Executable $(1) : $(2) : $(3) : $(4) ;
}

rule Server
{
	# Server <name> : <sources> : <libraries> : <res> ;
	
	Executable $(1) : $(2) : $(3) : $(4) ;
}

rule Addon
{
	# Addon <name> : <relpath> : <sources> : <is executable> : <libraries> ;
	# <name>: Name of the add-on.
	# <relpath>: Path where the add-on shall live relative to the add-on dir.
	# <sources>: Source files.
	# <is executable>: true, if the target shall be executable as well.
	# <libraries>: Libraries to be linked against.
# TODO: <relpath> is no longer needed

	if ! [ IsPlatformSupportedForTarget $(1) ] {
		return ;
	}

	local isExecutable = $(4) ;
	
	Main $(1) : $(3) ;

	local linkFlags = -Xlinker -soname=\"$(1:G=)\" ;
	if $(isExecutable) != true {
		linkFlags = -nostart $(linkFlags) ;
	}
	LINKFLAGS on $(1) = [ on $(1) return $(LINKFLAGS) ] $(linkFlags) ;
	LinkAgainst $(1) : $(5) ;

	AddSharedObjectGlueCode $(1) : $(isExecutable) ;
}

rule Translator
{
	# Translator <name> : <sources> : <libraries> ;
	# TODO: Although they currently all are, translators don't need to be
	# executable. Introduce a flag as for Addon.
	Addon $(1) : Translators : $(2) : true : $(3) ;
}

rule ScreenSaver
{
	# ScreenSaver <name> : <sources> : <libraries> ;
	Addon $(1) : screen_savers : $(2) : false : $(3) ;
}

rule StaticLibrary
{
	# StaticLibrary <lib> : <sources> : <otherObjects> ;
	# Creates a static library from sources.
	# <lib>: The static library to be built.
	# <sources>: List of source files.
	# <otherObjects>: List of additional object files.
	#	
	local lib = $(1) ;
	local sources = [ FGristFiles $(2) ] ;
	local otherObjects = $(3) ;
	local objects = $(sources:S=$(SUFOBJ)) ;

	if ! [ IsPlatformSupportedForTarget $(1) ] {
		return ;
	}

	InheritPlatform $(objects) : $(lib) ;

	StaticLibraryFromObjects $(lib) : $(objects) $(otherObjects) ;
	Objects $(2) ;
}

rule StaticLibraryFromObjects
{
	if ! [ IsPlatformSupportedForTarget $(1) ] {
		return ;
	}

	LibraryFromObjects $(1) : $(2) ;
}

rule Ld
{
	# Ld <name> : <objs> : <linkerscript> : <flags> ;
	#
	local target = $(1) ;
	local objects = $(2) ;
	local linkerScript = $(3) ;
	local linkerFlags = $(4) ;

	if $(linkerScript) {
		linkerFlags += --script=$(linkerScript) ;
	}

	on $(target) {
		if $(PLATFORM) = host {
			LINK on $(target) = $(HOST_LD) ;
			LINKFLAGS on $(target) = $(HOST_LDFLAGS) $(LINKFLAGS) $(linkerFlags) ;
		} else {
			LINK on $(target) = $(TARGET_LD) ;
			LINKFLAGS on $(target) = $(TARGET_LDFLAGS) $(LINKFLAGS)
				$(linkerFlags) ;
		}

		NEEDLIBS on $(target) = $(NEEDLIBS) ;
		LINKLIBS on $(target) = $(LINKLIBS) ;
	}
		
	LocalClean clean : $(target) ;
	LocalDepends all : $(target) ;
	Depends $(target) : $(objects) ;

	MakeLocateDebug $(target) ; 
}

actions Ld
{
	$(LINK) $(LINKFLAGS) -o "$(1)" "$(2)" "$(NEEDLIBS)" $(LINKLIBS)
}


rule MergeObjectFromObjects
{
	# MergeObjectFromObjects <name> : <objects> : <other objects> ;
	# Merges object files to an object file.
	# <name>: Name of the object file to create. No grist will be added.
	# <objects>: Object files to be merged. Grist will be added.
	# <other objects>: Object files or static libraries to be merged. No grist
	#                  will be added.
	#
	local objects = [ FGristFiles $(2) ] ;

	on $(1) {
		if ! $(PLATFORM) in $(SUPPORTED_PLATFORMS) {
			return ;
		}

		if $(PLATFORM) = host {
			LINK on $(1) = $(HOST_LD) ;
		} else {
			LINK on $(1) = $(TARGET_LD) ;
		}
	}

	MakeLocateDebug $(1) ;
	Depends $(1) : $(objects) ;
	Depends $(1) : $(3) ;
	LocalDepends obj : $(1) ;
	MergeObjectFromObjects1 $(1) : $(objects) $(3) ;
}

actions MergeObjectFromObjects1
{
	$(LINK) -r $(2) -o $(1) ;
}

rule MergeObject
{
	# MergeObject <name> : <sources> : <other objects> ;
	# Compiles source files and merges the object files to an object file.
	# <name>: Name of the object file to create. No grist will be added.
	# <sources>: Sources to be compiled. Grist will be added.
	# <other objects>: Object files or static libraries to be merged. No grist
	#                  will be added.
	#
	local target = $(1) ;
	local sources = [ FGristFiles $(2) ] ;
	local otherObjects = $(3) ;
	local objects = $(sources:S=$(SUFOBJ)) ;

	if ! [ IsPlatformSupportedForTarget $(1) ] {
		return ;
	}

	InheritPlatform $(objects) : $(target) ;
	Objects $(sources) ;
	MergeObjectFromObjects $(target) : $(objects) : $(otherObjects) ;
}

rule SharedLibraryFromObjects
{
	# SharedLibraryFromObjects <lib> : <objects> : <libraries> ;
	#
	local _lib = $(1) ;

	if ! [ IsPlatformSupportedForTarget $(1) ] {
		return ;
	}

	MainFromObjects $(_lib) : $(2) ;
	LINKFLAGS on $(_lib) = [ on $(_lib) return $(LINKFLAGS) ]
						   -nostart -Xlinker -soname=\"$(_lib:G=)\" ;
	LinkAgainst $(_lib) : $(3) ;

	AddSharedObjectGlueCode $(_lib) : false ;
}

rule SharedLibrary
{
	# SharedLibrary <lib> : <sources> : <libraries> ;
	local lib = $(1) ;
	local sources = [ FGristFiles $(2) ] ;
	local objects = $(sources:S=$(SUFOBJ)) ;
	local libs = $(3) ;

	if ! [ IsPlatformSupportedForTarget $(1) ] {
		return ;
	}

	InheritPlatform $(objects) : $(lib) ;
	Objects $(sources) ;
	SharedLibraryFromObjects $(lib) : $(objects) : $(libs) ;
}

rule LinkAgainst
{
	# LinkAgainst <name> : <libs> [ : <mapLibs> ] ;
	# Valid elements for <libs> are e.g. "be" or "libtranslation.so" or
	# "/boot/.../libfoo.so". If the basename starts with "lib" or the thingy
	# has a dirname or grist, it is added to the NEEDLIBS variable (i.e. the
	# file will be bound!), otherwise it is prefixed "-l" and added to
	# LINKLIBS. If you want to specify a target that isn't a library and
	# also has neither grist nor a dirname, you can prepend "<nogrist>" as
	# grist; it will be stripped by this rule.
	# <mapLibs> specifies whether the to translate library names (e.g. "be"
	# to "libbe.so" in case of target platform "haiku"). Defaults to "true".
	#
	local target = $(1) ;
	local libs = $(2) ;
	local mapLibs = $(3:E=true) ;

	on $(target) {
		# map libraries, if desired and target platform is Haiku
		if $(PLATFORM) != host && $(mapLibs) = true
				&& $(TARGET_LIBRARY_NAME_MAP) {
			local mappedLibs ;

			for i in $(libs) {
				local mapped = $($(TARGET_LIBRARY_NAME_MAP)_$(i)) ;
				mapped ?= $(i) ;
				mappedLibs += $(mapped) ;
			}

			libs = $(mappedLibs) ;
		}

		local linkLibs ;
		local needLibs ;

		for i in $(libs)
		{
			local isfile = ;
			if $(i:D) || $(i:G) {
				isfile = true ;
				if $(i:G) = <nogrist> {
					i = $(i:G=) ;
				}
			} else {
				switch $(i:B)
				{
					# XXX: _APP_ and _KERNEL_ should not be needed for ELF.
					case _APP_ : isfile = true ;
					case _KERNEL_ : isfile = true ;
					case lib*	: isfile = true ;
					case *	: isfile = ;
				}
				if ! $(isfile) && ( $(i:S) = .so || $(i:S) = .a ) {
					isfile = true ;
				}
			}

			if $(isfile) {
				needLibs += $(i) ;
			} else {
				linkLibs += $(i) ;
			}
		}
	
		NEEDLIBS on $(1) = $(NEEDLIBS) $(needLibs) ;
		LINKLIBS on $(1) = $(LINKLIBS) -l$(linkLibs) ;

		if $(needLibs) && ! $(NO_LIBRARY_DEPENDENCIES) {
			Depends $(1) : $(needLibs) ;
		}
	}
}

rule AddResources
{
	# AddResources <name> : <resourcefiles> ;

	# add grist to the resource files which don't have any yet
	local resfiles ;
	local file ;
	for file in $(2) {
		if ! $(file:G) {
			file = [ FGristFiles $(file) ] ;
		}
		resfiles += $(file) ;
	}

	SEARCH on $(resfiles) += $(SEARCH_SOURCE) ;

	for file in $(resfiles) {
		if $(file:S) = .rdef {
			local rdef = $(file) ;
			file = $(rdef:S=.rsrc) ;
			ResComp $(file) : $(rdef) ;
		}
		InheritPlatform $(file) : $(1) ;
		RESFILES on $(1) += $(file) ;
	}
}

rule BuildPlatformObjects
{
	# Usage BuildPlatformObjects <sources> ;
	# <sources> The sources.
	# 
	local sources = [ FGristFiles $(1) ] ;
	local objects = [ FGristFiles $(sources:S=$(SUFOBJ)) ] ;
	
	PLATFORM on $(objects) = host ;
	SUPPORTED_PLATFORMS on $(objects) = host ;

	Objects $(sources) ;
}

rule BuildPlatformMain
{
	# Usage BuildPlatformMain <target> : <sources> : <libraries> ;
	# <target> The executable/library.
	# <sources> The sources.
	# <libraries> Libraries to link against.
	# 
	local target = $(1) ;
	local sources = $(2) ;
	local libs = $(3) ;
	local objects = [ FGristFiles $(sources:S=$(SUFOBJ)) ] ;

	PLATFORM on $(target) = host ;
	SUPPORTED_PLATFORMS on $(target) = host ;
	DONT_USE_BEOS_RULES on $(target) = true ;

	local usesBeAPI = [ on $(target) return $(USES_BE_API) ] ;
	if $(usesBeAPI) {
		# propagate the flag to the objects
		USES_BE_API on $(objects) = $(usesBeAPI) ;

		# add the build libroot
		if ! $(HOST_PLATFORM_BEOS_COMPATIBLE) {
			Depends $(target) : $(HOST_LIBROOT) ;
			NEEDLIBS on $(target) += $(HOST_LIBROOT) ;
		}
	}
		
	Main $(target) : $(sources) ;
	LinkAgainst $(target) : $(libs) ;
}

rule BuildPlatformSharedLibrary
{
	# Usage BuildPlatformSharedLibrary <target> : <sources> : <libraries> ;
	# <target> The library.
	# <sources> The sources.
	# <libraries> Libraries to link against.
	#
	local target = $(1) ;
	local sources = $(2) ;
	local libs = $(3) ;
	
	BuildPlatformMain $(target) : $(sources) : $(libs) ;
	LINKFLAGS on $(target) = [ on $(target) return $(LINKFLAGS) ]
		-shared -Xlinker -soname=\"$(target:G=)\" ;
}

rule BuildPlatformMergeObject
{
	# BuildPlatformMergeObject <name> : <sources> : <other objects> ;
	# Compiles source files and merges the object files to an object file.
	# <name>: Name of the object file to create. No grist will be added.
	# <sources>: Sources to be compiled. Grist will be added.
	# <other objects>: Object files or static libraries to be merged. No grist
	#                  will be added.
	#
	local target = $(1) ;
	local sources = $(2) ;
	local otherObjects = $(3) ;
	local objects = [ FGristFiles $(sources:S=$(SUFOBJ)) ] ;
	
	PLATFORM on $(target) = host ;
	SUPPORTED_PLATFORMS on $(target) = host ;

	local usesBeAPI = [ on $(target[1]) return $(USES_BE_API) ] ;
	if $(usesBeAPI) {
		# propagate the flag to the objects
		USES_BE_API on $(objects) = $(usesBeAPI) ;
	}
	
	MergeObject $(target) : $(sources) : $(otherObjects) ;
}

rule BuildPlatformStaticLibrary
{
	# BuildPlatformStaticLibrary <lib> : <sources> ;
	# Creates a static library from sources.
	# <lib>: The library.
	# <sources>: List of source files.
	
	local lib = $(1) ;
	local sources = $(2) ;
	local objects = [ FGristFiles $(sources:S=$(SUFOBJ)) ] ;
	
	PLATFORM on $(lib) = host ;
	SUPPORTED_PLATFORMS on $(lib) = host ;

	local usesBeAPI = [ on $(lib) return $(USES_BE_API) ] ;
	if $(usesBeAPI) {
		# propagate the flag to the objects
		USES_BE_API on $(objects) = $(usesBeAPI) ;
	}

	StaticLibrary $(lib) : $(sources) ;
}

