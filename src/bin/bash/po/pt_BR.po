# bash: Translation to Brazilian Portuguese (pt_BR)
# Copyright (C) 2002 Free Software Foundation, Inc.
# Halley Pacheco de Oliveira <halleypo@ig.com.br>, 2002.
#
msgid ""
msgstr ""
"Project-Id-Version: bash 2.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2009-02-19 14:53-0500\n"
"PO-Revision-Date: 2002-05-08 13:50GMT -3\n"
"Last-Translator: Halley Pacheco de Oliveira <halleypo@ig.com.br>\n"
"Language-Team: Brazilian Portuguese <ldp-br@bazar.conectiva.com.br>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 0.9.5\n"

#: arrayfunc.c:50
msgid "bad array subscript"
msgstr "índice da matriz (array) incorreto"

#: arrayfunc.c:313 builtins/declare.def:474
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr ""

#: arrayfunc.c:479
#, fuzzy, c-format
msgid "%s: invalid associative array key"
msgstr "%c%c: opção incorreta"

#: arrayfunc.c:481
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: impossível atribuir a índice não numérico"

#: arrayfunc.c:517
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr ""

#: bashhist.c:379
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: impossível criar: %s"

#: bashline.c:3413
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr ""

#: bashline.c:3491
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr ""

#: bashline.c:3520
#, c-format
msgid "no closing `%c' in %s"
msgstr ""

#: bashline.c:3554
#, c-format
msgid "%s: missing colon separator"
msgstr ""

#: builtins/bind.def:120 builtins/bind.def:123
msgid "line editing not enabled"
msgstr ""

#: builtins/bind.def:206
#, c-format
msgid "`%s': invalid keymap name"
msgstr ""

#: builtins/bind.def:245
#, fuzzy, c-format
msgid "%s: cannot read: %s"
msgstr "%s: impossível criar: %s"

#: builtins/bind.def:260
#, fuzzy, c-format
msgid "`%s': cannot unbind"
msgstr "%s: comando não encontrado"

#: builtins/bind.def:295 builtins/bind.def:325
#, fuzzy, c-format
msgid "`%s': unknown function name"
msgstr "%s: função somente para leitura"

#: builtins/bind.def:303
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr ""

#: builtins/bind.def:307
#, c-format
msgid "%s can be invoked via "
msgstr ""

#: builtins/break.def:77 builtins/break.def:117
#, fuzzy
msgid "loop count"
msgstr "logout"

#: builtins/break.def:137
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr ""

#: builtins/caller.def:133
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns "
msgstr ""

#: builtins/cd.def:215
msgid "HOME not set"
msgstr ""

#: builtins/cd.def:227
msgid "OLDPWD not set"
msgstr ""

#: builtins/common.c:101
#, fuzzy, c-format
msgid "line %d: "
msgstr "encaixe (slot) %3d: "

#: builtins/common.c:139 error.c:260
#, fuzzy, c-format
msgid "warning: "
msgstr "escrevendo"

#: builtins/common.c:153
#, c-format
msgid "%s: usage: "
msgstr ""

#: builtins/common.c:166 test.c:822
msgid "too many arguments"
msgstr "número excessivo de argumentos"

#: builtins/common.c:191 shell.c:493 shell.c:774
#, fuzzy, c-format
msgid "%s: option requires an argument"
msgstr "a opção requer um argumento: -"

#: builtins/common.c:198
#, c-format
msgid "%s: numeric argument required"
msgstr ""

#: builtins/common.c:205
#, fuzzy, c-format
msgid "%s: not found"
msgstr "%s: comando não encontrado"

#: builtins/common.c:214 shell.c:787
#, fuzzy, c-format
msgid "%s: invalid option"
msgstr "%c%c: opção incorreta"

#: builtins/common.c:221
#, fuzzy, c-format
msgid "%s: invalid option name"
msgstr "%c%c: opção incorreta"

#: builtins/common.c:228 general.c:231 general.c:236
#, fuzzy, c-format
msgid "`%s': not a valid identifier"
msgstr "`%s' não é um identificador válido"

#: builtins/common.c:238
#, fuzzy
msgid "invalid octal number"
msgstr "número do sinal incorreto"

#: builtins/common.c:240
#, fuzzy
msgid "invalid hex number"
msgstr "número do sinal incorreto"

#: builtins/common.c:242 expr.c:1255
#, fuzzy
msgid "invalid number"
msgstr "número do sinal incorreto"

#: builtins/common.c:250
#, c-format
msgid "%s: invalid signal specification"
msgstr ""

#: builtins/common.c:257
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr ""

#: builtins/common.c:264 error.c:453
#, c-format
msgid "%s: readonly variable"
msgstr "%s: a variável permite somente leitura"

#: builtins/common.c:272
#, c-format
msgid "%s: %s out of range"
msgstr ""

#: builtins/common.c:272 builtins/common.c:274
#, fuzzy
msgid "argument"
msgstr "esperado argumento"

#: builtins/common.c:274
#, c-format
msgid "%s out of range"
msgstr ""

#: builtins/common.c:282
#, c-format
msgid "%s: no such job"
msgstr ""

#: builtins/common.c:290
#, fuzzy, c-format
msgid "%s: no job control"
msgstr "nenhum controle de trabalho nesta `shell'"

#: builtins/common.c:292
#, fuzzy
msgid "no job control"
msgstr "nenhum controle de trabalho nesta `shell'"

#: builtins/common.c:302
#, fuzzy, c-format
msgid "%s: restricted"
msgstr "%s: o trabalho terminou"

#: builtins/common.c:304
#, fuzzy
msgid "restricted"
msgstr "Terminado"

#: builtins/common.c:312
#, c-format
msgid "%s: not a shell builtin"
msgstr ""

#: builtins/common.c:321
#, fuzzy, c-format
msgid "write error: %s"
msgstr "erro de `pipe': %s"

#: builtins/common.c:329
#, c-format
msgid "error setting terminal attributes: %s"
msgstr ""

#: builtins/common.c:331
#, c-format
msgid "error getting terminal attributes: %s"
msgstr ""

#: builtins/common.c:563
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr ""

#: builtins/common.c:629 builtins/common.c:631
#, fuzzy, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: Redirecionamento ambíguo"

#: builtins/complete.def:270
#, c-format
msgid "%s: invalid action name"
msgstr ""

#: builtins/complete.def:430 builtins/complete.def:615
#: builtins/complete.def:813
#, c-format
msgid "%s: no completion specification"
msgstr ""

#: builtins/complete.def:667
msgid "warning: -F option may not work as you expect"
msgstr ""

#: builtins/complete.def:669
msgid "warning: -C option may not work as you expect"
msgstr ""

#: builtins/complete.def:786
msgid "not currently executing completion function"
msgstr ""

#: builtins/declare.def:122
#, fuzzy
msgid "can only be used in a function"
msgstr "somente pode ser usado dentro de funções; faz com que o escopo visível"

#: builtins/declare.def:353
msgid "cannot use `-f' to make functions"
msgstr ""

#: builtins/declare.def:365 execute_cmd.c:4818
#, c-format
msgid "%s: readonly function"
msgstr "%s: função somente para leitura"

#: builtins/declare.def:461
#, fuzzy, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "$%s: impossível atribuir desta maneira"

#: builtins/declare.def:468
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr ""

#: builtins/enable.def:137 builtins/enable.def:145
msgid "dynamic loading not available"
msgstr ""

#: builtins/enable.def:312
#, fuzzy, c-format
msgid "cannot open shared object %s: %s"
msgstr "impossível abrir o `named pipe' %s para %s: %s"

#: builtins/enable.def:335
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr ""

#: builtins/enable.def:459
#, c-format
msgid "%s: not dynamically loaded"
msgstr ""

#: builtins/enable.def:474
#, fuzzy, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: impossível criar: %s"

#: builtins/evalfile.c:134 builtins/hash.def:169 execute_cmd.c:4675
#: shell.c:1439
#, c-format
msgid "%s: is a directory"
msgstr "%s: é um diretório"

#: builtins/evalfile.c:139
#, fuzzy, c-format
msgid "%s: not a regular file"
msgstr "%s: impossível executar o arquivo binário"

#: builtins/evalfile.c:147
#, c-format
msgid "%s: file is too large"
msgstr ""

#: builtins/evalfile.c:185 execute_cmd.c:4745 shell.c:1449
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: impossível executar o arquivo binário"

#: builtins/exec.def:212
#, fuzzy, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: impossível criar: %s"

#: builtins/exit.def:65
#, fuzzy, c-format
msgid "logout\n"
msgstr "logout"

#: builtins/exit.def:88
msgid "not login shell: use `exit'"
msgstr ""

#: builtins/exit.def:120
#, c-format
msgid "There are stopped jobs.\n"
msgstr ""

#: builtins/exit.def:122
#, c-format
msgid "There are running jobs.\n"
msgstr ""

#: builtins/fc.def:261
#, fuzzy
msgid "no command found"
msgstr "%s: comando não encontrado"

#: builtins/fc.def:341
msgid "history specification"
msgstr ""

#: builtins/fc.def:362
#, fuzzy, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: impossível criar: %s"

#: builtins/fg_bg.def:149 builtins/jobs.def:282
msgid "current"
msgstr ""

#: builtins/fg_bg.def:158
#, c-format
msgid "job %d started without job control"
msgstr ""

#: builtins/getopt.c:110
#, fuzzy, c-format
msgid "%s: illegal option -- %c\n"
msgstr "Opção ilegal: -"

#: builtins/getopt.c:111
#, fuzzy, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "a opção requer um argumento: -"

#: builtins/hash.def:92
msgid "hashing disabled"
msgstr ""

#: builtins/hash.def:138
#, c-format
msgid "%s: hash table empty\n"
msgstr ""

#: builtins/hash.def:244
#, fuzzy, c-format
msgid "hits\tcommand\n"
msgstr "`r', o último comando seja executado novamente."

#: builtins/help.def:130
#, c-format
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] ""
msgstr[1] ""

#: builtins/help.def:168
#, c-format
msgid ""
"no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr ""

#: builtins/help.def:185
#, fuzzy, c-format
msgid "%s: cannot open: %s"
msgstr "%s: impossível criar: %s"

#: builtins/help.def:337
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""

#: builtins/history.def:154
msgid "cannot use more than one of -anrw"
msgstr ""

#: builtins/history.def:186
msgid "history position"
msgstr ""

#: builtins/history.def:365
#, fuzzy, c-format
msgid "%s: history expansion failed"
msgstr "%s: esperado expressão de número inteiro"

#: builtins/inlib.def:71
#, fuzzy, c-format
msgid "%s: inlib failed"
msgstr "%s: esperado expressão de número inteiro"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr ""

#: builtins/kill.def:197
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr ""

#: builtins/kill.def:260
#, fuzzy
msgid "Unknown error"
msgstr "Erro desconhecido %d"

#: builtins/let.def:95 builtins/let.def:120 expr.c:501 expr.c:516
msgid "expression expected"
msgstr "esperado uma expressão"

#: builtins/mapfile.def:241 builtins/read.def:272
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr ""

#: builtins/mapfile.def:249 builtins/read.def:279
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr ""

#: builtins/mapfile.def:258 builtins/mapfile.def:296
#, fuzzy, c-format
msgid "%s: invalid line count"
msgstr "%c%c: opção incorreta"

#: builtins/mapfile.def:269
#, fuzzy, c-format
msgid "%s: invalid array origin"
msgstr "%c%c: opção incorreta"

#: builtins/mapfile.def:286
#, fuzzy, c-format
msgid "%s: invalid callback quantum"
msgstr "número do sinal incorreto"

#: builtins/mapfile.def:318
#, fuzzy
msgid "empty array variable name"
msgstr "%s: variável não vinculada"

#: builtins/mapfile.def:339
msgid "array variable support required"
msgstr ""

#: builtins/printf.def:367
#, c-format
msgid "`%s': missing format character"
msgstr ""

#: builtins/printf.def:544
#, c-format
msgid "`%c': invalid format character"
msgstr ""

#: builtins/printf.def:571
#, c-format
msgid "warning: %s: %s"
msgstr ""

#: builtins/printf.def:750
msgid "missing hex digit for \\x"
msgstr ""

#: builtins/pushd.def:195
#, fuzzy
msgid "no other directory"
msgstr "o novo diretório que ocupa o topo da pilha."

#: builtins/pushd.def:462
#, fuzzy
msgid "<no current directory>"
msgstr "\tnovo diretório atual de trabalho."

#: builtins/pushd.def:506
msgid "directory stack empty"
msgstr ""

#: builtins/pushd.def:508
#, fuzzy
msgid "directory stack index"
msgstr "Estouro na base da pilha de recursividade"

#: builtins/pushd.def:683
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""

#: builtins/pushd.def:705
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""

#: builtins/pushd.def:730
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""

#: builtins/read.def:248
#, c-format
msgid "%s: invalid timeout specification"
msgstr ""

#: builtins/read.def:574
#, fuzzy, c-format
msgid "read error: %d: %s"
msgstr "erro de `pipe': %s"

#: builtins/return.def:73
msgid "can only `return' from a function or sourced script"
msgstr ""

#: builtins/set.def:768
#, fuzzy
msgid "cannot simultaneously unset a function and a variable"
msgstr "somente pode ser usado dentro de funções; faz com que o escopo visível"

#: builtins/set.def:805
#, fuzzy, c-format
msgid "%s: cannot unset"
msgstr "%s: impossível criar: %s"

#: builtins/set.def:812
#, fuzzy, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: impossível criar: %s"

#: builtins/set.def:823
#, fuzzy, c-format
msgid "%s: not an array variable"
msgstr "%s: variável não vinculada"

#: builtins/setattr.def:186
#, fuzzy, c-format
msgid "%s: not a function"
msgstr "%s: função somente para leitura"

#: builtins/shift.def:71 builtins/shift.def:77
#, fuzzy
msgid "shift count"
msgstr "shift [n]"

#: builtins/shopt.def:254
msgid "cannot set and unset shell options simultaneously"
msgstr ""

#: builtins/shopt.def:319
#, c-format
msgid "%s: invalid shell option name"
msgstr ""

#: builtins/source.def:128
msgid "filename argument required"
msgstr ""

#: builtins/source.def:153
#, fuzzy, c-format
msgid "%s: file not found"
msgstr "%s: comando não encontrado"

#: builtins/suspend.def:101
msgid "cannot suspend"
msgstr ""

#: builtins/suspend.def:111
#, fuzzy
msgid "cannot suspend a login shell"
msgstr "Sair de uma shell de login."

#: builtins/type.def:234
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr ""

#: builtins/type.def:255
#, c-format
msgid "%s is a shell keyword\n"
msgstr ""

#: builtins/type.def:274
#, fuzzy, c-format
msgid "%s is a function\n"
msgstr "%s: função somente para leitura"

#: builtins/type.def:296
#, c-format
msgid "%s is a shell builtin\n"
msgstr ""

#: builtins/type.def:317 builtins/type.def:391
#, c-format
msgid "%s is %s\n"
msgstr ""

#: builtins/type.def:337
#, c-format
msgid "%s is hashed (%s)\n"
msgstr ""

#: builtins/ulimit.def:372
#, c-format
msgid "%s: invalid limit argument"
msgstr ""

#: builtins/ulimit.def:398
#, fuzzy, c-format
msgid "`%c': bad command"
msgstr "%c%c: opção incorreta"

#: builtins/ulimit.def:427
#, fuzzy, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: impossível criar: %s"

#: builtins/ulimit.def:453
#, fuzzy
msgid "limit"
msgstr "Tempo limite de CPU excedido"

#: builtins/ulimit.def:465 builtins/ulimit.def:765
#, fuzzy, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: impossível criar: %s"

#: builtins/umask.def:118
#, fuzzy
msgid "octal number"
msgstr "número do sinal incorreto"

#: builtins/umask.def:231
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr ""

#: builtins/umask.def:286
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr ""

#: error.c:89 error.c:320 error.c:322 error.c:324
msgid " line "
msgstr ""

#: error.c:164
#, fuzzy, c-format
msgid "last command: %s\n"
msgstr "`r', o último comando seja executado novamente."

#: error.c:172
#, c-format
msgid "Aborting..."
msgstr ""

#: error.c:405
#, fuzzy
msgid "unknown command error"
msgstr "Erro desconhecido %d"

#: error.c:406
#, fuzzy
msgid "bad command type"
msgstr "usado como nome de um comando."

#: error.c:407
#, fuzzy
msgid "bad connector"
msgstr "conector incorreto `%d'"

#: error.c:408
#, fuzzy
msgid "bad jump"
msgstr "Desvio incorreto %d"

#: error.c:446
#, c-format
msgid "%s: unbound variable"
msgstr "%s: variável não vinculada"

#: eval.c:181
#, fuzzy, c-format
msgid "\atimed out waiting for input: auto-logout\n"
msgstr ""
"%ctempo limite de espera excedido aguardando entrada:\n"
"fim automático da sessão\n"

#: execute_cmd.c:491
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr ""

#: execute_cmd.c:1112
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr ""

#: execute_cmd.c:2011
#, fuzzy
msgid "pipe error"
msgstr "erro de `pipe': %s"

#: execute_cmd.c:4363
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: restrição: não é permitido especificar `/' em nomes de comandos"

#: execute_cmd.c:4454
#, c-format
msgid "%s: command not found"
msgstr "%s: comando não encontrado"

#: execute_cmd.c:4708
#, fuzzy, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: é um diretório"

#: execute_cmd.c:4857
#, fuzzy, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "impossível duplicar fd (descritor de arquivo) %d para fd 0: %s"

#: expr.c:241
msgid "expression recursion level exceeded"
msgstr "excedido o nível de recursividade da expressão"

#: expr.c:265
#, fuzzy
msgid "recursion stack underflow"
msgstr "Estouro na base da pilha de recursividade"

#: expr.c:379
msgid "syntax error in expression"
msgstr "erro de sintaxe na expressão"

#: expr.c:419
msgid "attempted assignment to non-variable"
msgstr "tentativa de atribuição para algo que não é uma variável"

#: expr.c:440 expr.c:445 expr.c:756
msgid "division by 0"
msgstr "divisão por 0"

#: expr.c:471
#, fuzzy
msgid "bug: bad expassign token"
msgstr "Erro de programação: `token' inválido `%d' passado para expassign()"

#: expr.c:513
msgid "`:' expected for conditional expression"
msgstr "`:' esperado para expressão condicional"

#: expr.c:781
msgid "exponent less than 0"
msgstr ""

#: expr.c:826
msgid "identifier expected after pre-increment or pre-decrement"
msgstr ""

#: expr.c:854
msgid "missing `)'"
msgstr "faltando `)'"

#: expr.c:897 expr.c:1175
#, fuzzy
msgid "syntax error: operand expected"
msgstr "erro de sintaxe: fim prematuro do arquivo"

#: expr.c:1177
msgid "syntax error: invalid arithmetic operator"
msgstr ""

#: expr.c:1201
#, fuzzy, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s: %s: %s (erro: o `token' é \"%s\")\n"

#: expr.c:1259
msgid "invalid arithmetic base"
msgstr ""

#: expr.c:1279
msgid "value too great for base"
msgstr "valor muito grande para esta base de numeração"

#: expr.c:1328
#, fuzzy, c-format
msgid "%s: expression error\n"
msgstr "%s: esperado expressão de número inteiro"

#: general.c:61
#, fuzzy
msgid "getcwd: cannot access parent directories"
msgstr "getwd: impossível acessar os diretórios pais (anteriores)"

#: input.c:94 subst.c:4559
#, fuzzy, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "impossível duplicar fd (descritor de arquivo) %d para fd 0: %s"

#: input.c:258
#, fuzzy, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr ""
"impossível alocar novo descritor de arquivo (fd) para a entrada\n"
"do `bash'  a partir do descritor de arquivo (fd) %d: %s"

#: input.c:266
#, fuzzy, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr ""
"check_bash_input: já existe o espaço intermediário (buffer)\n"
"para o novo descritor de arquivo (fd) %d"

#: jobs.c:466
msgid "start_pipeline: pgrp pipe"
msgstr ""

#: jobs.c:887
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr ""

#: jobs.c:1005
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr ""

#: jobs.c:1110
#, c-format
msgid "add_process: process %5ld (%s) in the_pipeline"
msgstr ""

#: jobs.c:1113
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr ""

#: jobs.c:1401
#, fuzzy, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: o identificador do processo (pid) não existe (%d)!\n"

#: jobs.c:1416
#, fuzzy, c-format
msgid "Signal %d"
msgstr "Sinal desconhecido #%d"

#: jobs.c:1430 jobs.c:1455
msgid "Done"
msgstr "Concluído"

#: jobs.c:1435 siglist.c:122
msgid "Stopped"
msgstr "Parado"

#: jobs.c:1439
#, fuzzy, c-format
msgid "Stopped(%s)"
msgstr "Parado"

#: jobs.c:1443
msgid "Running"
msgstr "Executando"

#: jobs.c:1457
#, c-format
msgid "Done(%d)"
msgstr "Concluído(%d)"

#: jobs.c:1459
#, c-format
msgid "Exit %d"
msgstr "Fim da execução com status %d"

#: jobs.c:1462
msgid "Unknown status"
msgstr "Status desconhecido"

#: jobs.c:1549
#, c-format
msgid "(core dumped) "
msgstr "(imagem do núcleo gravada)"

#: jobs.c:1568
#, fuzzy, c-format
msgid "  (wd: %s)"
msgstr "(wd agora: %s)\n"

#: jobs.c:1771
#, fuzzy, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "`setpgid' filho (%d para %d) erro %d: %s\n"

#: jobs.c:2099 nojobs.c:585
#, fuzzy, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: o pid %d não é um filho deste `shell'"

#: jobs.c:2326
#, c-format
msgid "wait_for: No record of process %ld"
msgstr ""

#: jobs.c:2598
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr ""

#: jobs.c:2820
#, c-format
msgid "%s: job has terminated"
msgstr "%s: o trabalho terminou"

#: jobs.c:2829
#, c-format
msgid "%s: job %d already in background"
msgstr ""

#: jobs.c:3492
#, fuzzy, c-format
msgid "%s: line %d: "
msgstr "encaixe (slot) %3d: "

#: jobs.c:3506 nojobs.c:814
#, c-format
msgid " (core dumped)"
msgstr " (imagem do núcleo gravada)"

#: jobs.c:3518 jobs.c:3531
#, c-format
msgid "(wd now: %s)\n"
msgstr "(wd agora: %s)\n"

#: jobs.c:3563
#, fuzzy
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_jobs: getpgrp falhou: %s"

#: jobs.c:3623
#, fuzzy
msgid "initialize_job_control: line discipline"
msgstr "initialize_jobs: disciplina da linha: %s"

#: jobs.c:3633
#, fuzzy
msgid "initialize_job_control: setpgid"
msgstr "initialize_jobs: getpgrp falhou: %s"

#: jobs.c:3661
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr ""

#: jobs.c:3666
msgid "no job control in this shell"
msgstr "nenhum controle de trabalho nesta `shell'"

#: lib/malloc/malloc.c:296
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr ""

#: lib/malloc/malloc.c:312
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""

#: lib/malloc/malloc.c:313
#, fuzzy
msgid "unknown"
msgstr "<desconhecido>"

#: lib/malloc/malloc.c:797
msgid "malloc: block on free list clobbered"
msgstr ""

#: lib/malloc/malloc.c:874
msgid "free: called with already freed block argument"
msgstr ""

#: lib/malloc/malloc.c:877
msgid "free: called with unallocated block argument"
msgstr ""

#: lib/malloc/malloc.c:896
msgid "free: underflow detected; mh_nbytes out of range"
msgstr ""

#: lib/malloc/malloc.c:902
msgid "free: start and end chunk sizes differ"
msgstr ""

#: lib/malloc/malloc.c:1001
msgid "realloc: called with unallocated block argument"
msgstr ""

#: lib/malloc/malloc.c:1016
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr ""

#: lib/malloc/malloc.c:1022
msgid "realloc: start and end chunk sizes differ"
msgstr ""

#: lib/malloc/table.c:177
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr ""

#: lib/malloc/table.c:184
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr ""

#: lib/malloc/table.c:220
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr ""

#: lib/sh/fmtulong.c:101
msgid "invalid base"
msgstr ""

#: lib/sh/netopen.c:168
#, fuzzy, c-format
msgid "%s: host unknown"
msgstr "desconhecido"

#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr ""

#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr ""

#: lib/sh/netopen.c:346
msgid "network operations not supported"
msgstr ""

#: mailcheck.c:433
msgid "You have mail in $_"
msgstr "Você tem mensagem de correio em $_"

#: mailcheck.c:458
msgid "You have new mail in $_"
msgstr "Você tem mensagem nova de correio em $_"

#: mailcheck.c:474
#, c-format
msgid "The mail in %s has been read\n"
msgstr "As mensagens de correio em %s foram lidas\n"

#: make_cmd.c:322
#, fuzzy
msgid "syntax error: arithmetic expression required"
msgstr "erro de sintaxe na expressão"

#: make_cmd.c:324
#, fuzzy
msgid "syntax error: `;' unexpected"
msgstr "erro de sintaxe: fim prematuro do arquivo"

#: make_cmd.c:325
#, fuzzy, c-format
msgid "syntax error: `((%s))'"
msgstr "erro de sintaxe"

#: make_cmd.c:567
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: o tipo da instrução está incorreto %d"

#: make_cmd.c:651
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr ""

#: make_cmd.c:746
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr ""

#: parse.y:2986 parse.y:3218
#, fuzzy, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "encontrado EOF não esperado enquanto procurava por `%c'"

#: parse.y:3722
#, fuzzy
msgid "unexpected EOF while looking for `]]'"
msgstr "encontrado EOF não esperado enquanto procurava por `%c'"

#: parse.y:3727
#, fuzzy, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "erro de sintaxe próximo do `token' não esperado `%s'"

#: parse.y:3731
#, fuzzy
msgid "syntax error in conditional expression"
msgstr "erro de sintaxe na expressão"

#: parse.y:3809
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr ""

#: parse.y:3813
#, fuzzy
msgid "expected `)'"
msgstr "esperado `)'"

#: parse.y:3841
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr ""

#: parse.y:3845
msgid "unexpected argument to conditional unary operator"
msgstr ""

#: parse.y:3885
#, fuzzy, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "%s: esperado operador binário"

#: parse.y:3889
#, fuzzy
msgid "conditional binary operator expected"
msgstr "%s: esperado operador binário"

#: parse.y:3906
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr ""

#: parse.y:3910
msgid "unexpected argument to conditional binary operator"
msgstr ""

#: parse.y:3921
#, fuzzy, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "`:' esperado para expressão condicional"

#: parse.y:3924
#, fuzzy, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "`:' esperado para expressão condicional"

#: parse.y:3928
#, fuzzy, c-format
msgid "unexpected token %d in conditional command"
msgstr "`:' esperado para expressão condicional"

#: parse.y:5195
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "erro de sintaxe próximo do `token' não esperado `%s'"

#: parse.y:5213
#, fuzzy, c-format
msgid "syntax error near `%s'"
msgstr "erro de sintaxe próximo do `token' não esperado `%s'"

#: parse.y:5223
msgid "syntax error: unexpected end of file"
msgstr "erro de sintaxe: fim prematuro do arquivo"

#: parse.y:5223
msgid "syntax error"
msgstr "erro de sintaxe"

#: parse.y:5285
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Use \"%s\" para sair da `shell'.\n"

#: parse.y:5447
#, fuzzy
msgid "unexpected EOF while looking for matching `)'"
msgstr "encontrado EOF não esperado enquanto procurava por `%c'"

#: pcomplete.c:1018
#, c-format
msgid "completion: function `%s' not found"
msgstr ""

#: pcomplib.c:179
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr ""

#: print_cmd.c:285
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: conector incorreto `%d'"

#: print_cmd.c:1348
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr ""

#: redir.c:105
msgid "file descriptor out of range"
msgstr ""

#: redir.c:148
#, fuzzy, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: Redirecionamento ambíguo"

#: redir.c:152
#, fuzzy, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: Impossível sobrescrever arquivo existente"

#: redir.c:157
#, fuzzy, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: restrição: não é permitido especificar `/' em nomes de comandos"

#: redir.c:162
#, fuzzy, c-format
msgid "cannot create temp file for here-document: %s"
msgstr "impossível criar `pipe' para a substituição do processo: %s"

#: redir.c:517
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr ""

#: redir.c:1023
#, fuzzy
msgid "redirection error: cannot duplicate fd"
msgstr "erro de redirecionamento"

#: shell.c:328
msgid "could not find /tmp, please create!"
msgstr ""

#: shell.c:332
msgid "/tmp must be a valid directory name"
msgstr ""

#: shell.c:876
#, fuzzy, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: opção incorreta"

#: shell.c:1638
msgid "I have no name!"
msgstr "Eu não tenho nome!"

#: shell.c:1778
#, fuzzy, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU %s, versão %s\n"

#: shell.c:1779
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Utilização:\t%s [opção-longa-GNU] [opção] ...\n"
"\t%s [opção-longa-GNU] [opção] arquivo-de-script ...\n"

#: shell.c:1781
msgid "GNU long options:\n"
msgstr "opções-longas-GNU:\n"

#: shell.c:1785
msgid "Shell options:\n"
msgstr "Opções da `shell':\n"

#: shell.c:1786
#, fuzzy
msgid "\t-irsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-irsD ou -c comando\t\t(somente para chamada)\n"

#: shell.c:1801
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s ou -o opção\n"

#: shell.c:1807
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr ""
"Digite `%s -c \"help set\"' para mais informações sobre as opções da "
"`shell'.\n"

#: shell.c:1808
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr ""
"Digite `%s -c help' para mais informações sobre os comandos internos do "
"`shell'.\n"

#: shell.c:1809
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr ""

#: sig.c:583
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr ""

#: siglist.c:47
msgid "Bogus signal"
msgstr "Sinal falso"

#: siglist.c:50
msgid "Hangup"
msgstr "Hangup"

#: siglist.c:54
msgid "Interrupt"
msgstr "Interromper"

#: siglist.c:58
msgid "Quit"
msgstr "Sair"

#: siglist.c:62
msgid "Illegal instruction"
msgstr "Instrução ilegal"

#: siglist.c:66
msgid "BPT trace/trap"
msgstr "BPT Rastreamento/Captura (BPT trace/trap)"

#: siglist.c:74
msgid "ABORT instruction"
msgstr "Instrução ABORT"

#: siglist.c:78
msgid "EMT instruction"
msgstr "Instrução EMT"

#: siglist.c:82
msgid "Floating point exception"
msgstr "Exceção de ponto flutuante"

#: siglist.c:86
msgid "Killed"
msgstr "Morto (Killed)"

#: siglist.c:90
msgid "Bus error"
msgstr "Erro do barramento"

#: siglist.c:94
msgid "Segmentation fault"
msgstr "Falha de segmentação"

#: siglist.c:98
msgid "Bad system call"
msgstr "Chamada incorreta do sistema"

#: siglist.c:102
msgid "Broken pipe"
msgstr "`Pipe' partido (Escrita sem leitura)"

#: siglist.c:106
msgid "Alarm clock"
msgstr "Relógio de alarme"

#: siglist.c:110
#, fuzzy
msgid "Terminated"
msgstr "exibida."

#: siglist.c:114
msgid "Urgent IO condition"
msgstr "Condição urgente de Entrada/Saída"

#: siglist.c:118
msgid "Stopped (signal)"
msgstr "Parado (sinal)"

#: siglist.c:126
msgid "Continue"
msgstr "Continuar"

#: siglist.c:134
msgid "Child death or stop"
msgstr "Processo filho parado ou terminado"

#: siglist.c:138
msgid "Stopped (tty input)"
msgstr "Parado (entrada tty)"

#: siglist.c:142
msgid "Stopped (tty output)"
msgstr "Parado (saída tty)"

#: siglist.c:146
msgid "I/O ready"
msgstr "Entrada/Saída pronta"

#: siglist.c:150
msgid "CPU limit"
msgstr "Tempo limite de CPU excedido"

#: siglist.c:154
msgid "File limit"
msgstr "Tamanho limite do arquivo excedido"

#: siglist.c:158
msgid "Alarm (virtual)"
msgstr "Alarme virtual de tempo"

#: siglist.c:162
msgid "Alarm (profile)"
msgstr "Alarme (profile)"

#: siglist.c:166
msgid "Window changed"
msgstr "Janela mudada"

#: siglist.c:170
msgid "Record lock"
msgstr "Registro bloqueado (lock)"

#: siglist.c:174
msgid "User signal 1"
msgstr "Sinal 1 definido pelo usuário"

#: siglist.c:178
msgid "User signal 2"
msgstr "Sinal 2 definido pelo usuário"

#: siglist.c:182
msgid "HFT input data pending"
msgstr "entrada de dados HFT pendente"

#: siglist.c:186
msgid "power failure imminent"
msgstr "falha iminente de energia"

#: siglist.c:190
msgid "system crash imminent"
msgstr "falha iminente do sistema"

#: siglist.c:194
msgid "migrate process to another CPU"
msgstr "migrar o processo para outra CPU"

#: siglist.c:198
msgid "programming error"
msgstr "erro de programação"

#: siglist.c:202
msgid "HFT monitor mode granted"
msgstr "modo monitor HFT autorizado"

#: siglist.c:206
msgid "HFT monitor mode retracted"
msgstr "modo monitor HFT rescindido"

#: siglist.c:210
msgid "HFT sound sequence has completed"
msgstr "a seqüência de som HFT foi completada"

#: siglist.c:214
msgid "Information request"
msgstr ""

#: siglist.c:222
msgid "Unknown Signal #"
msgstr "Sinal desconhecido #"

#: siglist.c:224
#, c-format
msgid "Unknown Signal #%d"
msgstr "Sinal desconhecido #%d"

#: subst.c:1181 subst.c:1302
#, fuzzy, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "substituição incorreta: nenhum `%s' em %s"

#: subst.c:2458
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: impossível atribuir uma lista a um membro de uma matriz (array)"

#: subst.c:4456 subst.c:4472
#, fuzzy
msgid "cannot make pipe for process substitution"
msgstr "impossível criar `pipe' para a substituição do processo: %s"

#: subst.c:4504
#, fuzzy
msgid "cannot make child for process substitution"
msgstr "impossível criar um processo filho para a substituição do processo: %s"

#: subst.c:4549
#, fuzzy, c-format
msgid "cannot open named pipe %s for reading"
msgstr "impossível abrir o `named pipe' %s para %s: %s"

#: subst.c:4551
#, fuzzy, c-format
msgid "cannot open named pipe %s for writing"
msgstr "impossível abrir o `named pipe' %s para %s: %s"

#: subst.c:4569
#, fuzzy, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr ""
"impossível duplicar o `named pipe' %s\n"
"como descritor de arquivo (fd) %d: %s"

#: subst.c:4765
#, fuzzy
msgid "cannot make pipe for command substitution"
msgstr "impossível construir `pipes' para substituição do comando: %s"

#: subst.c:4799
#, fuzzy
msgid "cannot make child for command substitution"
msgstr "impossível criar um processo filho para substituição do comando: %s"

#: subst.c:4816
#, fuzzy
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr ""
"command_substitute: impossível duplicar o `pipe' como\n"
"descritor de arquivo (fd) 1: %s"

#: subst.c:5318
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: parâmetro nulo ou não inicializado"

#: subst.c:5608
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: expressão de substring < 0"

#: subst.c:6660
#, c-format
msgid "%s: bad substitution"
msgstr "%s: substituição incorreta"

#: subst.c:6740
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: impossível atribuir desta maneira"

#: subst.c:7499
#, fuzzy, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "substituição incorreta: nenhum `%s' em %s"

#: subst.c:8375
#, c-format
msgid "no match: %s"
msgstr ""

#: test.c:145
msgid "argument expected"
msgstr "esperado argumento"

#: test.c:154
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: esperado expressão de número inteiro"

#: test.c:262
msgid "`)' expected"
msgstr "esperado `)'"

#: test.c:264
#, c-format
msgid "`)' expected, found %s"
msgstr "esperado `)', encontrado %s"

#: test.c:279 test.c:688 test.c:691
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: esperado operador unário"

#: test.c:444 test.c:731
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: esperado operador binário"

#: test.c:806
msgid "missing `]'"
msgstr "faltando `]'"

#: trap.c:201
#, fuzzy
msgid "invalid signal number"
msgstr "número do sinal incorreto"

#: trap.c:324
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr ""

#: trap.c:328
#, c-format
msgid ""
"run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr ""

#: trap.c:372
#, fuzzy, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: Sinal incorreto %d"

#: variables.c:358
#, c-format
msgid "error importing function definition for `%s'"
msgstr "erro ao importar a definição da função para `%s'"

#: variables.c:736
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr ""

#: variables.c:1898
msgid "make_local_variable: no function context at current scope"
msgstr ""

#: variables.c:3127
msgid "all_local_variables: no function context at current scope"
msgstr ""

#: variables.c:3344 variables.c:3353
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr ""

#: variables.c:3359
#, c-format
msgid "no `=' in exportstr for %s"
msgstr ""

#: variables.c:3794
msgid "pop_var_context: head of shell_variables not a function context"
msgstr ""

#: variables.c:3807
msgid "pop_var_context: no global_variables context"
msgstr ""

#: variables.c:3881
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr ""

#: version.c:46
msgid "Copyright (C) 2009 Free Software Foundation, Inc."
msgstr ""

#: version.c:47
msgid ""
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl."
"html>\n"
msgstr ""

#: version.c:86
#, fuzzy, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU %s, versão %s\n"

#: version.c:91
#, c-format
msgid "This is free software; you are free to change and redistribute it.\n"
msgstr ""

#: version.c:92
#, c-format
msgid "There is NO WARRANTY, to the extent permitted by law.\n"
msgstr ""

#: xmalloc.c:92
#, c-format
msgid "xmalloc: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "xmalloc: impossível alocar %lu bytes (%lu bytes alocados)"

#: xmalloc.c:94
#, fuzzy, c-format
msgid "xmalloc: cannot allocate %lu bytes"
msgstr "xmalloc: impossível alocar %lu bytes (%lu bytes alocados)"

#: xmalloc.c:114
#, c-format
msgid "xrealloc: cannot reallocate %lu bytes (%lu bytes allocated)"
msgstr "xrealloc: impossível realocar %lu bytes (%lu bytes alocados)"

#: xmalloc.c:116
#, fuzzy, c-format
msgid "xrealloc: cannot allocate %lu bytes"
msgstr "xrealloc: impossível realocar %lu bytes (%lu bytes alocados)"

#: xmalloc.c:150
#, fuzzy, c-format
msgid "xmalloc: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "xmalloc: impossível alocar %lu bytes (%lu bytes alocados)"

#: xmalloc.c:152
#, fuzzy, c-format
msgid "xmalloc: %s:%d: cannot allocate %lu bytes"
msgstr "xmalloc: impossível alocar %lu bytes (%lu bytes alocados)"

#: xmalloc.c:174
#, fuzzy, c-format
msgid "xrealloc: %s:%d: cannot reallocate %lu bytes (%lu bytes allocated)"
msgstr "xrealloc: impossível realocar %lu bytes (%lu bytes alocados)"

#: xmalloc.c:176
#, fuzzy, c-format
msgid "xrealloc: %s:%d: cannot allocate %lu bytes"
msgstr "xrealloc: impossível realocar %lu bytes (%lu bytes alocados)"

#: builtins.c:43
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [NOME[=VALOR] ... ]"

#: builtins.c:47
#, fuzzy
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] [NOME ...]"

#: builtins.c:51
#, fuzzy
msgid ""
"bind [-lpvsPVS] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-"
"x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr ""
"bind [-lpvsPVS] [-m MAPA-TECLAS] [-f ARQUIVO] [-q NOME-FUNÇÃO] [-r SEQ-"
"TECLAS] [SEQ-TECLAS:FUNÇÃO-DE-LEITURA-DE-LINHA]"

#: builtins.c:54
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:56
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:58
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [COMANDO-INTERNO-DA-SHELL [ARG ...]]"

#: builtins.c:61
#, fuzzy
msgid "caller [expr]"
msgstr "test [EXPR]"

#: builtins.c:64
#, fuzzy
msgid "cd [-L|-P] [dir]"
msgstr "cd [-PL] [DIR]"

#: builtins.c:66
#, fuzzy
msgid "pwd [-LP]"
msgstr "pwd [-PL]"

#: builtins.c:68
msgid ":"
msgstr ":"

#: builtins.c:70
msgid "true"
msgstr ""

#: builtins.c:72
msgid "false"
msgstr ""

#: builtins.c:74
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] COMANDO [ARG ...]"

#: builtins.c:76
#, fuzzy
msgid "declare [-aAfFilrtux] [-p] [name[=value] ...]"
msgstr "declare [-afFrxi] [-p] NOME[=VALOR] ..."

#: builtins.c:78
#, fuzzy
msgid "typeset [-aAfFilrtux] [-p] name[=value] ..."
msgstr "typeset [-afFrxi] [-p] NOME[=VALOR] ..."

#: builtins.c:80
#, fuzzy
msgid "local [option] name[=value] ..."
msgstr "local NOME[=VALOR] ..."

#: builtins.c:83
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [ARG ...]"

#: builtins.c:87
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [ARG ...]"

#: builtins.c:90
#, fuzzy
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-pnds] [-a] [-f ARQUIVO] [NOME ...]"

#: builtins.c:92
msgid "eval [arg ...]"
msgstr "eval [ARG ...]"

#: builtins.c:94
msgid "getopts optstring name [arg]"
msgstr "getopts OPÇÕES NOME [ARG]"

#: builtins.c:96
#, fuzzy
msgid "exec [-cl] [-a name] [command [arguments ...]] [redirection ...]"
msgstr "exec [-cl] [-a NOME] ARQUIVO [REDIRECIONAMENTO ...]"

#: builtins.c:98
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:100
#, fuzzy
msgid "logout [n]"
msgstr "logout"

#: builtins.c:103
#, fuzzy
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr ""
"fc [-e EDITOR] [-nlr] [PRIMEIRO] [ÚLTIMO] ou fc -s [ANTIGO=NOVO] [COMANDO]"

#: builtins.c:107
msgid "fg [job_spec]"
msgstr "fg [JOB-ESPECIFICADO]"

#: builtins.c:111
#, fuzzy
msgid "bg [job_spec ...]"
msgstr "bg [JOB-ESPECIFICADO]"

#: builtins.c:114
#, fuzzy
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-r] [-p CAMINHO] [NOME ...]"

#: builtins.c:117
#, fuzzy
msgid "help [-ds] [pattern ...]"
msgstr "help [PADRÃO ...]"

#: builtins.c:121
#, fuzzy
msgid ""
"history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg "
"[arg...]"
msgstr ""
"history [-c] [n] ou history -awrn [ARQUIVO] ou history -ps ARG [ARG...]"

#: builtins.c:125
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [JOB-ESPECIFICADO ...] ou jobs -x COMANDO [ARGS]"

#: builtins.c:129
#, fuzzy
msgid "disown [-h] [-ar] [jobspec ...]"
msgstr "disown [JOB-ESPECIFICADO ...]"

#: builtins.c:132
#, fuzzy
msgid ""
"kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l "
"[sigspec]"
msgstr ""
"kill [-s SIGSPEC | -n SIGNUM | -SIGSPEC] [PID | JOB]... ou kill -l [SIGSPEC]"

#: builtins.c:134
msgid "let arg [arg ...]"
msgstr "let ARG [ARG ...]"

#: builtins.c:136
msgid ""
"read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-p prompt] [-t "
"timeout] [-u fd] [name ...]"
msgstr ""

#: builtins.c:138
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:140
#, fuzzy
msgid "set [--abefhkmnptuvxBCHP] [-o option-name] [arg ...]"
msgstr "set [--abefhkmnptuvxBCHP] [-o OPÇÃO] [ARG ...]"

#: builtins.c:142
msgid "unset [-f] [-v] [name ...]"
msgstr "unset [-f] [-v] [NOME ...]"

#: builtins.c:144
#, fuzzy
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-nf] [NOME ...] ou export -p"

#: builtins.c:146
#, fuzzy
msgid "readonly [-af] [name[=value] ...] or readonly -p"
msgstr "readonly [-anf] [NOME ...] ou readonly -p"

#: builtins.c:148
#, fuzzy
msgid "shift [n]"
msgstr "exit [n]"

#: builtins.c:150
#, fuzzy
msgid "source filename [arguments]"
msgstr "arquivo fonte"

#: builtins.c:152
#, fuzzy
msgid ". filename [arguments]"
msgstr ". ARQUIVO"

#: builtins.c:155
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:158
msgid "test [expr]"
msgstr "test [EXPR]"

#: builtins.c:160
msgid "[ arg... ]"
msgstr "[ ARG... ]"

#: builtins.c:162
msgid "times"
msgstr "times"

#: builtins.c:164
#, fuzzy
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [ARG] [SINAL-ESPEC] ou trap -l"

#: builtins.c:166
#, fuzzy
msgid "type [-afptP] name [name ...]"
msgstr "type [-apt] NOME [NOME ...]"

#: builtins.c:169
#, fuzzy
msgid "ulimit [-SHacdefilmnpqrstuvx] [limit]"
msgstr "ulimit [-SHacdfmstpnuv] [LIMITE]"

#: builtins.c:172
#, fuzzy
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-S] [MODO]"

#: builtins.c:175
#, fuzzy
msgid "wait [id]"
msgstr "wait [n]"

#: builtins.c:179
#, fuzzy
msgid "wait [pid]"
msgstr "wait [n]"

#: builtins.c:182
#, fuzzy
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for NOME [in PALAVRAS ... ;] do COMANDOS; done"

#: builtins.c:184
#, fuzzy
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for NOME [in PALAVRAS ... ;] do COMANDOS; done"

#: builtins.c:186
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select NOME [in PALAVRAS ... ;] do COMANDOS; done"

#: builtins.c:188
msgid "time [-p] pipeline"
msgstr ""

#: builtins.c:190
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case PALAVRA in [PADRÃO [| PADRÃO]...) COMANDOS ;;]... esac"

#: builtins.c:192
msgid ""
"if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else "
"COMMANDS; ] fi"
msgstr ""
"if COMANDOS; then COMANDOS; [ elif COMANDOS; then COMANDOS; ]... [ else "
"COMANDOS; ] fi"

#: builtins.c:194
msgid "while COMMANDS; do COMMANDS; done"
msgstr "while COMANDOS; do COMANDOS; done"

#: builtins.c:196
msgid "until COMMANDS; do COMMANDS; done"
msgstr "until COMANDOS; do COMANDOS; done"

#: builtins.c:198
msgid "coproc [NAME] command [redirections]"
msgstr ""

#: builtins.c:200
#, fuzzy
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function NOME { COMANDOS ; } ou NOME () { COMANDOS ; }"

#: builtins.c:202
#, fuzzy
msgid "{ COMMANDS ; }"
msgstr "{ COMANDOS }"

#: builtins.c:204
#, fuzzy
msgid "job_spec [&]"
msgstr "fg [JOB-ESPECIFICADO]"

#: builtins.c:206
#, fuzzy
msgid "(( expression ))"
msgstr "esperado uma expressão"

#: builtins.c:208
#, fuzzy
msgid "[[ expression ]]"
msgstr "esperado uma expressão"

#: builtins.c:210
#, fuzzy
msgid "variables - Names and meanings of some shell variables"
msgstr "As variáveis da `shell' podem ser operandos.  O nome da variável é"

#: builtins.c:213
#, fuzzy
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [DIR | +N | -N] [-n]"

#: builtins.c:217
#, fuzzy
msgid "popd [-n] [+N | -N]"
msgstr "popd [+N | -N] [-n]"

#: builtins.c:221
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:224
#, fuzzy
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o OPÇÃO-LONGA] NOME-OPÇÃO [NOME-OPÇÃO...]"

#: builtins.c:226
msgid "printf [-v var] format [arguments]"
msgstr ""

#: builtins.c:229
msgid ""
"complete [-abcdefgjksuv] [-pr] [-o option] [-A action] [-G globpat] [-W "
"wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] "
"[name ...]"
msgstr ""

#: builtins.c:233
msgid ""
"compgen [-abcdefgjksuv] [-o option]  [-A action] [-G globpat] [-W wordlist]  "
"[-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr ""

#: builtins.c:237
#, fuzzy
msgid "compopt [-o|+o option] [name ...]"
msgstr "type [-apt] NOME [NOME ...]"

#: builtins.c:240
msgid ""
"mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c "
"quantum] [array]"
msgstr ""

#: builtins.c:242
msgid ""
"readarray [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c "
"quantum] [array]"
msgstr ""

#: builtins.c:254
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tPrint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has "
"been\n"
"    defined."
msgstr ""

#: builtins.c:276
#, fuzzy
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions.\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Remove NOMEs da lista de aliases definidos. Se a opção -a for fornecida,"

#: builtins.c:289
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their "
"values\n"
"      -s                 List key sequences that invoke macros and their "
"values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named "
"function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""

#: builtins.c:326
#, fuzzy
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr "Prossegue no próximo ciclo do laço FOR, WHILE ou UNTIL envolvente."

#: builtins.c:338
#, fuzzy
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr "Prossegue no próximo ciclo do laço FOR, WHILE ou UNTIL envolvente."

#: builtins.c:350
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the "
"function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin.."
msgstr ""

#: builtins.c:365
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""

#: builtins.c:383
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of "
"the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory "
"containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon "
"(:).\n"
"    A null directory name is the same as the current directory.  If DIR "
"begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is "
"set,\n"
"    the word is assumed to be  a variable name.  If that variable has a "
"value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"        -L\tforce symbolic links to be followed\n"
"        -P\tuse the physical directory structure without following symbolic\n"
"    \tlinks\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed; non-zero otherwise."
msgstr ""

#: builtins.c:411
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""

#: builtins.c:428
#, fuzzy
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Nenhum efeito; o comando não faz nada.  Retorna zero no código de saída."

#: builtins.c:439
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""

#: builtins.c:448
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""

#: builtins.c:457
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke "
"commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p\tuse a default value for PATH that is guaranteed to find all of\n"
"    \tthe standard utilities\n"
"      -v\tprint a description of COMMAND similar to the `type' builtin\n"
"      -V\tprint a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""

#: builtins.c:476
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \tsource file when debugging)\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert NAMEs to lower case on assignment\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert NAMEs to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the "
"`local'\n"
"    command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""

#: builtins.c:512
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Obsolete.  See `help declare'."
msgstr ""

#: builtins.c:520
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, an error occurs,\n"
"    or the shell is not executing a function."
msgstr ""

#: builtins.c:537
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \tcan be one or two hex digits\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""

#: builtins.c:571
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""

#: builtins.c:586
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""

#: builtins.c:614
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the "
"shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""

#: builtins.c:626
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters ($0 - $9), but if\n"
"    more arguments are given, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""

#: builtins.c:668
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not "
"specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\t\texecute COMMAND with an empty environment\n"
"      -l\t\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, "
"unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error "
"occurs."
msgstr ""

#: builtins.c:689
#, fuzzy
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr "Sair da `shell' com status igual a N.  Se N for omitido, o status"

#: builtins.c:698
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not "
"executed\n"
"    in a login shell."
msgstr ""

#: builtins.c:708
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history "
"list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then "
"EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error "
"occurs."
msgstr ""

#: builtins.c:738
#, fuzzy
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Colocar JOB-ESPECIFICADO no primeiro plano, e torná-lo o trabalho atual."

#: builtins.c:753
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if "
"they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's "
"notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""

#: builtins.c:767
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is "
"displayed.\n"
"    \n"
"    Options:\n"
"      -d\t\tforget the remembered location of each NAME\n"
"      -l\t\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME is the full pathname of NAME\n"
"      -r\t\tforget all remembered locations\n"
"      -t\t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\t\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""

#: builtins.c:792
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifiying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is "
"given."
msgstr ""

#: builtins.c:816
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at offset OFFSET.\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"      -r\tread the history file and append the contents to the history\n"
"    \tlist\n"
"      -w\twrite the current history to the history file\n"
"    \tand append them to the history list\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if $HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the $HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed "
"otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""

#: builtins.c:852
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlist only processes that have changed status since the last\n"
"    \tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""

#: builtins.c:879
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""

#: builtins.c:898
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \tassumed to be signal numbers for which names should be listed\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""

#: builtins.c:921
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are "
"listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise.."
msgstr ""

#: builtins.c:966
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with "
"word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as "
"word\n"
"    delimiters.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY "
"variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\t\tuse Readline to obtain the line in an interactive shell\n"
"      -i text\tUse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\t\tdo not allow backslashes to escape any characters\n"
"      -s\t\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of input "
"is\n"
"    \t\tnot read withint TIMEOUT seconds.  The value of the TMOUT\n"
"    \t\tvariable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns success only\n"
"    \t\tif input is available on the specified file descriptor.  The\n"
"    \t\texit status is greater than 128 if the timeout is exceeded\n"
"      -u fd\t\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times "
"out,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""

#: builtins.c:1006
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""

#: builtins.c:1019
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero "
"status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not follow symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG trap is inherited by shell functions.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""

#: builtins.c:1101
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that "
"fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""

#: builtins.c:1121
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before "
"exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""

#: builtins.c:1140
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""

#: builtins.c:1161
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""

#: builtins.c:1173 builtins.c:1188
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""

#: builtins.c:1204
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""

#: builtins.c:1220
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators as well, and numeric comparison operators.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last "
"read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 "
"lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""

#: builtins.c:1296
#, fuzzy
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr "argumento deve ser o literal `]', para fechar o `[' de abertura."

#: builtins.c:1305
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of "
"its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""

#: builtins.c:1317
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives "
"signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  "
"If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands "
"associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal "
"number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is "
"given."
msgstr ""

#: builtins.c:1349
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \tincludes aliases, builtins, and functions, if and only if\n"
"    \tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \tbuiltin, or function, and returns the name of the disk file\n"
"    \tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \tor nothing if `type -t NAME' would not return `file'.\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t`function', `builtin', `file' or `', if NAME is an alias, shell\n"
"    \treserved word, shell function, shell builtin, disk file, or not\n"
"    \tfound, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not "
"found."
msgstr ""

#: builtins.c:1380
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and "
"processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""

#: builtins.c:1425
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""

#: builtins.c:1445
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for the process identified by ID, which may be a process ID or a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a a job specification, waits for all "
"processes\n"
"    in the job's pipeline.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of ID; fails if ID is invalid or an invalid option "
"is\n"
"    given."
msgstr ""

#: builtins.c:1463
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for the specified process and reports its termination status.  If\n"
"    PID is not given, all currently active child processes are waited for,\n"
"    and the return code is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of ID; fails if ID is invalid or an invalid option "
"is\n"
"    given."
msgstr ""

#: builtins.c:1478
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1492
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1510
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1531
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""

#: builtins.c:1548
#, fuzzy
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Executar seletivamente COMANDOS tomando por base a correspondência entre"

#: builtins.c:1560
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then "
"the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list "
"is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  "
"Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of "
"the\n"
"    entire construct is the exit status of the last command executed, or "
"zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1577
#, fuzzy
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS as long as the final command in the\n"
"    `while' COMMANDS has an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr "Expande e executa COMANDOS enquanto o comando final nos"

#: builtins.c:1589
#, fuzzy
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS as long as the final command in the\n"
"    `until' COMMANDS has an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr "Expande e executa COMANDOS enquanto o comando final nos"

#: builtins.c:1601
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of COMMAND."
msgstr ""

#: builtins.c:1615
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is "
"invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""

#: builtins.c:1629
#, fuzzy
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr "Executa um conjunto de comandos agrupando-os.  Esta é uma forma de"

#: builtins.c:1641
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""

#: builtins.c:1656
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to \"let EXPRESSION\".\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""

#: builtins.c:1668
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the "
"conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries "
"used\n"
"    by the `test' builtin, and may be combined using the following "
"operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""

#: builtins.c:1694
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""

#: builtins.c:1751
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""

#: builtins.c:1785
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""

#: builtins.c:1815
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""

#: builtins.c:1844
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list all shell options with an indication of whether or not "
"each\n"
"    is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""

#: builtins.c:1865
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: "
"plain\n"
"    characters, which are simply copied to standard output; character "
"escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next "
"successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in printf"
"(1)\n"
"    and printf(3), printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or "
"assignment\n"
"    error occurs."
msgstr ""

#: builtins.c:1892
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no "
"options\n"
"    are supplied, existing completion specifications are printed in a way "
"that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \tNAMEs are supplied, all completion specifications\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""

#: builtins.c:1915
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches "
"against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""

#: builtins.c:1930
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are "
"supplied,\n"
"    the completion currently begin executed.  If no OPTIONs are givenm, "
"print\n"
"    the completion options for each NAME or the current completion "
"specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""

#: builtins.c:1958
msgid ""
"Read lines from the standard input into an array variable.\n"
"    \n"
"    Read lines from the standard input into the array variable ARRAY, or "
"from\n"
"    file descriptor FD if the -u option is supplied.  The variable MAPFILE "
"is\n"
"    the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are "
"copied.\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default "
"index is 0.\n"
"      -s count \tDiscard the first COUNT lines read.\n"
"      -t\t\tRemove a trailing newline from each line read.\n"
"      -u fd\t\tRead lines from file descriptor FD instead of the standard "
"input.\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read.\n"
"      -c quantum\tSpecify the number of lines read between each call to "
"CALLBACK.\n"
"    \n"
"    Arguments:\n"
"      ARRAY\t\tArray variable name to use for file data.\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned as an additional argument.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY "
"before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly."
msgstr ""

#: builtins.c:1990
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""

#~ msgid "Display the list of currently remembered directories.  Directories"
#~ msgstr "Exibe a lista atual de diretórios memorizados. Os diretórios são"

#~ msgid "find their way onto the list with the `pushd' command; you can get"
#~ msgstr "introduzidos na lista através do comando `pushd'; os diretórios são"

#~ msgid "back up through the list with the `popd' command."
#~ msgstr "removidos da lista através do comando `popd'."

#~ msgid ""
#~ "The -l flag specifies that `dirs' should not print shorthand versions"
#~ msgstr "A opção -l especifica que `dirs' não deve exibir a versão resumida"

#~ msgid ""
#~ "of directories which are relative to your home directory.  This means"
#~ msgstr ""
#~ "dos diretórios relativos ao seu diretório `home'. Isto significa que"

#~ msgid "that `~/bin' might be displayed as `/homes/bfox/bin'.  The -v flag"
#~ msgstr ""
#~ "`~/bin' deve ser exibido como `/home/você/bin'.  A opção -v faz com que"

#~ msgid "causes `dirs' to print the directory stack with one entry per line,"
#~ msgstr "`dirs' exiba a pilha de diretórios com uma entrada por linha,"

#~ msgid ""
#~ "prepending the directory name with its position in the stack.  The -p"
#~ msgstr "antecedendo o nome do diretório com a sua posição na pilha. A opção"

#~ msgid "flag does the same thing, but the stack position is not prepended."
#~ msgstr "-p faz a mesma coisa, mas a posição na pilha não é exibida. A opção"

#~ msgid ""
#~ "The -c flag clears the directory stack by deleting all of the elements."
#~ msgstr "-c limpa a pilha de diretórios apagando todos os seus elementos."

#, fuzzy
#~ msgid ""
#~ "+N   displays the Nth entry counting from the left of the list shown by"
#~ msgstr ""
#~ "+N\texibe a n-ésima entrada contada a partir da esquerda da lista exibida"

#, fuzzy
#~ msgid "     dirs when invoked without options, starting with zero."
#~ msgstr "\tpor `dirs', quando este é chamado sem opções, começando por zero."

#, fuzzy
#~ msgid ""
#~ "-N   displays the Nth entry counting from the right of the list shown by"
#~ msgstr ""
#~ "-N\texibe a n-ésima entrada contada a partir da direita da lista exibida"

#~ msgid "Adds a directory to the top of the directory stack, or rotates"
#~ msgstr "Adiciona o diretório no topo da pilha de diretórios, ou rotaciona a"

#~ msgid "the stack, making the new top of the stack the current working"
#~ msgstr ""
#~ "pilha, fazendo o diretório atual de trabalho ficar no topo da pilha."

#~ msgid "directory.  With no arguments, exchanges the top two directories."
#~ msgstr "Sem nenhum argumento, troca os dois diretórios do topo."

#, fuzzy
#~ msgid "+N   Rotates the stack so that the Nth directory (counting"
#~ msgstr ""
#~ "+N\tRotaciona a pilha de tal forma que o n-ésimo diretório (contado a"

#, fuzzy
#~ msgid "     from the left of the list shown by `dirs', starting with"
#~ msgstr "\tpartir da esquerda da lista exibida por `dirs') fique no topo."

#, fuzzy
#~ msgid "     zero) is at the top."
#~ msgstr "\tpartir da direita) fique no topo."

#, fuzzy
#~ msgid "-N   Rotates the stack so that the Nth directory (counting"
#~ msgstr ""
#~ "-N\tRotaciona a pilha de tal forma que o n-ésimo diretório (contado a"

#, fuzzy
#~ msgid "     from the right of the list shown by `dirs', starting with"
#~ msgstr "\tpartir da esquerda da lista exibida por `dirs') fique no topo."

#, fuzzy
#~ msgid "-n   suppress the normal change of directory when adding directories"
#~ msgstr "-n\tsuprime a troca normal de diretório ao se adicionar diretórios"

#, fuzzy
#~ msgid "     to the stack, so only the stack is manipulated."
#~ msgstr "\tà pilha, fazendo com que somente a pilha seja manipulada."

#, fuzzy
#~ msgid "dir  adds DIR to the directory stack at the top, making it the"
#~ msgstr "dir\tadiciona DIR à pilha de diretórios, no topo, tornando-o o"

#, fuzzy
#~ msgid "     new current working directory."
#~ msgstr "\tnovo diretório atual de trabalho."

#~ msgid "You can see the directory stack with the `dirs' command."
#~ msgstr "Você pode exibir a pilha de diretórios através do comando `dirs'."

#~ msgid "Removes entries from the directory stack.  With no arguments,"
#~ msgstr "Remove entradas da pilha de diretórios.  Sem nenhum argumento,"

#~ msgid "removes the top directory from the stack, and cd's to the new"
#~ msgstr "remove o diretório que está no topo da pilha, e executa `cd' para"

#~ msgid "top directory."
#~ msgstr "o novo diretório que ocupa o topo da pilha."

#, fuzzy
#~ msgid "+N   removes the Nth entry counting from the left of the list"
#~ msgstr "+N\tremove a n-ésima entrada contada a partir da esquerda da lista"

#, fuzzy
#~ msgid "     shown by `dirs', starting with zero.  For example: `popd +0'"
#~ msgstr "\texibida por `dirs', começando por zero.  Por exemplo: `popd +0'"

#, fuzzy
#~ msgid "     removes the first directory, `popd +1' the second."
#~ msgstr "\tremove o primeiro diretório, `popd +1' o segundo."

#, fuzzy
#~ msgid "-N   removes the Nth entry counting from the right of the list"
#~ msgstr "-N\tremove a n-ésima entrada contada a partir da direita da lista"

#, fuzzy
#~ msgid "     shown by `dirs', starting with zero.  For example: `popd -0'"
#~ msgstr "\texibida por `dirs', começando por zero.  Por exemplo: `popd -0'"

#, fuzzy
#~ msgid "     removes the last directory, `popd -1' the next to last."
#~ msgstr "\tremove o último diretório, `popd -1' o penúltimo."

#, fuzzy
#~ msgid ""
#~ "-n   suppress the normal change of directory when removing directories"
#~ msgstr "-n\tsuprime a troca normal de diretório ao remover-se diretórios"

#, fuzzy
#~ msgid "     from the stack, so only the stack is manipulated."
#~ msgstr "\tda pilha, fazendo com que somente a pilha seja manipulada."

#, fuzzy
#~ msgid ""
#~ "Exit from within a FOR, WHILE or UNTIL loop.  If N is specified,\n"
#~ "    break N levels."
#~ msgstr "Sair de um laço FOR, WHILE ou UNTIL."

#~ msgid "Obsolete.  See `declare'."
#~ msgstr "Obsoleta.  Veja `declare'."

#~ msgid ""
#~ "Output the ARGs.  If -n is specified, the trailing newline is suppressed."
#~ msgstr ""
#~ "Exibe ARGS.  Se -n for fornecido, o caracter final de nova linha é "
#~ "suprimido."

#~ msgid ""
#~ "Read ARGs as input to the shell and execute the resulting command(s)."
#~ msgstr ""
#~ "Ler ARGs como entrada da `shell' e executar o(s) comando(s) resultante(s)."

#~ msgid "Logout of a login shell."
#~ msgstr "Sair de uma shell de login."

#, fuzzy
#~ msgid ""
#~ "Causes a function to exit with the return value specified by N.  If N\n"
#~ "    is omitted, the return status is that of the last command."
#~ msgstr "Faz a função terminar com o valor de retorno especificado por N."

#, fuzzy
#~ msgid ""
#~ "The positional parameters from $N+1 ... are renamed to $1 ...  If N is\n"
#~ "    not given, it is assumed to be 1."
#~ msgstr ""
#~ "Os parâmetros posicionais a partir de $N+1 ... são deslocados para $1 ..."

#, fuzzy
#~ msgid ""
#~ "Print the accumulated user and system times for processes run from\n"
#~ "    the shell."
#~ msgstr ""
#~ "Exibe os tempos acumulados do usuário e do sistema para os processos"

#~ msgid "Missing `}'"
#~ msgstr "Faltando `}'"

#~ msgid "brace_expand> "
#~ msgstr "brace_expand> "

#~ msgid "Attempt to free unknown command type `%d'.\n"
#~ msgstr "Tentativa de liberar um tipo de comando desconhecido `%d'.\n"

#~ msgid "Report this to %s\n"
#~ msgstr "Informar o ocorrido para %s\n"

#~ msgid "Stopping myself..."
#~ msgstr "Parando-me..."

#~ msgid "Tell %s to fix this someday.\n"
#~ msgstr "Informar %s para corrigir o ocorrido.\n"

#~ msgid "execute_command: bad command type `%d'"
#~ msgstr "execute_command: `%d' é um tipo incorreto de comando "

#~ msgid "real\t"
#~ msgstr "real\t"

#~ msgid "user\t"
#~ msgstr "usuário\t"

#~ msgid "sys\t"
#~ msgstr "sistema\t"

#~ msgid ""
#~ "real\t0m0.00s\n"
#~ "user\t0m0.00s\n"
#~ "sys\t0m0.00s\n"
#~ msgstr ""
#~ "real   \t0m0.00s\n"
#~ "usuário\t0m0.00s\n"
#~ "sistema\t0m0.00s\n"

#~ msgid "cannot duplicate fd %d to fd 1: %s"
#~ msgstr "impossível duplicar fd (descritor de arquivo) %d para fd 1: %s"

#~ msgid "%s: output redirection restricted"
#~ msgstr "%s: redirecionamento da saída restringido"

#~ msgid "Out of memory!"
#~ msgstr "Memória esgotada!"

#~ msgid "You have already added item `%s'\n"
#~ msgstr "Você já adicionou o item `%s'\n"

#~ msgid "You have entered %d (%d) items.  The distribution is:\n"
#~ msgstr "Entrados %d (%d) itens.  A distribuição é:\n"

#~ msgid "%s: bg background job?"
#~ msgstr "%s: bg trabalho no segundo plano?"

#~ msgid ""
#~ "Redirection instruction from yyparse () '%d' is\n"
#~ "out of range in make_redirection ()."
#~ msgstr ""
#~ "A instrução de redirecionamento do yyparse () '%d' está\n"
#~ "fora do intervalo em make_redirection ()."

#~ msgid "clean_simple_command () got a command with type %d."
#~ msgstr "clean_simple_command () recebeu um comando do tipo %d."

#~ msgid "got errno %d while waiting for %d"
#~ msgstr "recebido erro número %d enquanto aguardava por %d"

#~ msgid "syntax error near unexpected token `%c'"
#~ msgstr "erro de sintaxe próximo do `token' não esperado `%c'"

#~ msgid "print_command: bad command type `%d'"
#~ msgstr "print_command: tipo de comando incorreto `%d'"

#~ msgid "cprintf: bad `%%' argument (%c)"
#~ msgstr "cprintf: argumento `%%' incorreto (%c)"

#~ msgid "option `%s' requires an argument"
#~ msgstr "a opção `%s' requer um argumento"

#~ msgid "%s: unrecognized option"
#~ msgstr "%s: a opção não é reconhecida"

#~ msgid "`-c' requires an argument"
#~ msgstr "A opção `-c' requer um argumento"

#~ msgid "%s: cannot execute directories"
#~ msgstr "%s: impossível executar diretórios"

#~ msgid "Bad code in sig.c: sigprocmask"
#~ msgstr "Código incorreto em sig.c: sigprocmask"

#~ msgid "bad substitution: no ending `}' in %s"
#~ msgstr "substituição incorreta: falta o `}' final em %s"

#~ msgid "%s: bad array subscript"
#~ msgstr "%s: indice da matriz (array) incorreto"

#~ msgid "can't make pipes for process substitution: %s"
#~ msgstr "impossível criar `pipes' para a substituição do processo: %s"

#~ msgid "reading"
#~ msgstr "lendo"

#~ msgid "process substitution"
#~ msgstr "substituição de processo"

#~ msgid "command substitution"
#~ msgstr "substituição de comando"

#~ msgid "Can't reopen pipe to command substitution (fd %d): %s"
#~ msgstr ""
#~ "Impossível reabrir o `pipe' para substituição de comando (fd %d): %s"

#~ msgid "$%c: unbound variable"
#~ msgstr "$%c: variável não vinculada"

#~ msgid "%s: bad arithmetic substitution"
#~ msgstr "%s: substituição aritmética incorreta"

#~ msgid "-%s: binary operator expected"
#~ msgstr "-%s: esperado operador binário"

#~ msgid "%s[%s: bad subscript"
#~ msgstr "%s[%s: índice incorreto"

#~ msgid "[%s: bad subscript"
#~ msgstr "[%s: índice incorreto"

#~ msgid "digits occur in two different argv-elements.\n"
#~ msgstr "os dígitos aparecem em dois elementos argv diferentes.\n"

#~ msgid "option %c\n"
#~ msgstr "opção %c\n"

#~ msgid "option a\n"
#~ msgstr "opção a\n"

#~ msgid "option b\n"
#~ msgstr "opção b\n"

#~ msgid "option c with value `%s'\n"
#~ msgstr "opção c com o valor `%s'\n"

#~ msgid "?? sh_getopt returned character code 0%o ??\n"
#~ msgstr "?? sh_getopt retornou o código de caracter 0%o ??\n"

#~ msgid "non-option ARGV-elements: "
#~ msgstr "elementos de ARGV que não são opção:"

#~ msgid "%s: Unknown flag %s.\n"
#~ msgstr "%s: Opção %s desconhecida.\n"

#~ msgid "Unknown directive `%s'"
#~ msgstr "Diretiva desconhecida `%s'"

#~ msgid "%s requires an argument"
#~ msgstr "%s requer um argumento"

#~ msgid "%s must be inside of a $BUILTIN block"
#~ msgstr "%s deve estar dentro de um bloco $BUILTIN"

#~ msgid "%s found before $END"
#~ msgstr "%s encontrado antes de $END"

#~ msgid "%s already has a function (%s)"
#~ msgstr "%s já possui uma função (%s)"

#~ msgid "%s already had a docname (%s)"
#~ msgstr "%s já possui um nome de documento (%s)"

#~ msgid "%s already has short documentation (%s)"
#~ msgstr "%s já possui uma documentação curta (%s)"

#~ msgid "%s already has a %s definition"
#~ msgstr "%s já possui a definição %s"

#~ msgid "mkbuiltins: Out of virtual memory!\n"
#~ msgstr "mkbuiltins: Memória virtual esgotada!\n"

#~ msgid "read [-r] [-p prompt] [-a array] [-e] [name ...]"
#~ msgstr "read [-r] [-p MENSAGEM] [-a MATRIZ] [-e] [NOME ...]"

#~ msgid "%[DIGITS | WORD] [&]"
#~ msgstr "%[DÍGITOS | PALAVRA] [&]"

#~ msgid "variables - Some variable names and meanings"
#~ msgstr "variáveis - Alguns nomes de variáveis e suas descrições"

#~ msgid "`alias' with no arguments or with the -p option prints the list"
#~ msgstr "`alias' sem nenhum argumento, ou com a opção -p, exibe a lista"

#~ msgid "of aliases in the form alias NAME=VALUE on standard output."
#~ msgstr "de aliases na forma `alias NOME=VALOR' na saída padrão."

#~ msgid "Otherwise, an alias is defined for each NAME whose VALUE is given."
#~ msgstr ""
#~ "Ou então, um alias é definido para cada NOME cujo VALOR for fornecido."

#~ msgid "A trailing space in VALUE causes the next word to be checked for"
#~ msgstr "Um espaço após VALOR faz a próxima palavra ser verificada para"

#~ msgid "alias substitution when the alias is expanded.  Alias returns"
#~ msgstr "substituição do alias quando o alias é expandido. Alias retorna"

#~ msgid "true unless a NAME is given for which no alias has been defined."
#~ msgstr ""
#~ "verdadeiro, a não ser que seja fornecido um NOME sem alias definido."

#~ msgid "then remove all alias definitions."
#~ msgstr "então todas as definições de alias são removidas."

#~ msgid "Bind a key sequence to a Readline function, or to a macro.  The"
#~ msgstr ""
#~ "Víncula uma seqüência de teclas a uma função de leitura de linha, ou a uma"

#~ msgid "syntax is equivalent to that found in ~/.inputrc, but must be"
#~ msgstr ""
#~ "macro.  A sintaxe é equivalente à encontrada em ~/.inputrc, mas deve ser"

#~ msgid ""
#~ "passed as a single argument: bind '\"\\C-x\\C-r\": re-read-init-file'."
#~ msgstr ""
#~ "passada como um único argumento: bind '\"\\C-x\\C-r\": re-read-init-file'."

#~ msgid "Arguments we accept:"
#~ msgstr "Argumentos permitidos:"

#~ msgid ""
#~ "  -m  keymap         Use `keymap' as the keymap for the duration of this"
#~ msgstr ""
#~ "  -m  MAPA-TECLAS    Usar `MAPA-TECLAS' como mapa das teclas pela duração"

#~ msgid "                     command.  Acceptable keymap names are emacs,"
#~ msgstr "                     deste comando.  Os nomes aceitos são emacs,"

#~ msgid ""
#~ "                     emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,"
#~ msgstr ""
#~ "                     emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,"

#~ msgid "                     vi-command, and vi-insert."
#~ msgstr "                     vi-command, and vi-insert."

#~ msgid "  -l                 List names of functions."
#~ msgstr "  -l                 Listar os nomes das funções."

#~ msgid "  -P                 List function names and bindings."
#~ msgstr "  -P                 Listar nomes e vinculações das funções."

#~ msgid ""
#~ "  -p                 List functions and bindings in a form that can be"
#~ msgstr ""
#~ "  -p                 Listar nomes e vinculações das funções de uma forma"

#~ msgid "                     reused as input."
#~ msgstr "                     que pode ser reutilizada como entrada."

#~ msgid "  -r  keyseq         Remove the binding for KEYSEQ."
#~ msgstr "  -r  SEQ-TECLAS     Remove o vínculo para SEQ-TECLAS."

#~ msgid "  -f  filename       Read key bindings from FILENAME."
#~ msgstr "  -f  ARQUIVO        Ler os vínculos das teclas em ARQUIVO."

#~ msgid ""
#~ "  -q  function-name  Query about which keys invoke the named function."
#~ msgstr "  -q  NOME-FUNÇÃO    Consultar quais teclas chamam esta função."

#~ msgid "  -V                 List variable names and values"
#~ msgstr "  -V                 Listar os nomes e os valores das variáveis."

#~ msgid ""
#~ "  -v                 List variable names and values in a form that can"
#~ msgstr ""
#~ "  -v                 Listar os nomes e os valores das variáveis de uma"

#~ msgid "                     be reused as input."
#~ msgstr "                     forma que pode ser reutilizada como entrada."

#~ msgid ""
#~ "  -S                 List key sequences that invoke macros and their "
#~ "values"
#~ msgstr ""
#~ "  -S                 Listar as seqüências de teclas que chamam macros\n"
#~ "                         e seus valores."

#~ msgid ""
#~ "  -s                 List key sequences that invoke macros and their "
#~ "values in"
#~ msgstr "  -s                 Listar seqüências de teclas que chamam macros"

#~ msgid "                     a form that can be reused as input."
#~ msgstr ""
#~ "                     e seus valores de uma forma que pode ser\n"
#~ "                         reutilizada como entrada."

#~ msgid "break N levels."
#~ msgstr "Se N for especificado, sai de N níveis."

#~ msgid "If N is specified, resume at the N-th enclosing loop."
#~ msgstr "Se N for especificado, prossegue no N-ésimo laço envolvente."

#~ msgid "Run a shell builtin.  This is useful when you wish to rename a"
#~ msgstr ""
#~ "Executa um comando interno da `shell'.  Útil quando desejamos substituir"

#~ msgid "shell builtin to be a function, but need the functionality of the"
#~ msgstr "um comando interno da `shell' por uma função, mas necessitamos da"

#~ msgid "builtin within the function itself."
#~ msgstr "funcionalidade do comando interno dentro da própria função."

#~ msgid "Change the current directory to DIR.  The variable $HOME is the"
#~ msgstr "Troca o diretório atual para DIR.  A variável $HOME é o padrão"

#~ msgid "default DIR.  The variable $CDPATH defines the search path for"
#~ msgstr "para DIR.  A variável $CDPATH define o caminho de procura para"

#~ msgid "the directory containing DIR.  Alternative directory names in CDPATH"
#~ msgstr ""
#~ "o diretório que contém DIR.  Nomes de diretórios alternativos em CDPATH"

#~ msgid "are separated by a colon (:).  A null directory name is the same as"
#~ msgstr ""
#~ "são separados por dois pontos (:).  Um nome de diretório nulo é o mesmo"

#~ msgid "the current directory, i.e. `.'.  If DIR begins with a slash (/),"
#~ msgstr "que o diretório atual, i.e. `.'.  Se DIR inicia com uma barra (/),"

#~ msgid "then $CDPATH is not used.  If the directory is not found, and the"
#~ msgstr "então $CDPATH não é usado.  Se o diretório não for encontrado, e a"

#~ msgid "shell option `cdable_vars' is set, then try the word as a variable"
#~ msgstr ""
#~ "opção `cdable_vars' estiver definida, tentar usar DIR como um nome de"

#~ msgid "name.  If that variable has a value, then cd to the value of that"
#~ msgstr ""
#~ "variável.  Se esta variável tiver valor, então `cd' para o valor desta"

#~ msgid ""
#~ "variable.  The -P option says to use the physical directory structure"
#~ msgstr ""
#~ "variável.  A opção -P indica para usar a estrutura física do diretório"

#~ msgid ""
#~ "instead of following symbolic links; the -L option forces symbolic links"
#~ msgstr "em vez de seguir os vínculos simbólicos; a opção -L força seguir os"

#~ msgid "to be followed."
#~ msgstr "vínculos simbólicos."

#~ msgid "Print the current working directory.  With the -P option, pwd prints"
#~ msgstr "Exibe o diretório atual de trabalho.  Com a opção -P, `pwd' exibe"

#~ msgid "the physical directory, without any symbolic links; the -L option"
#~ msgstr "o diretório físico, sem nenhum vínculo simbólico; a opção -L faz"

#~ msgid "makes pwd follow symbolic links."
#~ msgstr "com que `pwd' siga os vínculos simbólicos."

#~ msgid ""
#~ "Runs COMMAND with ARGS ignoring shell functions.  If you have a shell"
#~ msgstr ""
#~ "Executa COMANDO com ARGs ignorando as funções da `shell'.  Ex: Havendo"

#~ msgid "function called `ls', and you wish to call the command `ls', you can"
#~ msgstr ""
#~ "uma função `ls', e se for necessário executar o comando `ls', executa-se"

#~ msgid ""
#~ "say \"command ls\".  If the -p option is given, a default value is used"
#~ msgstr ""
#~ "\"command ls\".  Se a opção -p for fornecida, o valor padrão é utilizado"

#~ msgid ""
#~ "for PATH that is guaranteed to find all of the standard utilities.  If"
#~ msgstr ""
#~ "para PATH, garantindo-se o encontro de todos os utilitários padrão. Se"

#~ msgid ""
#~ "the -V or -v option is given, a string is printed describing COMMAND."
#~ msgstr "a opção -V ou -v for fornecida, é exibida a descrição do COMANDO."

#~ msgid "The -V option produces a more verbose description."
#~ msgstr "A opção -V produz uma descrição mais extensa."

#~ msgid "Declare variables and/or give them attributes.  If no NAMEs are"
#~ msgstr "Declara variáveis e/ou dá-lhes atributos.  Se nenhum nome for"

#~ msgid "given, then display the values of variables instead.  The -p option"
#~ msgstr "fornecido, então são exibidos os valores das variáveis.  A opção -p"

#~ msgid "will display the attributes and values of each NAME."
#~ msgstr "exibe os atributos e valores para cada NOME."

#~ msgid "The flags are:"
#~ msgstr "As opções são:"

#~ msgid "  -a\tto make NAMEs arrays (if supported)"
#~ msgstr "  -a\tpara tornar NOMEs matrizes (arrays), se suportado"

#~ msgid "  -f\tto select from among function names only"
#~ msgstr "  -f\tpara selecionar somente entre nomes de funções"

#~ msgid "  -F\tto display function names without definitions"
#~ msgstr "  -F\tpara exibir os nomes das funções omitindo suas definições"

#~ msgid "  -r\tto make NAMEs readonly"
#~ msgstr "  -r\tpara tornar NOMEs somente para leitura"

#~ msgid "  -x\tto make NAMEs export"
#~ msgstr "  -x\tpara fazer a exportação de NOMEs"

#~ msgid "  -i\tto make NAMEs have the `integer' attribute set"
#~ msgstr "  -i\tpara ativar o atributo `inteiro' em NOMEs "

#~ msgid "Variables with the integer attribute have arithmetic evaluation (see"
#~ msgstr "Variáveis com atributo inteiro são avaliadas aritmeticamente (veja"

#~ msgid "`let') done when the variable is assigned to."
#~ msgstr "`let') quando é feita uma atribuição de valor."

#~ msgid "When displaying values of variables, -f displays a function's name"
#~ msgstr "Ao exibir os valores das variáveis, -f exibe o nome da função e"

#~ msgid "and definition.  The -F option restricts the display to function"
#~ msgstr "sua definição.  A opção -F restringe a exibição ao nome da função"

#~ msgid "name only."
#~ msgstr "somente."

#~ msgid ""
#~ "Using `+' instead of `-' turns off the given attribute instead.  When"
#~ msgstr "Usando `+' em vez de `-' faz o atributo ser desabilitado.  Quando"

#~ msgid "used in a function, makes NAMEs local, as with the `local' command."
#~ msgstr "usado em uma função, torna NOMEs local, como no comando `local'."

#~ msgid "Create a local variable called NAME, and give it VALUE.  LOCAL"
#~ msgstr "Cria uma variável local chamada NOME, e atribui VALOR.  LOCAL"

#~ msgid "have a visible scope restricted to that function and its children."
#~ msgstr "da variável NOME fique restrito à própria função e às suas filhas."

#~ msgid "Output the ARGs.  If -n is specified, the trailing newline is"
#~ msgstr "Exibe ARGs.  Se -n for fornecido, o caracter final de nova linha é"

#~ msgid "suppressed.  If the -e option is given, interpretation of the"
#~ msgstr ""
#~ "suprimido.  Se a opção -e for fornecida, a interpretação dos seguintes"

#~ msgid "following backslash-escaped characters is turned on:"
#~ msgstr "caracteres após a contrabarra é ativada:"

#~ msgid "\t\\a\talert (bell)"
#~ msgstr "\t\\a\talerta (bell)"

#~ msgid "\t\\b\tbackspace"
#~ msgstr "\t\\b\tbackspace"

#~ msgid "\t\\c\tsuppress trailing newline"
#~ msgstr "\t\\c\tsuprimir o caracter final de nova linha"

#~ msgid "\t\\E\tescape character"
#~ msgstr "\t\\E\to caracter de escape"

#~ msgid "\t\\f\tform feed"
#~ msgstr "\t\\f\talimentação de formulário (form feed)"

#~ msgid "\t\\n\tnew line"
#~ msgstr "\t\\n\tnova linha"

#~ msgid "\t\\r\tcarriage return"
#~ msgstr "\t\\r\tretorno de carro (cr)"

#~ msgid "\t\\t\thorizontal tab"
#~ msgstr "\t\\t\ttabulação horizontal (ht)"

#~ msgid "\t\\v\tvertical tab"
#~ msgstr "\t\\v\ttabulação vertical (vt)"

#~ msgid "\t\\\\\tbackslash"
#~ msgstr "\t\\\\\tcontrabarra"

#~ msgid "\t\\num\tthe character whose ASCII code is NUM (octal)."
#~ msgstr "\t\\num\to caracter com código ASCII igual a NUM (octal)."

#~ msgid ""
#~ "You can explicitly turn off the interpretation of the above characters"
#~ msgstr ""
#~ "Pode-se explicitamente desabilitar a interpretação dos caracteres acima"

#~ msgid "with the -E option."
#~ msgstr "através da opção -E."

#~ msgid "Enable and disable builtin shell commands.  This allows"
#~ msgstr ""
#~ "Habilita e desabilita os comandos internos da `shell', permitindo usar"

#~ msgid "you to use a disk command which has the same name as a shell"
#~ msgstr ""
#~ "um comando de disco que tenha o mesmo nome do comando interno da `shell'."

#~ msgid "builtin.  If -n is used, the NAMEs become disabled; otherwise"
#~ msgstr ""
#~ "Se -n for especificado, os NOMEs são desabilitados, senão os nomes são"

#~ msgid "NAMEs are enabled.  For example, to use the `test' found on your"
#~ msgstr ""
#~ "habilitados. Por exemplo, para usar `test' encontrado pelo PATH em vez"

#~ msgid "path instead of the shell builtin version, type `enable -n test'."
#~ msgstr ""
#~ "da versão interna do comando, digite `enable -n test'. Em sistemas que"

#~ msgid "On systems supporting dynamic loading, the -f option may be used"
#~ msgstr ""
#~ "suportam carregamento dinâmico, pode-se usar a opção -f para carregar"

#~ msgid "to load new builtins from the shared object FILENAME.  The -d"
#~ msgstr ""
#~ "novos comandos internos do objeto compartilhado ARQUIVO.  A opção -d"

#~ msgid "option will delete a builtin previously loaded with -f.  If no"
#~ msgstr ""
#~ "elimina os comandos internos previamente carregados com -f.  Se nenhum"

#~ msgid "non-option names are given, or the -p option is supplied, a list"
#~ msgstr ""
#~ "nome for fornecido, ou se a opção -p for fornecida, uma lista de comandos"

#~ msgid "of builtins is printed.  The -a option means to print every builtin"
#~ msgstr ""
#~ "internos é exibida.  A opção -a faz com que todos os comandos internos"

#~ msgid "with an indication of whether or not it is enabled.  The -s option"
#~ msgstr "sejam exibidos indicando se estão habilitados ou não.  A opção -s"

#~ msgid "restricts the output to the Posix.2 `special' builtins.  The -n"
#~ msgstr ""
#~ "restringe a saída aos comandos internos `especiais' Posix.2.  A opção"

#~ msgid "option displays a list of all disabled builtins."
#~ msgstr "-n exibe a lista de todos os comandos internos desabilitados."

#~ msgid "Getopts is used by shell procedures to parse positional parameters."
#~ msgstr ""
#~ "Getopts é utilizado pelos procedimentos da `shell' para fazer a leitura\n"
#~ "    (parse) dos parâmetros posicionais."

#~ msgid "OPTSTRING contains the option letters to be recognized; if a letter"
#~ msgstr "OPÇÕES contém as letras das opções a serem reconhecidas; Se uma"

#~ msgid "is followed by a colon, the option is expected to have an argument,"
#~ msgstr "letra é seguida por dois pontos, a opção espera a presença de um"

#~ msgid "which should be separated from it by white space."
#~ msgstr "argumento que deve ser separado dela por espaço em branco."

#~ msgid "Each time it is invoked, getopts will place the next option in the"
#~ msgstr "Cada vez que for chamada, `getopts' irá colocar a próxima opção na"

#~ msgid "shell variable $name, initializing name if it does not exist, and"
#~ msgstr "variável da `shell' $NOME, inicializando NOME caso não exista, e o"

#~ msgid "the index of the next argument to be processed into the shell"
#~ msgstr "índice do próximo argumento a ser processado dentro da variável da"

#~ msgid "variable OPTIND.  OPTIND is initialized to 1 each time the shell or"
#~ msgstr "`shell' OPTIND.  OPTIND é inicializado com 1 cada vez que o script"

#~ msgid "a shell script is invoked.  When an option requires an argument,"
#~ msgstr ""
#~ "da `shell' é chamado.  Quando uma opção requer um argumento, `getopts'"

#~ msgid "getopts places that argument into the shell variable OPTARG."
#~ msgstr "coloca este argumento dentro da variável da `shell' OPTARG."

#~ msgid "getopts reports errors in one of two ways.  If the first character"
#~ msgstr ""
#~ "`getopts' informa os erros de duas maneiras.  Se o primeiro caracter de"

#~ msgid "of OPTSTRING is a colon, getopts uses silent error reporting.  In"
#~ msgstr "OPÇÕES for dois pontos, `getopts' usa o modo silencioso.  Neste"

#~ msgid "this mode, no error messages are printed.  If an illegal option is"
#~ msgstr "modo, nenhuma mensagem de erro é exibida.  Se uma opção ilegal for"

#~ msgid "seen, getopts places the option character found into OPTARG.  If a"
#~ msgstr "encontrada, `getopts' coloca o caracter da opção em OPTARG.  Se um"

#~ msgid "required argument is not found, getopts places a ':' into NAME and"
#~ msgstr ""
#~ "argumento requerido não for encontrado, `getopts' coloca ':' em  NOME e"

#~ msgid "sets OPTARG to the option character found.  If getopts is not in"
#~ msgstr ""
#~ "atribui a OPTARG o caracter de opção encontrado. Se `getopts' não está em"

#~ msgid "silent mode, and an illegal option is seen, getopts places '?' into"
#~ msgstr ""
#~ "modo silencioso, e uma opção ilegal é encontrada, `getopts' coloca '?' em"

#~ msgid "NAME and unsets OPTARG.  If a required option is not found, a '?'"
#~ msgstr ""
#~ "NOME e desativa OPTARG.  Se uma opção requerida não é encontrada, uma '?'"

#~ msgid "is placed in NAME, OPTARG is unset, and a diagnostic message is"
#~ msgstr ""
#~ "é colocada em NOME, OPTARG é desativado, e uma mensagem de diagnóstico é"

#~ msgid "If the shell variable OPTERR has the value 0, getopts disables the"
#~ msgstr ""
#~ "Se a variável da `shell' OPTERR tem o valor 0, `getopts' desabilita a"

#~ msgid "printing of error messages, even if the first character of"
#~ msgstr "exibição de mensagens de erro, mesmo que o primeiro caracter de"

#~ msgid "OPTSTRING is not a colon.  OPTERR has the value 1 by default."
#~ msgstr "OPTSTRING não seja dois pontos.  OPTERR tem o valor 1 por padrão."

#~ msgid "Getopts normally parses the positional parameters ($0 - $9), but if"
#~ msgstr ""
#~ "`getopts' normalmente faz a leitura dos parãmetros posicionais ($0 - $9),"

#~ msgid "more arguments are given, they are parsed instead."
#~ msgstr "mas, se mais argumentos forem fornecidos, então estes são lidos."

#~ msgid "Exec FILE, replacing this shell with the specified program."
#~ msgstr ""
#~ "Executa ARQUIVO, substituindo esta `shell' pelo programa especificado."

#~ msgid "If FILE is not specified, the redirections take effect in this"
#~ msgstr ""
#~ "Se ARQUIVO não for especificado, os redirecionamentos são efetivados"

#~ msgid "shell.  If the first argument is `-l', then place a dash in the"
#~ msgstr ""
#~ "nesta `shell'.  Se o primeiro argumento for `-l', coloca um hífen no"

#~ msgid "zeroth arg passed to FILE, as login does.  If the `-c' option"
#~ msgstr "argumento `0' passado para ARQUIVO, como no login.  Se a opção `-c'"

#~ msgid "is supplied, FILE is executed with a null environment.  The `-a'"
#~ msgstr "for fornecida, ARQUIVO é executado com um ambiente nulo.  A opção"

#~ msgid "option means to make set argv[0] of the executed process to NAME."
#~ msgstr "`-a' significa atribuir NOME para argv[0] do processo executado."

#~ msgid "If the file cannot be executed and the shell is not interactive,"
#~ msgstr ""
#~ "Se o arquivo não puder ser executado e a `shell' não for interativa,"

#~ msgid "then the shell exits, unless the variable \"no_exit_on_failed_exec\""
#~ msgstr ""
#~ "então a `shell' termina, a menos que a variável \"no_exit_on_failed_exec\""

#~ msgid "is set."
#~ msgstr "esteja inicializada."

#~ msgid "is that of the last command executed."
#~ msgstr "de saída é igual ao do último comando executado."

#~ msgid ""
#~ "FIRST and LAST can be numbers specifying the range, or FIRST can be a"
#~ msgstr "PRIMEIRO e ÚLTIMO podem ser números especificando o intervalo, ou"

#~ msgid "string, which means the most recent command beginning with that"
#~ msgstr "PRIMEIRO pode ser uma cadeia de caracteres, representando o comando"

#~ msgid "string."
#~ msgstr "mais recente começado por estes caracteres."

#~ msgid ""
#~ "   -e ENAME selects which editor to use.  Default is FCEDIT, then EDITOR,"
#~ msgstr ""
#~ "   -e EDITOR seleciona qual editor usar.  O padrão é FCEDIT, depois "
#~ "EDITOR,"

#~ msgid ""
#~ "      then the editor which corresponds to the current readline editing"
#~ msgstr ""
#~ "      depois o editor correspondente ao modo de edição atual da leitura"

#~ msgid "      mode, then vi."
#~ msgstr "      de linha, e depois o vi."

#~ msgid "   -l means list lines instead of editing."
#~ msgstr "   -l indica para listar as linha em vez de editá-las."

#~ msgid "   -n means no line numbers listed."
#~ msgstr "   -n indica para não listar os números das linhas."

#~ msgid ""
#~ "   -r means reverse the order of the lines (making it newest listed "
#~ "first)."
#~ msgstr ""
#~ "   -r faz reverter a ordem das linhas (a última torna-se a primeira)."

#~ msgid "With the `fc -s [pat=rep ...] [command]' format, the command is"
#~ msgstr ""
#~ "No formato `fc -s [ANTIGO=NOVO ...] [COMANDO]', o comando é executado"

#~ msgid "re-executed after the substitution OLD=NEW is performed."
#~ msgstr "novamente após a substituição de ANTIGO por NOVO ser realizada."

#~ msgid "A useful alias to use with this is r='fc -s', so that typing `r cc'"
#~ msgstr ""
#~ "Um alias útil a ser usado é r='fc -s' para que, ao se digitar `r cc',"

#~ msgid "runs the last command beginning with `cc' and typing `r' re-executes"
#~ msgstr "seja executado o último comando começado por `cc' e, ao se digitar"

#~ msgid "JOB_SPEC is not present, the shell's notion of the current job is"
#~ msgstr ""
#~ "Se JOB-ESPECIFICADO não estiver presente, a noção da `shell' do trabalho"

#~ msgid "used."
#~ msgstr "atual é utilizada."

#~ msgid "Place JOB_SPEC in the background, as if it had been started with"
#~ msgstr ""
#~ "Colocar JOB-ESPECIFICADO no segundo plano, como se tivesse sido ativado"

#~ msgid "`&'.  If JOB_SPEC is not present, the shell's notion of the current"
#~ msgstr ""
#~ "com `&'. Se JOB-ESPECIFICADO não estiver presente, a noção da `shell'"

#~ msgid "job is used."
#~ msgstr "do trabalho atual é utilizada."

#~ msgid "For each NAME, the full pathname of the command is determined and"
#~ msgstr ""
#~ "Para cada NOME, o caminho completo do comando é determinado e lembrado."

#~ msgid "remembered.  If the -p option is supplied, PATHNAME is used as the"
#~ msgstr ""
#~ "Se a opção -p for fornecida, CAMINHO é utilizado como o caminho completo"

#~ msgid "full pathname of NAME, and no path search is performed.  The -r"
#~ msgstr "para NOME, e nenhuma procura de caminho é realizada.  A opção -r"

#~ msgid "option causes the shell to forget all remembered locations.  If no"
#~ msgstr ""
#~ "faz com que a `shell' esqueça todas as localizações lembradas.  Sem nenhum"

#~ msgid ""
#~ "arguments are given, information about remembered commands is displayed."
#~ msgstr "argumento, as informações sobre os comandos lembrados são exibidas."

#~ msgid "Display helpful information about builtin commands.  If PATTERN is"
#~ msgstr "Exibe informações úteis sobre os comandos internos. Se PADRÃO for"

#~ msgid "specified, gives detailed help on all commands matching PATTERN,"
#~ msgstr "especificado, fornece ajuda detalhada para todos os comandos que"

#~ msgid "otherwise a list of the builtins is printed."
#~ msgstr ""
#~ "correspondem ao PADRÃO, senão a lista dos comandos internos é exibida."

#~ msgid "Display the history list with line numbers.  Lines listed with"
#~ msgstr ""
#~ "Exibe a lista histórica com os números das linhas. Linhas contendo um"

#~ msgid "with a `*' have been modified.  Argument of N says to list only"
#~ msgstr "`*' foram modificadas.  O argumento N faz listar somente as últimas"

#~ msgid "the last N lines.  The -c option causes the history list to be"
#~ msgstr "N linhas.  A opção -c faz com que a lista histórica seja apagada"

#~ msgid ""
#~ "cleared by deleting all of the entries.  The `-w' option writes out the"
#~ msgstr ""
#~ "removendo todas as entradas.  A opção `-w' escreve o histórico atual no"

#~ msgid ""
#~ "current history to the history file;  `-r' means to read the file and"
#~ msgstr ""
#~ "arquivo de histórico;  A opção `-r' significa ler o arquivo e apensar seu"

#~ msgid "append the contents to the history list instead.  `-a' means"
#~ msgstr ""
#~ "conteúdo à lista histórica.  A opção `-a' significa apensar as linhas de"

#~ msgid "to append history lines from this session to the history file."
#~ msgstr "histórico desta sessão ao arquivo de histórico."

#~ msgid "Argument `-n' means to read all history lines not already read"
#~ msgstr "A opção `-n' faz ler todas as linhas de histórico ainda não lidas"

#~ msgid "from the history file and append them to the history list.  If"
#~ msgstr ""
#~ "do arquivo histórico, e apensá-las à lista de histórico.  Se ARQUIVO"

#~ msgid "FILENAME is given, then that is used as the history file else"
#~ msgstr "for fornecido, então este é usado como arquivo de histórico, senão"

#~ msgid "if $HISTFILE has a value, that is used, else ~/.bash_history."
#~ msgstr ""
#~ "se $HISTFILE possui valor, este é usado, senão ~/.bash_history.  Se a"

#~ msgid "If the -s option is supplied, the non-option ARGs are appended to"
#~ msgstr ""
#~ "opção -s for fornecida, os ARGs, que não forem opções, são apensados à"

#~ msgid "the history list as a single entry.  The -p option means to perform"
#~ msgstr ""
#~ "lista histórica como uma única entrada. A opção -p significa realizar a"

#~ msgid ""
#~ "history expansion on each ARG and display the result, without storing"
#~ msgstr ""
#~ "expansão da história em cada ARG e exibir o resultado, sem armazenar"

#~ msgid "anything in the history list."
#~ msgstr "nada na lista de histórico."

#~ msgid "Lists the active jobs.  The -l option lists process id's in addition"
#~ msgstr ""
#~ "Lista os trabalhos ativos.  A opção -l lista os ID's dos processos além"

#~ msgid "to the normal information; the -p option lists process id's only."
#~ msgstr ""
#~ "das informações usuais;  a opção -p lista somente os ID's dos processos."

#~ msgid ""
#~ "If -n is given, only processes that have changed status since the last"
#~ msgstr ""
#~ "Se -n for fornecido, somente os processos que mudaram de status desde a"

#~ msgid ""
#~ "notification are printed.  JOBSPEC restricts output to that job.  The"
#~ msgstr ""
#~ "última notificação são exibidos.  JOB-ESPECIFICADO restringe a saída a "
#~ "este"

#~ msgid "-r and -s options restrict output to running and stopped jobs only,"
#~ msgstr ""
#~ "trabalho.  As opções -r e -s restringem a saída apenas aos trabalhos"

#~ msgid "respectively.  Without options, the status of all active jobs is"
#~ msgstr ""
#~ "executando e parados, respectivamente.  Sem opções, o status de todos os"

#~ msgid ""
#~ "printed.  If -x is given, COMMAND is run after all job specifications"
#~ msgstr ""
#~ "trabalhos ativos são exibidos.  Se -x for fornecido, COMANDO é executado"

#~ msgid ""
#~ "that appear in ARGS have been replaced with the process ID of that job's"
#~ msgstr ""
#~ "após todas as especificações de trabalho que aparecem em ARGS terem sido"

#~ msgid "process group leader."
#~ msgstr "substituídas pelo ID do processo líder deste grupo de processos."

#~ msgid "Removes each JOBSPEC argument from the table of active jobs."
#~ msgstr ""
#~ "Remove cada argumento JOB-ESPECIFICADO da tabela de trabalhos ativos."

#~ msgid "Send the processes named by PID (or JOB) the signal SIGSPEC.  If"
#~ msgstr ""
#~ "Envia ao processo identificado pelo PID (ou JOB) o sinal SIGSPEC.  Se"

#~ msgid ""
#~ "SIGSPEC is not present, then SIGTERM is assumed.  An argument of `-l'"
#~ msgstr ""
#~ "SIGSPEC não estiver presente, então SIGTERM é assumido.  A opção `-l'"

#~ msgid "lists the signal names; if arguments follow `-l' they are assumed to"
#~ msgstr ""
#~ "lista os nomes dos sinais;  havendo argumentos após `-l', são assumidos"

#~ msgid "be signal numbers for which names should be listed.  Kill is a shell"
#~ msgstr ""
#~ "como sendo os números dos sinais cujos nomes devem ser exibidos.  Kill"

#~ msgid "builtin for two reasons: it allows job IDs to be used instead of"
#~ msgstr ""
#~ "é um comando interno por duas razões: permite o uso do ID do trabalho em"

#~ msgid "process IDs, and, if you have reached the limit on processes that"
#~ msgstr ""
#~ "vez do ID do processo e, caso tenha sido atingido o limite de processos "
#~ "que"

#~ msgid ""
#~ "you can create, you don't have to start a process to kill another one."
#~ msgstr ""
#~ "podem ser criados, não é necessário um novo processo para remover outro."

#~ msgid "Each ARG is an arithmetic expression to be evaluated.  Evaluation"
#~ msgstr "Cada ARG é uma expressão aritmética a ser avaliada.  A avaliação é"

#~ msgid "is done in long integers with no check for overflow, though division"
#~ msgstr ""
#~ "feita usando inteiros longos sem verificar estouro, embora a divisão"

#~ msgid "by 0 is trapped and flagged as an error.  The following list of"
#~ msgstr "por 0 seja capturada e indicada como erro.  A lista abaixo está"

#~ msgid "operators is grouped into levels of equal-precedence operators."
#~ msgstr "grupada em níveis de igual de precedência dos operadores."

#~ msgid "The levels are listed in order of decreasing precedence."
#~ msgstr "Os níveis estão listados em ordem decrescente de precedência."

#~ msgid "\t-, +\t\tunary minus, plus"
#~ msgstr "\t-, +\t\tmenos, mais unários"

#~ msgid "\t!, ~\t\tlogical and bitwise negation"
#~ msgstr "\t!, ~\t\tnegação lógica e bit a bit"

#~ msgid "\t*, /, %\t\tmultiplication, division, remainder"
#~ msgstr "\t*, /, %\t\tmultiplicação, divisão, resto"

#~ msgid "\t+, -\t\taddition, subtraction"
#~ msgstr "\t+, -\t\tadição, subtração"

#~ msgid "\t<<, >>\t\tleft and right bitwise shifts"
#~ msgstr "\t<<, >>\t\tdeslocamento à esquerda e à direita bit a bit"

#~ msgid "\t<=, >=, <, >\tcomparison"
#~ msgstr "\t<=, >=, <, >\tcomparação"

#~ msgid "\t==, !=\t\tequality, inequality"
#~ msgstr "\t==, !=\t\tigualdade, desigualdade"

#~ msgid "\t&\t\tbitwise AND"
#~ msgstr "\t&\t\tE bit a bit"

#~ msgid "\t^\t\tbitwise XOR"
#~ msgstr "\t^\t\tOU Exclusivo (XOR) bit a bit"

#~ msgid "\t|\t\tbitwise OR"
#~ msgstr "\t|\t\tOU Inclusivo (OR) bit a bit"

#~ msgid "\t&&\t\tlogical AND"
#~ msgstr "\t&&\t\tE lógico"

#~ msgid "\t||\t\tlogical OR"
#~ msgstr "\t||\t\tOU lógico"

#~ msgid "\texpr ? expr : expr"
#~ msgstr "\texpr ? expr : expr"

#~ msgid "\t\t\tconditional expression"
#~ msgstr "\t\t\texpressão condicional"

#~ msgid "\t=, *=, /=, %=,"
#~ msgstr "\t=, *=, /=, %=,"

#~ msgid "\t+=, -=, <<=, >>=,"
#~ msgstr "\t+=, -=, <<=, >>=,"

#~ msgid "\t&=, ^=, |=\tassignment"
#~ msgstr "\t&=, ^=, |=\tatribuição"

#~ msgid "is replaced by its value (coerced to a long integer) within"
#~ msgstr "substituído pelo seu valor (convertido em inteiro longo) dentro"

#~ msgid "an expression.  The variable need not have its integer attribute"
#~ msgstr "da expressão.  A variável não precisa ter seu atributo inteiro"

#~ msgid "turned on to be used in an expression."
#~ msgstr "ativo para ser usada em uma expressão."

#~ msgid "Operators are evaluated in order of precedence.  Sub-expressions in"
#~ msgstr ""
#~ "Os operadores são avaliados em ordem de precedência.  Sub-expressões"

#~ msgid "parentheses are evaluated first and may override the precedence"
#~ msgstr "entre parênteses são avaliadas primeiro e podem prevalecer sobre as"

#~ msgid "rules above."
#~ msgstr "regras de precedência anteriores."

#~ msgid "If the last ARG evaluates to 0, let returns 1; 0 is returned"
#~ msgstr "Se o último argumento for avaliado como 0, `let' retorna 1, caso"

#~ msgid "otherwise."
#~ msgstr "contrário, retorna 0."

#~ msgid "One line is read from the standard input, and the first word is"
#~ msgstr "Uma linha é lida a partir da entrada padrão, e a primeira palavra é"

#~ msgid ""
#~ "assigned to the first NAME, the second word to the second NAME, and so"
#~ msgstr ""
#~ "atribuída ao primeiro NOME, a segunda ao segundo NOME, e assim por diante,"

#~ msgid ""
#~ "on, with leftover words assigned to the last NAME.  Only the characters"
#~ msgstr ""
#~ "com as palavras restantes atribuídas ao último NOME.  Somente os "
#~ "caracteres"

#~ msgid "found in $IFS are recognized as word delimiters.  The return code is"
#~ msgstr ""
#~ "encontrados em $IFS são reconhecidos como delimitadores. O código de "
#~ "retorno"

#~ msgid ""
#~ "zero, unless end-of-file is encountered.  If no NAMEs are supplied, the"
#~ msgstr ""
#~ "é zero, a menos que EOF seja encontrado.  Se nenhum NOME for fornecido,"

#~ msgid ""
#~ "line read is stored in the REPLY variable.  If the -r option is given,"
#~ msgstr ""
#~ "a linha lida é armazenada na variável REPLY.  Se a opção -r for fornecida,"

#~ msgid "this signifies `raw' input, and backslash escaping is disabled.  If"
#~ msgstr ""
#~ "significa entrada `textual', desabilitando a interpretação da contrabarra."

#~ msgid "the `-p' option is supplied, the string supplied as an argument is"
#~ msgstr ""
#~ "Se a opção `-p' for fornecida a MENSAGEM fornecida como argumento é "
#~ "exibida,"

#~ msgid ""
#~ "output without a trailing newline before attempting to read.  If -a is"
#~ msgstr ""
#~ "sem o caracter de nova linha, antes de efetuar a leitura.  Se a opção -a"

#~ msgid ""
#~ "supplied, the words read are assigned to sequential indices of ARRAY,"
#~ msgstr ""
#~ "for fornecida, as palavras lidas são atribuídas aos índices seqüenciais"

#~ msgid "starting at zero.  If -e is supplied and the shell is interactive,"
#~ msgstr ""
#~ "da MATRIZ, começando por zero.  Se a opção -e for fornecida, e a shell for"

#~ msgid "readline is used to obtain the line."
#~ msgstr "interativa, `readline' é utilizado para ler a linha."

#~ msgid "is omitted, the return status is that of the last command."
#~ msgstr "Se N for omitido, retorna o status do último comando executado."

#~ msgid "    -a  Mark variables which are modified or created for export."
#~ msgstr ""
#~ "    -a  Marcar para exportação as variáveis que são criadas ou "
#~ "modificadas."

#~ msgid "    -b  Notify of job termination immediately."
#~ msgstr "    -b  Notificar imediatamente o término do trabalho."

#~ msgid "    -e  Exit immediately if a command exits with a non-zero status."
#~ msgstr ""
#~ "    -e  Terminar imediatamente se um comando terminar com status != 0."

#~ msgid "    -f  Disable file name generation (globbing)."
#~ msgstr "    -f  Desabilitar a geração de nome de arquivo (metacaracteres)."

#~ msgid "    -h  Remember the location of commands as they are looked up."
#~ msgstr "    -h  Lembrar da localização dos comandos ao procurá-los."

#~ msgid ""
#~ "    -i  Force the shell to be an \"interactive\" one.  Interactive shells"
#~ msgstr "    -i  Forçar a `shell' ser do tipo \"interativa\".  `Shells'"

#~ msgid "        always read `~/.bashrc' on startup."
#~ msgstr "        interativas sempre lêem `~/.bashrc' ao iniciar."

#~ msgid "    -k  All assignment arguments are placed in the environment for a"
#~ msgstr ""
#~ "    -k  Todos os argumentos de atribuição são colocados no ambiente,"

#~ msgid "        command, not just those that precede the command name."
#~ msgstr "        e não somente os que precedem o nome do comando."

#~ msgid "    -m  Job control is enabled."
#~ msgstr "    -m  O controle de trabalho está habilitado."

#~ msgid "    -n  Read commands but do not execute them."
#~ msgstr "    -n  Ler os comandos, mas não executá-los."

#~ msgid "    -o option-name"
#~ msgstr "    -o NOME-DA-OPÇÃO"

#~ msgid "        Set the variable corresponding to option-name:"
#~ msgstr "        Inicializar a variável correspondente ao nome da opção:"

#~ msgid "            allexport    same as -a"
#~ msgstr "            allexport    o mesmo que -a"

#~ msgid "            braceexpand  same as -B"
#~ msgstr "            braceexpand  o mesmo que -B"

#~ msgid "            emacs        use an emacs-style line editing interface"
#~ msgstr ""
#~ "            emacs        usar interface de edição de linha estilo emacs"

#~ msgid "            errexit      same as -e"
#~ msgstr "            errexit      o mesmo que -e"

#~ msgid "            hashall      same as -h"
#~ msgstr "            hashall      o mesmo que -h"

#~ msgid "            histexpand   same as -H"
#~ msgstr "            histexpand   o mesmo que -H"

#~ msgid "            ignoreeof    the shell will not exit upon reading EOF"
#~ msgstr "            ignoreeof    a `shell' não termina após ler EOF"

#~ msgid "            interactive-comments"
#~ msgstr "            interactive-comments"

#~ msgid ""
#~ "                         allow comments to appear in interactive commands"
#~ msgstr ""
#~ "                         permite comentários em comandos interativos"

#~ msgid "            keyword      same as -k"
#~ msgstr "            keyword      o mesmo que -k"

#~ msgid "            monitor      same as -m"
#~ msgstr "            monitor      o mesmo que -m"

#~ msgid "            noclobber    same as -C"
#~ msgstr "            noclobber    o mesmo que -C"

#~ msgid "            noexec       same as -n"
#~ msgstr "            noexec       o mesmo que -n"

#~ msgid "            noglob       same as -f"
#~ msgstr "            noglob       o mesmo que -f"

#~ msgid "            notify       save as -b"
#~ msgstr "            notify       o mesmo que -b"

#~ msgid "            nounset      same as -u"
#~ msgstr "            nounset      o mesmo que -u"

#~ msgid "            onecmd       same as -t"
#~ msgstr "            onecmd       o mesmo que -t"

#~ msgid "            physical     same as -P"
#~ msgstr "            physical     o mesmo que -P"

#~ msgid ""
#~ "            posix        change the behavior of bash where the default"
#~ msgstr ""
#~ "            posix        mudar o comportamento do `bash' onde o padrão"

#~ msgid ""
#~ "                         operation differs from the 1003.2 standard to"
#~ msgstr ""
#~ "                         for diferente do padrão 1003.2, para tornar"

#~ msgid "                         match the standard"
#~ msgstr "                         igual ao padrão"

#~ msgid "            privileged   same as -p"
#~ msgstr "            privileged   o mesmo que -p"

#~ msgid "            verbose      same as -v"
#~ msgstr "            verbose      o mesmo que -v"

#~ msgid "            vi           use a vi-style line editing interface"
#~ msgstr ""
#~ "            vi           usar interface de edição de linha estilo vi"

#~ msgid "            xtrace       same as -x"
#~ msgstr "            xtrace       o mesmo que -x"

#~ msgid ""
#~ "    -p  Turned on whenever the real and effective user ids do not match."
#~ msgstr ""
#~ "    -p  Habilitado sempre que o usuário real e efetivo forem diferentes."

#~ msgid "        Disables processing of the $ENV file and importing of shell"
#~ msgstr ""
#~ "        Desabilita o processamento do arquivo $ENV e importação das "
#~ "funções"

#~ msgid ""
#~ "        functions.  Turning this option off causes the effective uid and"
#~ msgstr ""
#~ "        da `shell'.  Desabilitando esta opção faz com que o `uid' e `gid'"

#~ msgid "        gid to be set to the real uid and gid."
#~ msgstr "        efetivos sejam feitos o mesmo que o `uid' e `gid' reais."

#~ msgid "    -t  Exit after reading and executing one command."
#~ msgstr "    -t  Sair após ler e executar um comando."

#~ msgid "    -u  Treat unset variables as an error when substituting."
#~ msgstr ""
#~ "    -u  Tratar como erro as variáveis não inicializadas na substituição."

#~ msgid "    -v  Print shell input lines as they are read."
#~ msgstr "    -v  Exibir as linhas de entrada da `shell' ao lê-las."

#~ msgid "    -x  Print commands and their arguments as they are executed."
#~ msgstr "    -x  Exibir os comandos e seus argumentos ao executá-los."

#~ msgid "    -B  the shell will perform brace expansion"
#~ msgstr "    -B  a `shell' irá realizar a expansão das chaves {}"

#~ msgid "    -H  Enable ! style history substitution.  This flag is on"
#~ msgstr "    -H  Habilitar o estilo ! para substituição do histórico."

#~ msgid "        by default."
#~ msgstr "        Esta opção está ativa por padrão."

#~ msgid "    -C  If set, disallow existing regular files to be overwritten"
#~ msgstr "    -C  Não permite que arquivos regulares existentes sejam"

#~ msgid "        by redirection of output."
#~ msgstr "        sobrescritos pelo redirecionamento da saída."

#~ msgid "    -P  If set, do not follow symbolic links when executing commands"
#~ msgstr "    -P  Não seguir os vínculos simbólicos ao executar comandos,"

#~ msgid "        such as cd which change the current directory."
#~ msgstr "        tais como `cd', que troca o diretório atual."

#~ msgid "Using + rather than - causes these flags to be turned off.  The"
#~ msgstr "Usando + em vez de - faz com que as opções sejam desabilitadas. As"

#~ msgid "flags can also be used upon invocation of the shell.  The current"
#~ msgstr ""
#~ "opções também podem ser usadas na chamada da `shell'.  O conjunto atual"

#~ msgid ""
#~ "set of flags may be found in $-.  The remaining n ARGs are positional"
#~ msgstr ""
#~ "de opções pode ser encontrado em $-. Os n ARGs restantes são parâmetros"

#~ msgid "parameters and are assigned, in order, to $1, $2, .. $n.  If no"
#~ msgstr "posicionais e são atribuídos, em ordem, a $1, $2, .. $n.  Se nenhum"

#~ msgid "ARGs are given, all shell variables are printed."
#~ msgstr "ARG for fornecido, todas as variáveis da `shell' são exibidas."

#~ msgid "For each NAME, remove the corresponding variable or function.  Given"
#~ msgstr ""
#~ "Para cada NOME, remove a variável ou a função correspondente.  Usando-se a"

#~ msgid "the `-v', unset will only act on variables.  Given the `-f' flag,"
#~ msgstr ""
#~ "opção `-v', `unset' atua somente nas variáveis.  Usando-se a opção `-f'"

#~ msgid "unset will only act on functions.  With neither flag, unset first"
#~ msgstr "`unset' atua somente nas funções.  Sem nenhuma opção, inicialmente"

#~ msgid "tries to unset a variable, and if that fails, then tries to unset a"
#~ msgstr "`unset' tenta remover uma variável e, se falhar, tenta remover uma"

#~ msgid ""
#~ "function.  Some variables (such as PATH and IFS) cannot be unset; also"
#~ msgstr ""
#~ "função.  Algumas variáveis (como PATH e IFS) não podem ser removidas."

#~ msgid "see readonly."
#~ msgstr "Veja também o comando `readonly'."

#~ msgid "NAMEs are marked for automatic export to the environment of"
#~ msgstr ""
#~ "NOMEs são marcados para serem automaticamente exportados para o ambiente"

#~ msgid "subsequently executed commands.  If the -f option is given,"
#~ msgstr "dos comando executados a seguir.  Se a opção -f for fornecida,"

#~ msgid "the NAMEs refer to functions.  If no NAMEs are given, or if `-p'"
#~ msgstr ""
#~ "os NOMEs se referem a funções.  Se nenhum nome for fornecido, ou se `-p'"

#~ msgid "is given, a list of all names that are exported in this shell is"
#~ msgstr ""
#~ "for usado, uma lista com todos os nomes que são exportados nesta `shell' é"

#~ msgid "printed.  An argument of `-n' says to remove the export property"
#~ msgstr ""
#~ "exibida.  O argumento `-n' faz remover a propriedade de exportação dos"

#~ msgid "from subsequent NAMEs.  An argument of `--' disables further option"
#~ msgstr "NOMEs subseqüentes.  O argumento `--' desabilita o processamento de"

#~ msgid "processing."
#~ msgstr "opções posteriores."

#~ msgid ""
#~ "The given NAMEs are marked readonly and the values of these NAMEs may"
#~ msgstr ""
#~ "Os NOMEs são marcados como somente para leitura, e os valores destes"

#~ msgid "not be changed by subsequent assignment.  If the -f option is given,"
#~ msgstr ""
#~ "NOMEs não poderão ser alterados por novas atribuições.  Se a opção -f for"

#~ msgid "then functions corresponding to the NAMEs are so marked.  If no"
#~ msgstr ""
#~ "fornecida, as funções correspondentes a NOMEs também são marcadas.  Sem"

#~ msgid ""
#~ "arguments are given, or if `-p' is given, a list of all readonly names"
#~ msgstr ""
#~ "nenhum argumento, ou se `-p' for usado, uma lista com todos os nomes"

#~ msgid ""
#~ "is printed.  An argument of `-n' says to remove the readonly property"
#~ msgstr ""
#~ "somente para leitura é exibida.  O argumento `-n' remove a propriedade"

#~ msgid "from subsequent NAMEs.  The `-a' option means to treat each NAME as"
#~ msgstr "somente para leitura.  A opção `-a' faz tratar cada NOME como uma"

#~ msgid "an array variable.  An argument of `--' disables further option"
#~ msgstr ""
#~ "variável tipo matriz.  Um argumento `--' desabilita o processamento de"

#~ msgid "not given, it is assumed to be 1."
#~ msgstr "Se N não for especificado, o valor 1 é assumido ($2 vira $1 ...)."

#~ msgid "Read and execute commands from FILENAME and return.  The pathnames"
#~ msgstr "Ler e executar os comandos em ARQUIVO e retornar.  Os caminhos em"

#~ msgid "in $PATH are used to find the directory containing FILENAME."
#~ msgstr "$PATH são usados para encontrar o diretório contendo o ARQUIVO."

#~ msgid "Suspend the execution of this shell until it receives a SIGCONT"
#~ msgstr ""
#~ "Suspender a execução desta `shell' até que o sinal SIGCONT seja recebido."

#~ msgid "signal.  The `-f' if specified says not to complain about this"
#~ msgstr "Se a opção `-f' for especificada indica para não reclamar sobre ser"

#~ msgid "being a login shell if it is; just suspend anyway."
#~ msgstr ""
#~ "uma `shell de login', caso seja; simplesmente suspender de qualquer forma."

#~ msgid "Exits with a status of 0 (trueness) or 1 (falseness) depending on"
#~ msgstr ""
#~ "Termina com status 0 (verdadeiro) ou 1 (falso) conforme EXPR for avaliada."

#~ msgid "the evaluation of EXPR.  Expressions may be unary or binary.  Unary"
#~ msgstr ""
#~ "As expressões podem ser unárias ou binárias. As expressões unárias são"

#~ msgid "expressions are often used to examine the status of a file.  There"
#~ msgstr ""
#~ "muito usadas para examinar o status de um arquivo.  Existem, também,"

#~ msgid "are string operators as well, and numeric comparison operators."
#~ msgstr ""
#~ "operadores para cadeias de caracteres (strings) e comparações numéricas."

#~ msgid "File operators:"
#~ msgstr "Operadores para arquivos:"

#~ msgid "    -b FILE        True if file is block special."
#~ msgstr "    -b ARQUIVO  Verdade se o arquivo for do tipo especial de bloco."

#~ msgid "    -c FILE        True if file is character special."
#~ msgstr ""
#~ "    -c ARQUIVO  Verdade se o arquivo for do tipo especial de caracter."

#~ msgid "    -d FILE        True if file is a directory."
#~ msgstr "    -d ARQUIVO  Verdade se o arquivo for um diretório."

#~ msgid "    -e FILE        True if file exists."
#~ msgstr "    -e ARQUIVO  Verdade se o arquivo existir."

#~ msgid "    -f FILE        True if file exists and is a regular file."
#~ msgstr "    -f ARQUIVO  Verdade se o arquivo existir e for do tipo regular."

#~ msgid "    -g FILE        True if file is set-group-id."
#~ msgstr ""
#~ "    -g ARQUIVO  Verdade se o arquivo tiver o bit \"set-group-id\" ativo."

#~ msgid "    -h FILE        True if file is a symbolic link.  Use \"-L\"."
#~ msgstr ""
#~ "    -h ARQUIVO  Verdade se arquivo for um vínculo simbólico.  Usar \"-L\"."

#~ msgid "    -L FILE        True if file is a symbolic link."
#~ msgstr "    -L ARQUIVO  Verdade se o arquivo for um vínculo simbólico."

#~ msgid "    -k FILE        True if file has its \"sticky\" bit set."
#~ msgstr "    -k ARQUIVO  Verdade se o arquivo tiver o bit \"sticky\" ativo."

#~ msgid "    -p FILE        True if file is a named pipe."
#~ msgstr "    -p ARQUIVO  Verdade se o arquivo for um `named pipe'."

#~ msgid "    -r FILE        True if file is readable by you."
#~ msgstr ""
#~ "    -r ARQUIVO  Verdade se você tiver autorização para ler o arquivo."

#~ msgid "    -s FILE        True if file exists and is not empty."
#~ msgstr "    -s ARQUIVO  Verdade se o arquivo existir e não estiver vazio."

#~ msgid "    -S FILE        True if file is a socket."
#~ msgstr "    -S ARQUIVO  Verdade se o arquivo for um soquete."

#~ msgid "    -t FD          True if FD is opened on a terminal."
#~ msgstr ""
#~ "    -t FD       Verdade se o descritor de arquivo (FD) estiver aberto\n"
#~ "                    em um terminal."

#~ msgid "    -u FILE        True if the file is set-user-id."
#~ msgstr ""
#~ "    -u ARQUIVO  Verdade se o arquivo tiver o bit \"set-user-id\" ativo."

#~ msgid "    -w FILE        True if the file is writable by you."
#~ msgstr ""
#~ "    -w ARQUIVO  Verdade se você tiver autorização para escrever no "
#~ "arquivo."

#~ msgid "    -x FILE        True if the file is executable by you."
#~ msgstr ""
#~ "    -x ARQUIVO  Verdade se você tiver autorização para executar o arquivo."

#~ msgid "    -O FILE        True if the file is effectively owned by you."
#~ msgstr ""
#~ "    -O ARQUIVO  Verdade se o arquivo pertencer ao seu usuário efetivo."

#~ msgid ""
#~ "    -G FILE        True if the file is effectively owned by your group."
#~ msgstr ""
#~ "    -G ARQUIVO  Verdade se o arquivo pertencer ao seu grupo efetivo."

#~ msgid "  FILE1 -nt FILE2  True if file1 is newer than (according to"
#~ msgstr "  ARQ1 -nt ARQ2 Verdade se ARQ1 for mais novo (conforme a data"

#~ msgid "                   modification date) file2."
#~ msgstr "                de modificação) do que ARQ2."

#~ msgid "  FILE1 -ot FILE2  True if file1 is older than file2."
#~ msgstr "  ARQ1 -ot ARQ2 Verdade se ARQ1 for mais antigo que ARQ2."

#~ msgid "  FILE1 -ef FILE2  True if file1 is a hard link to file2."
#~ msgstr ""
#~ "  ARQ1 -ef ARQ2 Verdade se ARQ1 for um vínculo direto para ARQ2.\n"
#~ "                    (mesma unidade e mesmo número do inode)"

#~ msgid "String operators:"
#~ msgstr "Operadores para cadeias de caracteres (strings):"

#~ msgid "    -z STRING      True if string is empty."
#~ msgstr "    -z STRING   Verdade se STRING estiver vazia."

#~ msgid "    -n STRING"
#~ msgstr "    -n STRING"

#~ msgid "    STRING         True if string is not empty."
#~ msgstr "    STRING      Verdade se STRING não estiver vazia."

#~ msgid "    STRING1 = STRING2"
#~ msgstr "    STRING1 = STRING2"

#~ msgid "                   True if the strings are equal."
#~ msgstr "                Verdade se STRING1 for idêntica à STRING2."

#~ msgid "    STRING1 != STRING2"
#~ msgstr "    STRING1 != STRING2"

#~ msgid "                   True if the strings are not equal."
#~ msgstr "                Verdade se STRING1 não for idêntica à STRING2."

#~ msgid "    STRING1 < STRING2"
#~ msgstr "    STRING1 < STRING2"

#~ msgid ""
#~ "                   True if STRING1 sorts before STRING2 lexicographically"
#~ msgstr ""
#~ "                Verdade se STRING1 tiver ordenação anterior à STRING2."

#~ msgid "    STRING1 > STRING2"
#~ msgstr "    STRING1 > STRING2"

#~ msgid ""
#~ "                   True if STRING1 sorts after STRING2 lexicographically"
#~ msgstr ""
#~ "                Verdade se STRING1 tiver ordenação posterior à STRING2."

#~ msgid "Other operators:"
#~ msgstr "Outros operadores:"

#~ msgid "    ! EXPR         True if expr is false."
#~ msgstr "    ! EXPR         Verdade se a expressão EXPR for falsa."

#~ msgid "    EXPR1 -a EXPR2 True if both expr1 AND expr2 are true."
#~ msgstr "    EXPR1 -a EXPR2 Verdade se EXPR1 `E' EXPR2 forem verdadeiras."

#~ msgid "    EXPR1 -o EXPR2 True if either expr1 OR expr2 is true."
#~ msgstr "    EXPR1 -o EXPR2 Verdade se EXPR1 `OU' EXPR2 for verdadeira."

#~ msgid "    arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,"
#~ msgstr "    arg1 OP arg2   Testes aritméticos.  OP pode ser -eq, -ne,"

#~ msgid "                   -lt, -le, -gt, or -ge."
#~ msgstr "                   -lt, -le, -gt, ou -ge."

#~ msgid "Arithmetic binary operators return true if ARG1 is equal, not-equal,"
#~ msgstr ""
#~ "Operadores aritméticos binários retornam verdadeiro se ARG1 for igual,"

#~ msgid ""
#~ "less-than, less-than-or-equal, greater-than, or greater-than-or-equal"
#~ msgstr "diferente, menor, menor ou igual, maior, ou maior ou igual do que"

#~ msgid "than ARG2."
#~ msgstr "ARG2, respectivamente."

#~ msgid "This is a synonym for the \"test\" builtin, but the last"
#~ msgstr "É um sinônimo para o comando interno \"test\", mas o último"

#~ msgid "the shell."
#~ msgstr "executados por esta `shell'."

#~ msgid "The command ARG is to be read and executed when the shell receives"
#~ msgstr ""
#~ "O comando em ARG é para ser lido e executado quando a `shell' receber o(s)"

#~ msgid "signal(s) SIGNAL_SPEC.  If ARG is absent all specified signals are"
#~ msgstr ""
#~ "sinal(is) SINAL-ESPEC.  Se ARG for omitido, todos os sinais especificados"

#~ msgid "reset to their original values.  If ARG is the null string each"
#~ msgstr ""
#~ "retornam aos seus valores originais.  Se ARG for uma string nula, cada"

#~ msgid "SIGNAL_SPEC is ignored by the shell and by the commands it invokes."
#~ msgstr ""
#~ "SINAL-ESPEC é ignorado pela `shell' e pelos comandos chamados por ela."

#~ msgid "If SIGNAL_SPEC is EXIT (0) the command ARG is executed on exit from"
#~ msgstr ""
#~ "Se SINAL-ESPEC for EXIT (0) o comando em ARG é executado na saída da"

#~ msgid "the shell.  If SIGNAL_SPEC is DEBUG, ARG is executed after every"
#~ msgstr ""
#~ "`shell'.  Se SINAL-ESPEC for DEBUG, o comando em ARG é executado após cada"

#~ msgid "command.  If ARG is `-p' then the trap commands associated with"
#~ msgstr ""
#~ "comando.  Se ARG for `-p' então os comandos de captura associados com cada"

#~ msgid "each SIGNAL_SPEC are displayed.  If no arguments are supplied or if"
#~ msgstr "SINAL-ESPEC são exibidos.  Se nenhum argumento for fornecido, ou se"

#~ msgid "only `-p' is given, trap prints the list of commands associated with"
#~ msgstr ""
#~ "somente `-p' for fornecido, é exibida a lista dos comandos associados"

#~ msgid ""
#~ "each signal number.  SIGNAL_SPEC is either a signal name in <signal.h>"
#~ msgstr ""
#~ "com cada número de sinal.  SINAL-ESPEC é um nome de sinal em <signal.h> ou"

#~ msgid ""
#~ "or a signal number.  `trap -l' prints a list of signal names and their"
#~ msgstr ""
#~ "um número de sinal.  `trap -l' exibe a lista de nomes de sinais com seus"

#~ msgid "corresponding numbers.  Note that a signal can be sent to the shell"
#~ msgstr ""
#~ "números correspondentes.  Note que o sinal pode ser enviado para a `shell'"

#~ msgid "with \"kill -signal $$\"."
#~ msgstr "através do comando \"kill -SINAL $$\"."

#~ msgid "For each NAME, indicate how it would be interpreted if used as a"
#~ msgstr "Para cada NOME, indica como este deve ser interpretado caso seja"

#~ msgid "If the -t option is used, returns a single word which is one of"
#~ msgstr ""
#~ "Se a opção -t for fornecida, `type' retorna uma única palavra dentre"

#~ msgid ""
#~ "`alias', `keyword', `function', `builtin', `file' or `', if NAME is an"
#~ msgstr ""
#~ "`alias', `keyword', `function', `builtin', `file' ou `', se NOME for um"

#~ msgid ""
#~ "alias, shell reserved word, shell function, shell builtin, disk file,"
#~ msgstr ""
#~ "alias, uma palavra reservada, função ou comando interno da shell, um "
#~ "arquivo"

#~ msgid "or unfound, respectively."
#~ msgstr "em disco, ou não for encontrado, respectivamente."

#~ msgid "If the -p flag is used, either returns the name of the disk file"
#~ msgstr "Se a opção -p for fornecida, retorna o nome do arquivo em disco que"

#~ msgid "that would be executed, or nothing if -t would not return `file'."
#~ msgstr "deve ser executado, ou nada, caso -t não retorne `file'."

#~ msgid "If the -a flag is used, displays all of the places that contain an"
#~ msgstr "Se a opção -a for fornecida, exibe todos os locais que contém um"

#~ msgid ""
#~ "executable named `file'.  This includes aliases and functions, if and"
#~ msgstr ""
#~ "arquivo executável chamado `ARQUIVO', incluindo os aliases e funções,"

#~ msgid "only if the -p flag is not also used."
#~ msgstr "mas somente se a opção -p não for fornecida conjuntamente."

#~ msgid "Type accepts -all, -path, and -type in place of -a, -p, and -t,"
#~ msgstr "O comando `type' aceita -all, -path, e -type no lugar de"

#~ msgid "respectively."
#~ msgstr "-a, -p, and -t, respectivamente."

#~ msgid "Ulimit provides control over the resources available to processes"
#~ msgstr ""
#~ "Ulimit estabelece controle sobre os recursos disponíveis para os processos"

#~ msgid "started by the shell, on systems that allow such control.  If an"
#~ msgstr ""
#~ "iniciados por esta shell, em sistemas que permitem estes controles. Se uma"

#~ msgid "option is given, it is interpreted as follows:"
#~ msgstr "opção for fornecida, é interpretada como mostrado a seguir:"

#~ msgid "    -S\tuse the `soft' resource limit"
#~ msgstr "    -S\tutilizar os limites correntes (`soft') dos recursos"

#~ msgid "    -H\tuse the `hard' resource limit"
#~ msgstr "    -H\tutilizar os limites absolutos (`hard') dos recursos"

#~ msgid "    -a\tall current limits are reported"
#~ msgstr "    -a\ttodos os limites correntes são informados"

#~ msgid "    -c\tthe maximum size of core files created"
#~ msgstr ""
#~ "    -c\to tamanho máximo para os arquivos de imagem do núcleo criados"

#~ msgid "    -d\tthe maximum size of a process's data segment"
#~ msgstr "    -d\to tamanho máximo do segmento de dados de um processo"

#~ msgid "    -m\tthe maximum resident set size"
#~ msgstr ""
#~ "    -m\to tamanho máximo do conjunto de processos residentes em memória"

#~ msgid "    -s\tthe maximum stack size"
#~ msgstr "    -s\to tamanho máximo da pilha"

#~ msgid "    -t\tthe maximum amount of cpu time in seconds"
#~ msgstr "    -t\ta quantidade máxima de tempo de CPU em segundos"

#~ msgid "    -f\tthe maximum size of files created by the shell"
#~ msgstr "    -f\to tamanho máximo dos arquivos criados pela `shell'"

#~ msgid "    -p\tthe pipe buffer size"
#~ msgstr "    -p\to tamanho da área intermediária (buffer) do `pipe'"

#~ msgid "    -n\tthe maximum number of open file descriptors"
#~ msgstr "    -n\to número máximo de descritores de arquivos abertos"

#~ msgid "    -u\tthe maximum number of user processes"
#~ msgstr "    -u\to número máximo de processos do usuário"

#~ msgid "    -v\tthe size of virtual memory"
#~ msgstr "    -v\to tamanho da memória virtual"

#~ msgid "If LIMIT is given, it is the new value of the specified resource."
#~ msgstr ""
#~ "Se LIMITE for fornecido, torna-se o novo valor do recurso especificado."

#~ msgid "Otherwise, the current value of the specified resource is printed."
#~ msgstr "Senão, o valor atual do recurso especificado é exibido."

#~ msgid "If no option is given, then -f is assumed.  Values are in 1k"
#~ msgstr ""
#~ "Se nenhuma opção for fornecida, então -f é assumido. Os valores são em"

#~ msgid "increments, except for -t, which is in seconds, -p, which is in"
#~ msgstr "incrementos de 1k, exceto para -t, que é em segundos, -p, que é em"

#~ msgid "increments of 512 bytes, and -u, which is an unscaled number of"
#~ msgstr "incrementos de 512 bytes, e -u, que é o número cardinal de"

#~ msgid "processes."
#~ msgstr "processos."

#~ msgid ""
#~ "The user file-creation mask is set to MODE.  If MODE is omitted, or if"
#~ msgstr ""
#~ "MODO é atribuído à máscara de criação de arquivos do usuário.  Se omitido,"

#~ msgid ""
#~ "`-S' is supplied, the current value of the mask is printed.  The `-S'"
#~ msgstr ""
#~ "ou se `-S' for especificado, a máscara em uso é exibida.  A opção `-S'"

#~ msgid ""
#~ "option makes the output symbolic; otherwise an octal number is output."
#~ msgstr "exibe símbolos na saída; sem esta opção um número octal é exibido."

#~ msgid "If MODE begins with a digit, it is interpreted as an octal number,"
#~ msgstr ""
#~ "Se MODO começar por um dígito, é interpretado como sendo um número octal,"

#~ msgid ""
#~ "otherwise it is a symbolic mode string like that accepted by chmod(1)."
#~ msgstr ""
#~ "senão devem ser caracteres simbólicos, como os aceitos por chmod(1)."

#~ msgid ""
#~ "Wait for the specified process and report its termination status.  If"
#~ msgstr ""
#~ "Aguardar pelo processo especificado e informar seu status de término. Se N"

#~ msgid "N is not given, all currently active child processes are waited for,"
#~ msgstr ""
#~ "não for especificado, todos os processos filhos ativos são aguardados,"

#~ msgid "and the return code is zero.  N may be a process ID or a job"
#~ msgstr "e o código de retorno é zero.  N pode ser o ID de um processo ou a"

#~ msgid "specification; if a job spec is given, all processes in the job's"
#~ msgstr ""
#~ "especificação de um trabalho; Se for a especificação de um trabalho, todos"

#~ msgid "pipeline are waited for."
#~ msgstr "os processos presentes no `pipeline' do trabalho são aguardados."

#~ msgid "and the return code is zero.  N is a process ID; if it is not given,"
#~ msgstr ""
#~ "e o código de retorno é zero.  N é o ID de um processo; se N não for"

#~ msgid "all child processes of the shell are waited for."
#~ msgstr "especificado, todos os processos filhos da `shell' são aguardados."

#~ msgid "The `for' loop executes a sequence of commands for each member in a"
#~ msgstr ""
#~ "O laço `for' executa a seqüência de comandos para cada membro na lista de"

#~ msgid ""
#~ "list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is"
#~ msgstr ""
#~ "items.  Se `in PALAVRAS ...;' não estiver presente, então `in \"$@\"'"

#~ msgid ""
#~ "assumed.  For each element in WORDS, NAME is set to that element, and"
#~ msgstr ""
#~ "(parâmetros posicionais) é assumido. Para cada elemento em PALAVRAS, NOME"

#~ msgid "the COMMANDS are executed."
#~ msgstr "assume seu valor, e os COMANDOS são executados."

#~ msgid "The WORDS are expanded, generating a list of words.  The"
#~ msgstr ""
#~ "As palavras são expandidas, gerando uma lista de palavras. O conjunto"

#~ msgid "set of expanded words is printed on the standard error, each"
#~ msgstr ""
#~ "de palavras expandidas é enviado para a saída de erro padrão, cada uma"

#~ msgid "preceded by a number.  If `in WORDS' is not present, `in \"$@\"'"
#~ msgstr ""
#~ "precedida por um número.  Se `in PALAVRAS' for omitido, `in \"$@\"' é"

#~ msgid "is assumed.  The PS3 prompt is then displayed and a line read"
#~ msgstr "assumido.  Em seguida o prompt PS3 é exibido, e uma linha é lida da"

#~ msgid "from the standard input.  If the line consists of the number"
#~ msgstr ""
#~ "entrada padrão.  Se a linha consistir do número correspondente ao número"

#~ msgid "corresponding to one of the displayed words, then NAME is set"
#~ msgstr "de uma das palavras exibidas, então NOME é atribuído para esta"

#~ msgid "to that word.  If the line is empty, WORDS and the prompt are"
#~ msgstr ""
#~ "PALAVRA.  Se a linha estiver vazia, PALAVRAS e o prompt são exibidos"

#~ msgid "redisplayed.  If EOF is read, the command completes.  Any other"
#~ msgstr ""
#~ "novamente.  Se EOF for lido, o comando termina.  Qualquer outro valor"

#~ msgid "value read causes NAME to be set to null.  The line read is saved"
#~ msgstr "lido faz com que NOME seja tornado nulo.  A linha lida é salva"

#~ msgid "in the variable REPLY.  COMMANDS are executed after each selection"
#~ msgstr "na variável REPLY.  COMANDOS são executados após cada seleção"

#~ msgid "until a break or return command is executed."
#~ msgstr "até que o comando `break' ou `return' seja executado."

#~ msgid "`|' is used to separate multiple patterns."
#~ msgstr ""
#~ "PALAVRA e PADRÃO. O caracter `|' é usado para separar múltiplos padrões."

#~ msgid ""
#~ "The if COMMANDS are executed.  If the exit status is zero, then the then"
#~ msgstr ""
#~ "Os COMANDOS `if' são executados. Se os status de saída for zero, então os"

#~ msgid ""
#~ "COMMANDS are executed.  Otherwise, each of the elif COMMANDS are executed"
#~ msgstr ""
#~ "COMANDOS `then' são executados, senão, os COMANDOS `elif' são executados "
#~ "em"

#~ msgid ""
#~ "in turn, and if the exit status is zero, the corresponding then COMMANDS"
#~ msgstr ""
#~ "seqüência e, se o status de saída for zero, os COMANDOS `then' associados"

#~ msgid ""
#~ "are executed and the if command completes.  Otherwise, the else COMMANDS"
#~ msgstr ""
#~ "são executados e o `if' termina.  Senão, os COMANDOS da cláusula `else'"

#~ msgid ""
#~ "are executed, if present.  The exit status is the exit status of the last"
#~ msgstr ""
#~ "são executados, se houver.  O status de saída é o status de saída do"

#~ msgid "command executed, or zero if no condition tested true."
#~ msgstr ""
#~ "último comando executado, ou zero, se nenhuma condição for verdadeira."

#~ msgid "`while' COMMANDS has an exit status of zero."
#~ msgstr "COMANDOS `while' tiver um status de saída igual a zero."

#~ msgid "`until' COMMANDS has an exit status which is not zero."
#~ msgstr "COMANDOS `until' tiver um status de saída diferente de zero."

#~ msgid "Create a simple command invoked by NAME which runs COMMANDS."
#~ msgstr "Cria um comando chamado NOME o qual executa COMANDOS."

#~ msgid "Arguments on the command line along with NAME are passed to the"
#~ msgstr "Os argumentos na linha de comando juntamente com NOME são passados"

#~ msgid "function as $0 .. $n."
#~ msgstr "para a função como $0 .. $n."

#~ msgid "entire set of commands."
#~ msgstr "redirecionar todo um conjunto de comandos."

#~ msgid "This is similar to the `fg' command.  Resume a stopped or background"
#~ msgstr ""
#~ "Semelhante ao comando `fg'. Prossegue a execução de um trabalho parado ou"

#~ msgid "job.  If you specifiy DIGITS, then that job is used.  If you specify"
#~ msgstr ""
#~ "em segundo plano. Se DÍGITOS for especificado, então este trabalho é "
#~ "usado."

#~ msgid ""
#~ "WORD, then the job whose name begins with WORD is used.  Following the"
#~ msgstr ""
#~ "Se for especificado PALAVRA, o trabalho começado por PALAVRA é usado."

#~ msgid "job specification with a `&' places the job in the background."
#~ msgstr ""
#~ "Seguindo-se a especificação por um `&' põe o trabalho em segundo plano."

#~ msgid "BASH_VERSION    The version numbers of this Bash."
#~ msgstr "BASH_VERSION    Os números da versão desta `bash'."

#~ msgid "CDPATH          A colon separated list of directories to search"
#~ msgstr "CDPATH          Uma lista, separada por dois pontos, de diretórios"

#~ msgid "\t\twhen the argument to `cd' is not found in the current"
#~ msgstr "\t\ta serem pesquisados quando o argumento para `cd' não for"

#~ msgid "\t\tdirectory."
#~ msgstr "\t\tencontrado no diretório atual."

#~ msgid ""
#~ "HISTFILE        The name of the file where your command history is stored."
#~ msgstr ""
#~ "HISTFILE        O nome do arquivo onde o histórico de comandos é "
#~ "armazenado."

#~ msgid "HISTFILESIZE    The maximum number of lines this file can contain."
#~ msgstr ""
#~ "HISTFILESIZE    O número máximo de linhas que este arquivo pode conter."

#~ msgid "HISTSIZE        The maximum number of history lines that a running"
#~ msgstr "HISTSIZE        O número máximo de linhas do histórico que uma"

#~ msgid "\t\tshell can access."
#~ msgstr "\t\t`shell' em execução pode acessar."

#~ msgid "HOME            The complete pathname to your login directory."
#~ msgstr ""
#~ "HOME            O nome completo do caminho do seu diretório de login."

#~ msgid ""
#~ "HOSTTYPE        The type of CPU this version of Bash is running under."
#~ msgstr ""
#~ "HOSTTYPE        O tipo de CPU sob a qual esta `bash' está executando."

#~ msgid ""
#~ "IGNOREEOF       Controls the action of the shell on receipt of an EOF"
#~ msgstr "IGNOREEOF       Controla a ação da `shell' ao receber um caracter"

#~ msgid "\t\tcharacter as the sole input.  If set, then the value"
#~ msgstr "\t\tEOF como única entrada.  Se estiver ativa, então o valor da"

#~ msgid "\t\tof it is the number of EOF characters that can be seen"
#~ msgstr "\t\tvariável é o número de caracteres EOF que podem ser recebidos,"

#~ msgid "\t\tin a row on an empty line before the shell will exit"
#~ msgstr "\t\tde forma seguida em uma linha vazia, antes da `shell' terminar"

#~ msgid "\t\t(default 10).  When unset, EOF signifies the end of input."
#~ msgstr ""
#~ "\t\t(padrão 10).  Caso contrário, EOF significa o fim da entrada de dados."

#~ msgid "MAILCHECK\tHow often, in seconds, Bash checks for new mail."
#~ msgstr ""
#~ "MAILCHECK\tFreqüência, em segundos, para a `bash' verificar novo e-mail."

#~ msgid "MAILPATH\tA colon-separated list of filenames which Bash checks"
#~ msgstr ""
#~ "MAILPATH\tUma lista, separada por dois pontos, de nomes de arquivos,"

#~ msgid "\t\tfor new mail."
#~ msgstr "\t\tnos quais a `bash' vai verificar se existe novo e-mail."

#~ msgid "OSTYPE\t\tThe version of Unix this version of Bash is running on."
#~ msgstr "OSTYPE\t\tA versão do Unix sob a qual a `bash' está executando."

#~ msgid "PATH            A colon-separated list of directories to search when"
#~ msgstr ""
#~ "PATH            Uma lista, separada por dois pontos, de diretórios a"

#~ msgid "\t\tlooking for commands."
#~ msgstr "\t\tserem pesquisados quando os comandos forem procurados."

#~ msgid "PROMPT_COMMAND  A command to be executed before the printing of each"
#~ msgstr "PROMPT_COMMAND  O comando a ser executado antes da exibição de cada"

#~ msgid "\t\tprimary prompt."
#~ msgstr "\t\tmensagem de prompt primária."

#~ msgid "PS1             The primary prompt string."
#~ msgstr "PS1             A mensagem primária de prompt exibida."

#~ msgid "PS2             The secondary prompt string."
#~ msgstr "PS2             A mensagem secundária de prompt exibida."

#~ msgid "TERM            The name of the current terminal type."
#~ msgstr "TERM            O nome do tipo de terminal em uso no momento."

#~ msgid "auto_resume     Non-null means a command word appearing on a line by"
#~ msgstr ""
#~ "auto_resume     Não nulo significa que um comando aparecendo sozinho em"

#~ msgid "\t\titself is first looked for in the list of currently"
#~ msgstr ""
#~ "\t\tlinha deve ser procurado primeiro na lista de trabalhos parados."

#~ msgid "\t\tstopped jobs.  If found there, that job is foregrounded."
#~ msgstr ""
#~ "\t\tSe for encontrado na lista, o trabalho vai para o primeiro plano."

#~ msgid "\t\tA value of `exact' means that the command word must"
#~ msgstr ""
#~ "\t\tO valor `exact' significa que a palavra do comando deve corresponder"

#~ msgid "\t\texactly match a command in the list of stopped jobs.  A"
#~ msgstr "\t\texatamente a um comando da lista de trabalhos parados."

#~ msgid "\t\tvalue of `substring' means that the command word must"
#~ msgstr "\t\tO valor `substring' significa que a palavra do comando deve"

#~ msgid "\t\tmatch a substring of the job.  Any other value means that"
#~ msgstr "\t\tcorresponder a uma parte do trabalho.  Qualquer outro valor"

#~ msgid "\t\tthe command must be a prefix of a stopped job."
#~ msgstr ""
#~ "\t\tsignifica que o comando deve ser um prefixo de um trabalho parado."

#~ msgid "command_oriented_history"
#~ msgstr "command_oriented_history"

#~ msgid ""
#~ "                Non-null means to save multiple-line commands together on"
#~ msgstr ""
#~ "                Se não for nulo significa salvar comandos com múltiplas"

#~ msgid "                a single history line."
#~ msgstr "                linhas, juntas em uma única linha do histórico."

#~ msgid "histchars       Characters controlling history expansion and quick"
#~ msgstr ""
#~ "histchars       Caracteres que controlam a expansão do histórico e a"

#~ msgid "\t\tsubstitution.  The first character is the history"
#~ msgstr "\t\tsubstituição rápida.  O primeiro caracter é o de substituição"

#~ msgid "\t\tsubstitution character, usually `!'.  The second is"
#~ msgstr "\t\tdo histórico, geralmente o `!'.  O segundo caracter é o"

#~ msgid "\t\tthe `quick substitution' character, usually `^'.  The"
#~ msgstr "\t\tde substituição rápida, geralmente o `^'.  O terceiro caracter"

#~ msgid "\t\tthird is the `history comment' character, usually `#'."
#~ msgstr "\t\té o de comentário do histórico, geralmente o `#'."

#~ msgid "HISTCONTROL\tSet to a value of `ignorespace', it means don't enter"
#~ msgstr ""
#~ "HISTCONTROL\tCom valor igual a `ignorespace', significa não introduzir"

#~ msgid "\t\tlines which begin with a space or tab on the history"
#~ msgstr ""
#~ "\t\tlinhas que iniciam por espaço ou tabulação na lista de histórico."

#~ msgid "\t\tlist.  Set to a value of `ignoredups', it means don't"
#~ msgstr "\t\tCom valor igual a `ignoredups', significa não introduzir linhas"

#~ msgid "\t\tenter lines which match the last entered line.  Set to"
#~ msgstr "\t\tque correspondam à última linha introduzida.  Com valor igual a"

#~ msgid "\t\t`ignoreboth' means to combine the two options.  Unset,"
#~ msgstr "\t\t`ignoreboth' significa combinar as duas opções.  Remover,"

#~ msgid "\t\tor set to any other value than those above means to save"
#~ msgstr ""
#~ "\t\tou atribuir algum outro valor que não os acima, significa salvar"

#~ msgid "\t\tall lines on the history list."
#~ msgstr "\t\ttodas as linhas na lista de histórico."

#~ msgid "Toggle the values of variables controlling optional behavior."
#~ msgstr ""
#~ "Alterna os valores das variáveis controladoras de comportamentos "
#~ "opcionais."

#~ msgid "The -s flag means to enable (set) each OPTNAME; the -u flag"
#~ msgstr "A opção -s ativa (set) cada NOME-OPÇÃO; a opção -u desativa cada"

#~ msgid "unsets each OPTNAME.  The -q flag suppresses output; the exit"
#~ msgstr ""
#~ "NOME-OPÇÃO. A opção -q suprime a saída; o status de término indica se"

#~ msgid "status indicates whether each OPTNAME is set or unset.  The -o"
#~ msgstr "cada NOME-OPÇÃO foi ativado ou desativado  A opção -o restringe"

#~ msgid "option restricts the OPTNAMEs to those defined for use with"
#~ msgstr "NOME-OPÇÃO para aqueles definidos para uso através de `set -o'."

#~ msgid "`set -o'.  With no options, or with the -p option, a list of all"
#~ msgstr "Sem nenhuma opção, ou com a opção -p, uma lista com todas as"

#~ msgid "settable options is displayed, with an indication of whether or"
#~ msgstr ""
#~ "opções que podem ser ativadas é exibida, com indicação sobre se cada uma"

#~ msgid "not each is set."
#~ msgstr "das opções está ativa ou não."
