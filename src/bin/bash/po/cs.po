# Czech tranlation for bash.
# Copyright (C) 2008 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Petr Pisar <petr.pisar@atlas.cz>, 2008.
#
msgid ""
msgstr ""
"Project-Id-Version: bash 4.0-pre1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2009-02-19 14:53-0500\n"
"PO-Revision-Date: 2008-09-07 13:09+0200\n"
"Last-Translator: Petr Pisar <petr.pisar@atlas.cz>\n"
"Language-Team: Czech <translation-team-cs@lists.sourceforge.net>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2;\n"

#: arrayfunc.c:50
msgid "bad array subscript"
msgstr "chybný podskript pole"

#: arrayfunc.c:313 builtins/declare.def:474
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: číslované pole nezle převést na pole asociativní"

#: arrayfunc.c:479
#, c-format
msgid "%s: invalid associative array key"
msgstr "%s: neplatný klíč asociativního pole"

#: arrayfunc.c:481
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: přes nečíselný indexu nelze dosadit"

# FIXME: subscript je klicove slovo bashe 4 nebo skutecne podprogram?
# přiřazuje se do pole nebo pole někam?
#: arrayfunc.c:517
#, fuzzy, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s: %s: při přiřazovaní asociativního pole se musí použít podprogram"

#: bashhist.c:379
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: nelze vytvořit: %s"

#: bashline.c:3413
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr "bash_execute_unix_command: pro příkaz nelze nalézt klávesovou mapu "

#: bashline.c:3491
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: první nebílý znak není „\"“"

#: bashline.c:3520
#, c-format
msgid "no closing `%c' in %s"
msgstr "ne zavírající „%c“ v %s"

#: bashline.c:3554
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: chybí dvojtečkový oddělovač"

#: builtins/bind.def:120 builtins/bind.def:123
msgid "line editing not enabled"
msgstr ""

#: builtins/bind.def:206
#, c-format
msgid "`%s': invalid keymap name"
msgstr "„%s“: chybný název klávesové mapy"

#: builtins/bind.def:245
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: nelze číst: %s"

#: builtins/bind.def:260
#, c-format
msgid "`%s': cannot unbind"
msgstr "„%s“: nelze zrušit vazbu"

#: builtins/bind.def:295 builtins/bind.def:325
#, c-format
msgid "`%s': unknown function name"
msgstr "„%s“: neznámé jméno funkce"

#: builtins/bind.def:303
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s není svázán s žádnou klávesou.\n"

#: builtins/bind.def:307
#, c-format
msgid "%s can be invoked via "
msgstr "%s lze vyvolat přes "

#: builtins/break.def:77 builtins/break.def:117
msgid "loop count"
msgstr "počet smyček"

#: builtins/break.def:137
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "má smysl jen ve smyčkách „for“, „while“ nebo „until“"

#: builtins/caller.def:133
#, fuzzy
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns "
msgstr "Vrací kontext aktuálního volání podrutiny."

#: builtins/cd.def:215
msgid "HOME not set"
msgstr "není nestavena HOME"

#: builtins/cd.def:227
msgid "OLDPWD not set"
msgstr "není nastaveno OLDPWD"

#: builtins/common.c:101
#, c-format
msgid "line %d: "
msgstr "řádek %d: "

#: builtins/common.c:139 error.c:260
#, c-format
msgid "warning: "
msgstr "varování: "

#: builtins/common.c:153
#, c-format
msgid "%s: usage: "
msgstr "%s: užití: "

#: builtins/common.c:166 test.c:822
msgid "too many arguments"
msgstr "příliš mnoho argumentů"

#: builtins/common.c:191 shell.c:493 shell.c:774
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: přepínač vyžaduje argument"

#: builtins/common.c:198
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: vyžadován číselný argument"

#: builtins/common.c:205
#, c-format
msgid "%s: not found"
msgstr "%s: nenalezeno"

#: builtins/common.c:214 shell.c:787
#, c-format
msgid "%s: invalid option"
msgstr "%s: chybný přepínač"

#: builtins/common.c:221
#, c-format
msgid "%s: invalid option name"
msgstr "%s: chybný název přepínače"

#: builtins/common.c:228 general.c:231 general.c:236
#, c-format
msgid "`%s': not a valid identifier"
msgstr "„%s“: není platným identifikátorem"

#: builtins/common.c:238
msgid "invalid octal number"
msgstr "neplatné osmičkové číslo"

#: builtins/common.c:240
msgid "invalid hex number"
msgstr "chybné šestnáctkové číslo"

#: builtins/common.c:242 expr.c:1255
msgid "invalid number"
msgstr "chybné číslo"

#: builtins/common.c:250
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: chybné určení signálu"

#: builtins/common.c:257
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "„%s“: není PID ani platným označením úlohy"

#: builtins/common.c:264 error.c:453
#, c-format
msgid "%s: readonly variable"
msgstr "%s: proměnná pouze pro čtení"

#: builtins/common.c:272
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s mimo rozsah"

#: builtins/common.c:272 builtins/common.c:274
msgid "argument"
msgstr "argument"

#: builtins/common.c:274
#, c-format
msgid "%s out of range"
msgstr "%s mimo rozsah"

#: builtins/common.c:282
#, c-format
msgid "%s: no such job"
msgstr "%s: žádná taková úloha"

#: builtins/common.c:290
#, c-format
msgid "%s: no job control"
msgstr "%s: žádné řízení úloh"

#: builtins/common.c:292
msgid "no job control"
msgstr "žádné řízení úloh"

#: builtins/common.c:302
#, c-format
msgid "%s: restricted"
msgstr "%s: omezeno"

#: builtins/common.c:304
msgid "restricted"
msgstr "omezeno"

#: builtins/common.c:312
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: není vestavěným příkazem shellu"

#: builtins/common.c:321
#, c-format
msgid "write error: %s"
msgstr "chyba zápisu: %s"

#: builtins/common.c:329
#, c-format
msgid "error setting terminal attributes: %s"
msgstr ""

#: builtins/common.c:331
#, c-format
msgid "error getting terminal attributes: %s"
msgstr ""

#: builtins/common.c:563
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: chyba při zjišťování současného adresáře: %s: %s\n"

#: builtins/common.c:629 builtins/common.c:631
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: nejednoznačné určení úlohy"

#: builtins/complete.def:270
#, c-format
msgid "%s: invalid action name"
msgstr "%s: neplatný název akce"

#: builtins/complete.def:430 builtins/complete.def:615
#: builtins/complete.def:813
#, c-format
msgid "%s: no completion specification"
msgstr "%s: žádné doplňování neurčeno"

#: builtins/complete.def:667
msgid "warning: -F option may not work as you expect"
msgstr "varování: přepínač -F možná nebude dělat, co jste čekali"

#: builtins/complete.def:669
msgid "warning: -C option may not work as you expect"
msgstr "varování: přepínač -C možná nebude dělat, co jste čekali"

#: builtins/complete.def:786
msgid "not currently executing completion function"
msgstr "doplňovací funkce se právě nevykonává"

#: builtins/declare.def:122
msgid "can only be used in a function"
msgstr "může být použito jen ve funkci"

#: builtins/declare.def:353
msgid "cannot use `-f' to make functions"
msgstr "„-f“ nezle použít na výrobu funkce"

#: builtins/declare.def:365 execute_cmd.c:4818
#, c-format
msgid "%s: readonly function"
msgstr "%s: funkce jen pro čtení"

#: builtins/declare.def:461
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: takto nelze likvidovat pole"

#: builtins/declare.def:468
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: asociativní pole nelze převést na číslované pole"

#: builtins/enable.def:137 builtins/enable.def:145
msgid "dynamic loading not available"
msgstr "dynamické nahrávání není dostupné"

#: builtins/enable.def:312
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "sdílený objekt %s nelze otevřít: %s"

#: builtins/enable.def:335
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "ve sdílením objektu %2$s nelze nalézt %1$s: %3$s"

#: builtins/enable.def:459
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: není dynamicky nahráno"

#: builtins/enable.def:474
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: nelze smazat: %s"

#: builtins/evalfile.c:134 builtins/hash.def:169 execute_cmd.c:4675
#: shell.c:1439
#, c-format
msgid "%s: is a directory"
msgstr "%s: je adresářem"

#: builtins/evalfile.c:139
#, c-format
msgid "%s: not a regular file"
msgstr "%s: není obyčejný soubor"

#: builtins/evalfile.c:147
#, c-format
msgid "%s: file is too large"
msgstr "%s: soubor je příliš velký"

#: builtins/evalfile.c:185 execute_cmd.c:4745 shell.c:1449
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: binární soubor nelze spustit"

#: builtins/exec.def:212
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: nelze provést: %s"

# FIXME: Toto je literál, jedná se o syntaxi příkazu, který nemá žádné
# parametry? Nebo se jedná o zprávu shellu při odhlášení?
#: builtins/exit.def:65
#, fuzzy, c-format
msgid "logout\n"
msgstr "logout\n"

#: builtins/exit.def:88
msgid "not login shell: use `exit'"
msgstr "toto není login shell: použijte „exit“"

#: builtins/exit.def:120
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Jsou zde pozastavení úlohy.\n"

#: builtins/exit.def:122
#, c-format
msgid "There are running jobs.\n"
msgstr "Jsou zde běžící úlohy.\n"

#: builtins/fc.def:261
msgid "no command found"
msgstr "žádný příkaz nenalezen"

#: builtins/fc.def:341
msgid "history specification"
msgstr "určení historie"

#: builtins/fc.def:362
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: dočasný soubor nelze otevřít: %s"

#: builtins/fg_bg.def:149 builtins/jobs.def:282
msgid "current"
msgstr "současný"

#: builtins/fg_bg.def:158
#, c-format
msgid "job %d started without job control"
msgstr "úloha %d spuštěna bez správy úloh"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: chybný přepínač – %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: přepínač vyžaduje argument – %c\n"

#: builtins/hash.def:92
msgid "hashing disabled"
msgstr "hashování zakázáno"

#: builtins/hash.def:138
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: tabulka hashů je prázdná\n"

#: builtins/hash.def:244
#, c-format
msgid "hits\tcommand\n"
msgstr "zásahů\tpříkaz\n"

#: builtins/help.def:130
#, c-format
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Příkazy shellu shodující se s klíčovým slovem „"
msgstr[1] "Příkazy shellu shodující se s klíčovými slovy „"
msgstr[2] "Příkazy shellu shodující se s klíčovými slovy „"

#: builtins/help.def:168
#, c-format
msgid ""
"no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr ""
"žádné téma nápovědy se nehodí pro „%s“. Zkuste „help help“ nebo „man -k %s“ "
"nebo „info %s“."

#: builtins/help.def:185
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: nelze otevřít: %s"

#: builtins/help.def:337
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Tyto příkazy shellu jsou vnitřně definovány. Napište „help“, aby ste "
"získali\n"
"tento seznam. Podrobnosti o funkci „název“ získáte příkazem „help název“.\n"
"Příkazem „info bash“ získáte obecné informace o tomto shellu.\n"
"Použijte „man -k“ nebo „info“, chcete-li zjistit více o příkazech, které\n"
"na tomto seznamu nejsou.\n"
"\n"
"Hvězdička (*) vedle jména znamená, že příkaz je zakázán.\n"
"\n"

#: builtins/history.def:154
msgid "cannot use more than one of -anrw"
msgstr "nelze použít více jak jeden z -anrw"

#: builtins/history.def:186
msgid "history position"
msgstr "místo v historii"

#: builtins/history.def:365
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: expanze historie selhala"

#: builtins/inlib.def:71
#, c-format
msgid "%s: inlib failed"
msgstr "%s: inlib selhala"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "s „-x“ nejsou dovoleny další přepínače"

#: builtins/kill.def:197
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: argumenty musí být proces nebo identifikátor úlohy"

#: builtins/kill.def:260
msgid "Unknown error"
msgstr "Neznámá chyba"

#: builtins/let.def:95 builtins/let.def:120 expr.c:501 expr.c:516
msgid "expression expected"
msgstr "očekáván výraz"

#: builtins/mapfile.def:241 builtins/read.def:272
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: chybné určení deskriptoru souboru"

#: builtins/mapfile.def:249 builtins/read.def:279
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: neplatný deskriptor souboru: %s"

#: builtins/mapfile.def:258 builtins/mapfile.def:296
#, c-format
msgid "%s: invalid line count"
msgstr "%s: chybný počet řádků"

#: builtins/mapfile.def:269
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: chybný počátek pole"

#: builtins/mapfile.def:286
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: neplatné množství mezi voláními"

#: builtins/mapfile.def:318
msgid "empty array variable name"
msgstr "prázdný název proměnné typu pole"

#: builtins/mapfile.def:339
msgid "array variable support required"
msgstr "je vyžadována podpora proměnných typu pole"

#: builtins/printf.def:367
#, c-format
msgid "`%s': missing format character"
msgstr "„%s“: postrádám formátovací znak"

#: builtins/printf.def:544
#, c-format
msgid "`%c': invalid format character"
msgstr "„%c“: neplatný formátovací znak"

#: builtins/printf.def:571
#, c-format
msgid "warning: %s: %s"
msgstr "varování: %s: %s"

#: builtins/printf.def:750
msgid "missing hex digit for \\x"
msgstr "u \\x chybí šestnáctková číslovka"

#: builtins/pushd.def:195
msgid "no other directory"
msgstr "žádný další adresář"

#: builtins/pushd.def:462
msgid "<no current directory>"
msgstr "<žádný aktuální adresář>"

#: builtins/pushd.def:506
msgid "directory stack empty"
msgstr "prázdný zásobník adresářů"

#: builtins/pushd.def:508
msgid "directory stack index"
msgstr "pořadí v zásobníku adresářů"

#: builtins/pushd.def:683
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Zobrazí seznam právě zapamatovaných adresářů. Adresáře si najdou svoji\n"
"    cestu na seznam příkazem „pushd“ a procházet seznamem zpět lze příkazem\n"
"    „popd“.\n"
"    \n"
"    Přepínače:\n"
"      -c\tvyprázdní zásobník adresářů tím, že smaže všechny jeho prvky\n"
"      -l\tnevypisuje adresáře relativní vašemu domovskému adresáři pomocí\n"
"    \tvlnkové předpony\n"
"      -p\tvypíše zásobník adresářů stylem jedna položka na jeden řádek\n"
"      -v\tvypíše zásobník adresářů stylem jedna položka na jeden řádek\n"
"    \tuvozená svojí pozicí na zásobníku\n"
"    \n"
"    Argumenty:\n"
"      +N\tZobrazí N. položku počítáno zleva na seznamu, který zobrazuje\n"
"    \tdirs, když je vyvolán bez přepínačů, počínaje nulou.\n"
"    \n"
"      -N\tZobrazí N. položku počítáno zprava na seznamu, který zobrazuje\n"
"    \tdirs, když je vyvolán bez přepínačů, počínaje nulou."

#: builtins/pushd.def:705
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Přidá adresář na vrchol zásobníku adresářů nebo zásobník zrotuje tak,\n"
"    že nový vrchol zásobníku se stane současným pracovním adresářem. Bez\n"
"    argumentů prohodí dva vrchní adresáře.\n"
"    \n"
"    Přepínače:\n"
"      -n\tPotlačí obvyklou změnu adresáře, když se na zásobník přidávají\n"
"    \tadresáře, takže změněn bude pouze zásobník.\n"
"    \n"
"    Argumenty:\n"
"      +N\tZrotuje zásobník tak, že N. adresář (počítáno zleva na seznamu\n"
"    \tzobrazovaném pomocí „dirs“, počínaje nulou) se dostane na vrchol.\n"
"    \n"
"      -N\tZrotuje zásobník tak, že N. adresář (počítáno zprava na seznamu\n"
"    \tzobrazovaném pomocí „dirs“, počínaje nulou) se dostane na vrchol.\n"
"    \n"
"      ADRESÁŘ\n"
"    \tPřidá ADRESÁŘ na vrchol zásobníku adresářů a učiní jej novým\n"
"    \tsoučasným pracovním adresářem.\n"
"    \n"
"    Zásobník adresářů si můžete prohlédnout příkazem „dirs“."

#: builtins/pushd.def:730
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Odstraní položku ze zásobníku adresářů. Bez argumentů odstraní adresář\n"
"    z vrcholu zásobníku a přepne se do nového vrcholového adresáře.\n"
"    \n"
"    Přepínače:\n"
"      -n\tPotlačí obvyklou změnu adresáře, když se ze zásobníku odebírají\n"
"    \tadresáře, takže změněn bude pouze zásobník.\n"
"    \n"
"    Argumenty:\n"
"      +N\tOdstraní N. položku počítáno zleva na seznamu zobrazovaném pomocí\n"
"    \t„dirs“, počínaje nulou. Na příklad: „popd +0“ odstraní první\n"
"    \tadresář, „popd -1“ druhý.\n"
"    \n"
"      -N\tOdstraní N. položku počítáno zprava na seznamu zobrazovaném "
"pomocí\n"
"    \t„dirs“, počínaje nulou. Na příklad: „popd -0“ odstraní poslední\n"
"    \tadresář, „popd -1“ další vedle posledního.\n"
"    \n"
"    Zásobník adresářů si můžete prohlédnout příkazem „dirs“."

#: builtins/read.def:248
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: chybné určení časového limitu"

#: builtins/read.def:574
#, c-format
msgid "read error: %d: %s"
msgstr "chyba čtení: %d: %s"

#: builtins/return.def:73
msgid "can only `return' from a function or sourced script"
msgstr "„return“ lze provést jen z funkce nebo skriptu načteného přes „source“"

#: builtins/set.def:768
msgid "cannot simultaneously unset a function and a variable"
msgstr "funkci i proměnnou nelze rušit současně"

#: builtins/set.def:805
#, c-format
msgid "%s: cannot unset"
msgstr "%s: nelze zrušit"

#: builtins/set.def:812
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: nelze zrušit: %s jen pro čtení"

#: builtins/set.def:823
#, c-format
msgid "%s: not an array variable"
msgstr "%s: není (proměnnou typu) pole"

#: builtins/setattr.def:186
#, c-format
msgid "%s: not a function"
msgstr "%s: není funkcí"

#: builtins/shift.def:71 builtins/shift.def:77
msgid "shift count"
msgstr "počet shiftů"

#: builtins/shopt.def:254
msgid "cannot set and unset shell options simultaneously"
msgstr "přepínač shellu nelze zároveň nastavit a zrušit"

#: builtins/shopt.def:319
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: chybný název přepínače shellu"

#: builtins/source.def:128
msgid "filename argument required"
msgstr "vyžadován argument s názvem souboru"

#: builtins/source.def:153
#, c-format
msgid "%s: file not found"
msgstr "%s: soubor nenalezen"

#: builtins/suspend.def:101
msgid "cannot suspend"
msgstr "nelze pozastavit"

#: builtins/suspend.def:111
msgid "cannot suspend a login shell"
msgstr "login shell nelze pozastavit"

#: builtins/type.def:234
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s je alias na „%s“\n"

#: builtins/type.def:255
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s je klíčové slovo shellu\n"

#: builtins/type.def:274
#, c-format
msgid "%s is a function\n"
msgstr "%s je funkce\n"

#: builtins/type.def:296
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s je součást shellu\n"

#: builtins/type.def:317 builtins/type.def:391
#, c-format
msgid "%s is %s\n"
msgstr "%s je %s\n"

#: builtins/type.def:337
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "%s je zahashován (%s)\n"

#: builtins/ulimit.def:372
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: chybný argument s limitou"

#: builtins/ulimit.def:398
#, c-format
msgid "`%c': bad command"
msgstr "„%c“: chybný příkaz"

#: builtins/ulimit.def:427
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: limit nelze zjistit: %s"

#: builtins/ulimit.def:453
msgid "limit"
msgstr "limit"

#: builtins/ulimit.def:465 builtins/ulimit.def:765
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: limit nelze změnit: %s"

#: builtins/umask.def:118
msgid "octal number"
msgstr "osmičkové číslo"

#: builtins/umask.def:231
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "„%c“: chybný operátor symbolických práv"

#: builtins/umask.def:286
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "„%c“: chybný znak symbolický práv "

#: error.c:89 error.c:320 error.c:322 error.c:324
msgid " line "
msgstr " řádek "

#: error.c:164
#, c-format
msgid "last command: %s\n"
msgstr "poslední příkaz: %s\n"

#: error.c:172
#, c-format
msgid "Aborting..."
msgstr "Ukončuji…"

#: error.c:405
msgid "unknown command error"
msgstr "chyba neznámého příkazu"

#: error.c:406
msgid "bad command type"
msgstr "chybný druh příkazu"

#: error.c:407
msgid "bad connector"
msgstr "chybný konektor"

#: error.c:408
msgid "bad jump"
msgstr "chybný skok"

#: error.c:446
#, c-format
msgid "%s: unbound variable"
msgstr "%s: nevázaná proměnná"

#: eval.c:181
#, c-format
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\ačasový limit pro čekání na vstup vypršel: automatické odhlášení\n"

#: execute_cmd.c:491
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "standardní vstup nelze přesměrovat z /dev/null: %s"

#: execute_cmd.c:1112
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: „%c“: chybný formátovací znak"

#: execute_cmd.c:2011
msgid "pipe error"
msgstr "chyba v rouře"

#: execute_cmd.c:4363
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: omezeno: v názvu příkazu nesmí být „/“"

#: execute_cmd.c:4454
#, c-format
msgid "%s: command not found"
msgstr "%s: příkaz nenalezen"

#: execute_cmd.c:4708
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: chybný interpretr"

#: execute_cmd.c:4857
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "deskriptor souboru %d nelze duplikovat na deskriptor %d"

#: expr.c:241
msgid "expression recursion level exceeded"
msgstr "úroveň rekurze výrazu byla překročena"

#: expr.c:265
msgid "recursion stack underflow"
msgstr "zásobník rekurze podtekl"

#: expr.c:379
msgid "syntax error in expression"
msgstr "syntaktická chyba ve výrazu"

#: expr.c:419
msgid "attempted assignment to non-variable"
msgstr "pokus o přiřazení do ne-proměnné"

#: expr.c:440 expr.c:445 expr.c:756
msgid "division by 0"
msgstr "dělení nulou"

#: expr.c:471
msgid "bug: bad expassign token"
msgstr "chyba: chybný expassing token"

#: expr.c:513
msgid "`:' expected for conditional expression"
msgstr "v podmíněném výrazu očekávána „:“"

#: expr.c:781
msgid "exponent less than 0"
msgstr "mocnitel menší než 0"

#: expr.c:826
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "po přednostním zvýšení nebo snížení očekáván identifikátor"

#: expr.c:854
msgid "missing `)'"
msgstr "postrádám „)“"

#: expr.c:897 expr.c:1175
msgid "syntax error: operand expected"
msgstr "syntaktická chyba: očekáván operand"

#: expr.c:1177
msgid "syntax error: invalid arithmetic operator"
msgstr "syntaktická chyba: chybný aritmetický operátor"

#: expr.c:1201
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (chybný token je „%s“)"

#: expr.c:1259
msgid "invalid arithmetic base"
msgstr "chybný aritmetický základ"

#: expr.c:1279
msgid "value too great for base"
msgstr "hodnot je pro základ příliš velká"

#: expr.c:1328
#, c-format
msgid "%s: expression error\n"
msgstr "%s: chyba výrazu\n"

#: general.c:61
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: rodičovské adresáře nejsou přístupné"

#: input.c:94 subst.c:4559
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "na deskriptoru %d nelze resetovat režim nodelay"

#: input.c:258
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "nový deskriptor souboru pro vstup bashe z deskr. %d nelze alokovat"

#: input.c:266
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: buffer již pro nový deskriptor %d existuje"

#: jobs.c:466
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: pgrp roury"

#: jobs.c:887
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "forknutý PID %d se objevil v běžící úloze %d"

#: jobs.c:1005
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "mažu pozastavenou úlohu %d se skupinou procesů %ld"

# FIXME: in the_pipeline znamená do nebo v?
#: jobs.c:1110
#, fuzzy, c-format
msgid "add_process: process %5ld (%s) in the_pipeline"
msgstr "add_process: proces %5ld (%s) do the_pipeline"

#: jobs.c:1113
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "add_process: PID %5ld (%s) označen za stále živého"

#: jobs.c:1401
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: žádný takový PID"

#: jobs.c:1416
#, c-format
msgid "Signal %d"
msgstr "Signál %d"

# FIXME: rod a zkontrolovat následující
#: jobs.c:1430 jobs.c:1455
msgid "Done"
msgstr "Dokonán"

#: jobs.c:1435 siglist.c:122
msgid "Stopped"
msgstr "Pozastaven"

#: jobs.c:1439
#, c-format
msgid "Stopped(%s)"
msgstr "Pozastaven (%s)"

#: jobs.c:1443
msgid "Running"
msgstr "Běží"

#: jobs.c:1457
#, c-format
msgid "Done(%d)"
msgstr "Dokonán (%d)"

# FIXME: Jedná se o způsob ukončení zavoláním funkce exit(%d)?
#: jobs.c:1459
#, fuzzy, c-format
msgid "Exit %d"
msgstr "Exit %d"

#: jobs.c:1462
msgid "Unknown status"
msgstr "Stav neznámý"

#: jobs.c:1549
#, c-format
msgid "(core dumped) "
msgstr "(core dumped [obraz paměti uložen]) "

#: jobs.c:1568
#, c-format
msgid "  (wd: %s)"
msgstr "  (cwd: %s)"

#: jobs.c:1771
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "setpgid na potomku (z %ld na %ld)"

#: jobs.c:2099 nojobs.c:585
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: PID %ld není potomkem tohoto shellu"

#: jobs.c:2326
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for: Žádný záznam o procesu %ld"

#: jobs.c:2598
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: úloha %d je pozastavena"

#: jobs.c:2820
#, c-format
msgid "%s: job has terminated"
msgstr "%s: úloha skončila"

#: jobs.c:2829
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: úloha %d je již na pozadí"

#: jobs.c:3492
#, c-format
msgid "%s: line %d: "
msgstr "%s: řádek %d: "

#: jobs.c:3506 nojobs.c:814
#, c-format
msgid " (core dumped)"
msgstr " (core dumped [obraz paměti uložen])"

#: jobs.c:3518 jobs.c:3531
#, c-format
msgid "(wd now: %s)\n"
msgstr "(cwd nyní: %s)\n"

#: jobs.c:3563
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: getpgrp selhalo"

#: jobs.c:3623
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: disciplína linky"

#: jobs.c:3633
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.c:3661
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "nelze nastavit skupinu procesů terminálu (%d)"

#: jobs.c:3666
msgid "no job control in this shell"
msgstr "žádná správa úloh v tomto shellu"

#: lib/malloc/malloc.c:296
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: předpoklad nesplněn: %s\n"

#: lib/malloc/malloc.c:312
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: zbabraný předpoklad\r\n"

#: lib/malloc/malloc.c:313
#, fuzzy
msgid "unknown"
msgstr "není známo"

#: lib/malloc/malloc.c:797
msgid "malloc: block on free list clobbered"
msgstr "malloc: blok v seznamu uvolněných zbit"

#: lib/malloc/malloc.c:874
msgid "free: called with already freed block argument"
msgstr "free: zavoláno s argumentem již uvolněného bloku"

#: lib/malloc/malloc.c:877
msgid "free: called with unallocated block argument"
msgstr "free: zavoláno s argumentem nenaalokovaného bloku"

#: lib/malloc/malloc.c:896
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: zjištěno podtečení, mh_nbytes mimo rozsah"

#: lib/malloc/malloc.c:902
msgid "free: start and end chunk sizes differ"
msgstr "free: velikosti počátečního a koncového kusu se liší"

#: lib/malloc/malloc.c:1001
msgid "realloc: called with unallocated block argument"
msgstr "realloc: zavoláno s argumentem nenaalokovaného bloku"

#: lib/malloc/malloc.c:1016
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc: zjištěno podtečení, mh_nbytes mimo rozsah"

#: lib/malloc/malloc.c:1022
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: velikosti počátečního a koncového kusu se liší"

#: lib/malloc/table.c:177
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: tabulka alokací je plná FIND_ALLOC?\n"

#: lib/malloc/table.c:184
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: %p již obsažen v tabulce jako alokovaný?\n"

#: lib/malloc/table.c:220
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_free: %p již obsažen v tabulce jako volný?\n"

#: lib/sh/fmtulong.c:101
msgid "invalid base"
msgstr "chybný základ"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr "%s: stroj není znám"

#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr "%s: chybná služba"

#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: chybné určení síťové cesty"

#: lib/sh/netopen.c:346
msgid "network operations not supported"
msgstr "síťové operace nejsou podporovány"

#: mailcheck.c:433
msgid "You have mail in $_"
msgstr "V $_ máte poštu"

#: mailcheck.c:458
msgid "You have new mail in $_"
msgstr "V $_ máte novou poštu"

#: mailcheck.c:474
#, c-format
msgid "The mail in %s has been read\n"
msgstr "Pošta v %s je přečtená\n"

#: make_cmd.c:322
msgid "syntax error: arithmetic expression required"
msgstr "chyba syntaxe: vyžadován aritmetický výraz"

#: make_cmd.c:324
msgid "syntax error: `;' unexpected"
msgstr "chyba syntaxe: neočekávaný „;“"

#: make_cmd.c:325
#, c-format
msgid "syntax error: `((%s))'"
msgstr "chyba syntaxe: „((%s))“"

#: make_cmd.c:567
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: chybný druh instrukce %d"

#: make_cmd.c:651
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr "„here“ dokument na řádku %d ukončen koncem souboru (požadováno „%s“)"

#: make_cmd.c:746
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr "make_redirection: instrukce přesměrování „%d“ mimo rozsah"

#: parse.y:2986 parse.y:3218
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "neočekávaný konec souboru při hledání znaku odpovídajícímu „%c“"

#: parse.y:3722
msgid "unexpected EOF while looking for `]]'"
msgstr "neočekávaný konec souboru při hledání „]]“"

# XXX: Condional means condition (adj.) probably. Can English distinguish
# between the condition (podmínkový) and the code branch (podmíněný)? Check
# for all "conditional" string occurences.
#: parse.y:3727
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "chyba syntaxe ve výrazu podmínky: neočekávaný token „%s“"

#: parse.y:3731
msgid "syntax error in conditional expression"
msgstr "chyba syntaxe ve výrazu podmínky"

#: parse.y:3809
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "neočekávaný token „%s“, očekávána „)“"

#: parse.y:3813
msgid "expected `)'"
msgstr "očekávána „)“"

#: parse.y:3841
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "neočekávaný argument „%s“ u podmínkového unárního operátoru"

#: parse.y:3845
msgid "unexpected argument to conditional unary operator"
msgstr "neočekávaný argument u podmínkového unárního operátoru"

#: parse.y:3885
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "neočekávaný token „%s“, očekáván podmínkový binární operátor"

#: parse.y:3889
msgid "conditional binary operator expected"
msgstr "očekáván podmínkový binární operátor"

#: parse.y:3906
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "neočekávaný argument „%s„ u podmínkového binárního operátoru"

#: parse.y:3910
msgid "unexpected argument to conditional binary operator"
msgstr "neočekávaný argument u podmínkového binárního operátoru"

#: parse.y:3921
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "neočekávaný token „%c“ v podmínkovém příkazu"

#: parse.y:3924
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "neočekávaný token „%s“ v podmínkovém příkazu"

#: parse.y:3928
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "neočekávaný token %d v podmínkovém příkazu"

#: parse.y:5195
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "chyba syntaxe poblíž neočekávaného tokenu „%s“"

#: parse.y:5213
#, c-format
msgid "syntax error near `%s'"
msgstr "chyba syntaxe poblíž „%s“"

#: parse.y:5223
msgid "syntax error: unexpected end of file"
msgstr "chyba syntaxe: nenadálý konec souboru"

#: parse.y:5223
msgid "syntax error"
msgstr "chyba syntaxe"

#: parse.y:5285
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Shell lze ukončit příkazem „%s“.\n"

#: parse.y:5447
msgid "unexpected EOF while looking for matching `)'"
msgstr "nenadálý konec souboru při hledání odpovídající „)“"

#: pcomplete.c:1018
#, c-format
msgid "completion: function `%s' not found"
msgstr "doplňování: funkce „%s“ nenalezena"

#: pcomplib.c:179
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: NULLOVÝ COMPSPEC"

#: print_cmd.c:285
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: chybná propojka „%d“"

#: print_cmd.c:1348
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: „%c“: chybný formátovací znak"

#: redir.c:105
msgid "file descriptor out of range"
msgstr "deskriptor souboru mimo rozsah"

#: redir.c:148
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: nejednoznačné přesměrování"

#: redir.c:152
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: existující soubor nelze přepsat"

#: redir.c:157
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: omezeno: výstup nelze přesměrovat"

#: redir.c:162
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr "pro „here“ dokument nelze vytvořit dočasný soubor: %s"

#: redir.c:517
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "/dev/(tcp|udp)/host/port není bez síťování podporováno"

#: redir.c:1023
msgid "redirection error: cannot duplicate fd"
msgstr "chyba přesměrování: deskriptor souboru nelze duplikovat"

#: shell.c:328
msgid "could not find /tmp, please create!"
msgstr "nelze nalézt /tmp, vytvořte jej, prosím!"

#: shell.c:332
msgid "/tmp must be a valid directory name"
msgstr "/tmp musí být platným názvem pro adresář"

#: shell.c:876
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: chybný přepínač"

#: shell.c:1638
msgid "I have no name!"
msgstr "Nemám žádné jméno!"

#: shell.c:1778
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, verze %s-(%s)\n"

#: shell.c:1779
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Použití:\t%s [Dlouhý GNU přepínač] [přepínač]…\n"
"\t%s [Dlouhý GNU přepínač] [přepínač] skriptový_soubor…\n"

#: shell.c:1781
msgid "GNU long options:\n"
msgstr "Dlouhé GNU přepínače:\n"

#: shell.c:1785
msgid "Shell options:\n"
msgstr "Přepínače shellu:\n"

#: shell.c:1786
msgid "\t-irsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-irsD nebo -c příkaz nebo -O shopt_přepínač\t(pouze při vyvolání)\n"

#: shell.c:1801
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s nebo -o přepínač\n"

#: shell.c:1807
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr ""
"Podrobnosti o přepínačích shellu získáte tím, že napíšete „%s -c \"help set"
"\"“.\n"

#: shell.c:1808
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr ""
"Podrobnosti o příkazech vestavěných do shellu získáte tím, že\n"
"napište „%s -c help“.\n"

#: shell.c:1809
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Chyby nahlásíte příkazem „bashbug“.\n"

#: sig.c:583
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: neplatná operace"

#: siglist.c:47
msgid "Bogus signal"
msgstr "Falešný signál"

# Překlady názvů signálů převzaty (s mírnými úpravami) z české překladu
# manuálové stránky signal(7). 
#: siglist.c:50
msgid "Hangup"
msgstr "Linka terminálu zavěšena"

# FIXME: rod a následující
#: siglist.c:54
#, fuzzy
msgid "Interrupt"
msgstr "Přerušení"

#: siglist.c:58
msgid "Quit"
msgstr "Ukončení"

#: siglist.c:62
msgid "Illegal instruction"
msgstr "Neplatní instrukce"

#: siglist.c:66
msgid "BPT trace/trap"
msgstr "Přerušení při ladění"

#: siglist.c:74
msgid "ABORT instruction"
msgstr "Ukončení funkcí abort()"

#: siglist.c:78
msgid "EMT instruction"
msgstr "Instrukce EMT"

#: siglist.c:82
msgid "Floating point exception"
msgstr "Výjimka při práci s pohyblivou řádovou čárkou"

#: siglist.c:86
msgid "Killed"
msgstr "Zabit"

#: siglist.c:90
msgid "Bus error"
msgstr "Chyba sběrnice"

#: siglist.c:94
msgid "Segmentation fault"
msgstr "Chyba segmentace"

#: siglist.c:98
msgid "Bad system call"
msgstr "Špatné volání systému"

#: siglist.c:102
msgid "Broken pipe"
msgstr "Z roury nikdo nečte"

#: siglist.c:106
msgid "Alarm clock"
msgstr "Signál časovače"

#: siglist.c:110
msgid "Terminated"
msgstr "Ukončit"

#: siglist.c:114
msgid "Urgent IO condition"
msgstr "Čekají urgentní I/O data"

#: siglist.c:118
msgid "Stopped (signal)"
msgstr "Pozastaveno (signálem)"

#: siglist.c:126
msgid "Continue"
msgstr "Pokračovat"

#: siglist.c:134
msgid "Child death or stop"
msgstr "Potomek byl pozastaven nebo zemřel"

#: siglist.c:138
msgid "Stopped (tty input)"
msgstr "Pozastaveno (vstupem TTY)"

#: siglist.c:142
msgid "Stopped (tty output)"
msgstr "Pozastaveno (výstupem na TTY)"

#: siglist.c:146
msgid "I/O ready"
msgstr "I/O je připraveno"

#: siglist.c:150
msgid "CPU limit"
msgstr "Dosažen limit procesorového času"

#: siglist.c:154
msgid "File limit"
msgstr "Dosažen limit velikosti souboru"

#: siglist.c:158
msgid "Alarm (virtual)"
msgstr "Časovač (virtuální)"

#: siglist.c:162
msgid "Alarm (profile)"
msgstr "Časovač (profilovací)"

#: siglist.c:166
msgid "Window changed"
msgstr "Změna okna"

# FIXME: WTF?
# „Zámek záznamu“ nebo „Zaznamenej zámek“
#: siglist.c:170
#, fuzzy
msgid "Record lock"
msgstr "Zámek záznamu"

#: siglist.c:174
msgid "User signal 1"
msgstr "Uživatelský signal 1"

#: siglist.c:178
msgid "User signal 2"
msgstr "Uživatelský signál 2"

# FIXME: HFT znamená High Frequency Timer? Zkontrolovat i další výskyty
#: siglist.c:182
msgid "HFT input data pending"
msgstr "vstupní data HFT čekají"

#: siglist.c:186
msgid "power failure imminent"
msgstr "hrozí selhání napájení"

#: siglist.c:190
msgid "system crash imminent"
msgstr "hrozí selhání systému"

#: siglist.c:194
msgid "migrate process to another CPU"
msgstr "přesunout proces na jiný procesor"

#: siglist.c:198
msgid "programming error"
msgstr "chyba programování"

#: siglist.c:202
msgid "HFT monitor mode granted"
msgstr "Režim HFT sledování přidělen"

#: siglist.c:206
msgid "HFT monitor mode retracted"
msgstr "Režim HFT sledování odebrán"

#: siglist.c:210
msgid "HFT sound sequence has completed"
msgstr "HFT zvuková posloupnost byla dokončena"

#: siglist.c:214
msgid "Information request"
msgstr "Požadavek o informaci"

#: siglist.c:222
msgid "Unknown Signal #"
msgstr "Neznámé číslo signálu"

#: siglist.c:224
#, c-format
msgid "Unknown Signal #%d"
msgstr "Neznámý signál č. %d"

#: subst.c:1181 subst.c:1302
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "chybná substituce: v %2$s chybí uzavírací „%1$s“"

#: subst.c:2458
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: seznam nelze přiřadit do prvku pole"

#: subst.c:4456 subst.c:4472
msgid "cannot make pipe for process substitution"
msgstr "nelze vyrobit rouru za účelem substituce procesu"

#: subst.c:4504
msgid "cannot make child for process substitution"
msgstr "nelze vytvořit potomka za účelem substituce procesu"

#: subst.c:4549
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "pojmenovanou rouru %s nelze otevřít pro čtení"

#: subst.c:4551
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "pojmenovanou rouru %s nelze otevřít pro zápis"

#: subst.c:4569
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "pojmenovanou rouru %s nelze zdvojit jako deskriptor %d"

#: subst.c:4765
msgid "cannot make pipe for command substitution"
msgstr "nelze vytvořit rouru pro substituci příkazu"

#: subst.c:4799
msgid "cannot make child for command substitution"
msgstr "nelze vytvořit potomka pro substituci příkazu"

#: subst.c:4816
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: rouru nelze zdvojit jako deskriptor 1"

#: subst.c:5318
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: parametr null nebo nenastaven"

#: subst.c:5608
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: výraz podřetězce < 0"

#: subst.c:6660
#, c-format
msgid "%s: bad substitution"
msgstr "%s: chybná substituce"

#: subst.c:6740
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: takto nelze přiřazovat"

#: subst.c:7499
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "chybná substituce: v %s chybí uzavírací „`“"

#: subst.c:8375
#, c-format
msgid "no match: %s"
msgstr "žádná shoda: %s"

#: test.c:145
msgid "argument expected"
msgstr "očekáván argument"

#: test.c:154
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: očekáván celočíselný výraz"

#: test.c:262
msgid "`)' expected"
msgstr "očekávána „)“"

#: test.c:264
#, c-format
msgid "`)' expected, found %s"
msgstr "očekávána „)“, nalezeno %s"

#: test.c:279 test.c:688 test.c:691
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: očekáván unární operátor"

#: test.c:444 test.c:731
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: očekáván binární operátor"

#: test.c:806
msgid "missing `]'"
msgstr "postrádám „]“"

#: trap.c:201
msgid "invalid signal number"
msgstr "neplatné číslo signálu"

#: trap.c:324
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: chybná hodnota v trap_list[%d]: %p"

#: trap.c:328
#, c-format
msgid ""
"run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr "run_pending_traps: obsluha signálu je SIG_DFL, přeposílám %d (%s) sobě"

#: trap.c:372
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: chybný signál %d"

#: variables.c:358
#, c-format
msgid "error importing function definition for `%s'"
msgstr "chyba při importu definice „%s“"

#: variables.c:736
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "úroveň shellu (%d) příliš vysoká, resetuji na 1"

#: variables.c:1898
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: žádný kontext funkce v aktuálním rozsahu"

#: variables.c:3127
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: žádný kontext funkce v aktuálním rozsahu"

#: variables.c:3344 variables.c:3353
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "neplatný znak %d v exportstr pro %s"

#: variables.c:3359
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "v exportstr pro %s chybí „=“"

#: variables.c:3794
msgid "pop_var_context: head of shell_variables not a function context"
msgstr "pop_var_context: hlava shell_variables není kontextem funkce"

#: variables.c:3807
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: chybí kontext global_variables"

#: variables.c:3881
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr "pop_scope: hlava shell_variables není dočasným rozsahem prostředí"

#: version.c:46
#, fuzzy
msgid "Copyright (C) 2009 Free Software Foundation, Inc."
msgstr "Copyright © 2008 Free Software Foundation, Inc."

#: version.c:47
msgid ""
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl."
"html>\n"
msgstr ""
"Licence GPLv3+: GNU GPL verze 3 nebo novější <http://gnu.org/licenses/gpl."
"html>\n"

#: version.c:86
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, verze %s (%s)\n"

#: version.c:91
#, c-format
msgid "This is free software; you are free to change and redistribute it.\n"
msgstr "Toto je svobodné programové vybavení: máte právo jej měnit a šířit.\n"

#: version.c:92
#, c-format
msgid "There is NO WARRANTY, to the extent permitted by law.\n"
msgstr "VEŠKERÉ ZÁRUKY chybí, jak jen zákon dovoluje.\n"

#: xmalloc.c:92
#, c-format
msgid "xmalloc: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "xmalloc: nelze alokovat %'lu bajtů (%'lu bajtů alokováno)"

#: xmalloc.c:94
#, c-format
msgid "xmalloc: cannot allocate %lu bytes"
msgstr "xmalloc: nezle alokovat %'lu bajtů"

#: xmalloc.c:114
#, c-format
msgid "xrealloc: cannot reallocate %lu bytes (%lu bytes allocated)"
msgstr "xrealloc: nelze přealokovat %'lu bajtů (%'lu bajtů alokováno)"

#: xmalloc.c:116
#, c-format
msgid "xrealloc: cannot allocate %lu bytes"
msgstr "xrealloc: nelze alokovat %'lu bajtů"

#: xmalloc.c:150
#, c-format
msgid "xmalloc: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "xmalloc: %s:%d: nelze alokovat %'lu bajtů (%'lu bajtů alokováno)"

#: xmalloc.c:152
#, c-format
msgid "xmalloc: %s:%d: cannot allocate %lu bytes"
msgstr "xmalloc: %s:%d: nelze alokovat %'lu bajtů"

#: xmalloc.c:174
#, c-format
msgid "xrealloc: %s:%d: cannot reallocate %lu bytes (%lu bytes allocated)"
msgstr "xrealloc: %s:%d: nelze přealokovat %'lu bajtů (%'lu bajtů alokováno)"

#: xmalloc.c:176
#, c-format
msgid "xrealloc: %s:%d: cannot allocate %lu bytes"
msgstr "xrealloc: %s:%d: nelze alokovat %'lu bajtů"

#: builtins.c:43
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [název[=hodnota] …]"

#: builtins.c:47
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] název [název…]"

#: builtins.c:51
msgid ""
"bind [-lpvsPVS] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-"
"x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr ""
"bind [-lpvsPVS] [-m klávmapa] [-f soubor] [-q název] [-u název] [-r "
"klávposl] [-x klávposl:příkaz-shellu] [klávposl:readline-funkce nebo "
"readline-příkaz]"

#: builtins.c:54
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:56
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:58
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [vestavěný-příkaz-shellu [argument…]]"

#: builtins.c:61
msgid "caller [expr]"
msgstr "caller [výraz]"

#: builtins.c:64
msgid "cd [-L|-P] [dir]"
msgstr "cd [-L|-P] [adr]"

#: builtins.c:66
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:68
msgid ":"
msgstr ":"

#: builtins.c:70
msgid "true"
msgstr "true"

#: builtins.c:72
msgid "false"
msgstr "false"

#: builtins.c:74
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] příkaz [argument…]"

#: builtins.c:76
msgid "declare [-aAfFilrtux] [-p] [name[=value] ...]"
msgstr "declare [-aAfFilrtux] [-p] [název[=hodnota]…]"

#: builtins.c:78
msgid "typeset [-aAfFilrtux] [-p] name[=value] ..."
msgstr "typeset [-aAfFilrtux] [-p] název[=hodnota]…"

#: builtins.c:80
msgid "local [option] name[=value] ..."
msgstr "local [přepínač] název[=hodnota]…"

#: builtins.c:83
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [argument…]"

#: builtins.c:87
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [argument…]"

#: builtins.c:90
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f soubor] [název…]"

#: builtins.c:92
msgid "eval [arg ...]"
msgstr "eval [argument…]"

#: builtins.c:94
msgid "getopts optstring name [arg]"
msgstr "getopts optstring name [argument]"

#: builtins.c:96
msgid "exec [-cl] [-a name] [command [arguments ...]] [redirection ...]"
msgstr "exec [-cl] [-a název] [příkaz [argument…]] [přesměrování…]"

#: builtins.c:98
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:100
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:103
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr ""
"fc [-e enázev] [-lnr] [první] [poslední] nebo fc -s [vzor=náhrada] [příkaz]"

#: builtins.c:107
msgid "fg [job_spec]"
msgstr "fg [úloha]"

#: builtins.c:111
msgid "bg [job_spec ...]"
msgstr "bg [úloha…]"

#: builtins.c:114
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p název_cesty] [-dt] [název…]"

#: builtins.c:117
msgid "help [-ds] [pattern ...]"
msgstr "help [-ds] [vzorek…]"

#: builtins.c:121
msgid ""
"history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg "
"[arg...]"
msgstr ""
"history [-c] [-d pozice] [n] nebo history -anrw [jméno_souboru] nebo history "
"-ps argument [argument…]"

#: builtins.c:125
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [úloha…] nebo jobs -x příkaz [argumenty]"

#: builtins.c:129
msgid "disown [-h] [-ar] [jobspec ...]"
msgstr "disown [-h] [-ar] [úloha…]"

#: builtins.c:132
msgid ""
"kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l "
"[sigspec]"
msgstr ""
"kill [-s sigspec | -n číssig | -sigspec] pid | úloha … nebo kill -l [sigspec]"

#: builtins.c:134
msgid "let arg [arg ...]"
msgstr "let argument [argument…]"

#: builtins.c:136
msgid ""
"read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-p prompt] [-t "
"timeout] [-u fd] [name ...]"
msgstr ""
"read [-ers] [-a pole] [-d oddělovač] [-i text] [-n p_znaků] [-p výzva] [-t "
"limit] [-u fd] [jméno…]"

#: builtins.c:138
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:140
msgid "set [--abefhkmnptuvxBCHP] [-o option-name] [arg ...]"
msgstr "set [--abefhkmnptuvxBCHP] [-o název_přepínače] [argument…]"

#: builtins.c:142
msgid "unset [-f] [-v] [name ...]"
msgstr "unset [-f] [-v] [jméno…]"

#: builtins.c:144
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [název[=hodnota] …] nebo export -p"

#: builtins.c:146
msgid "readonly [-af] [name[=value] ...] or readonly -p"
msgstr "readonly [-af] [název[=hodnota] …] nebo readonly -p"

#: builtins.c:148
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:150
msgid "source filename [arguments]"
msgstr "source název_souboru [argumenty]"

#: builtins.c:152
msgid ". filename [arguments]"
msgstr ". název_souboru [argumenty]"

#: builtins.c:155
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:158
msgid "test [expr]"
msgstr "test [výraz]"

#: builtins.c:160
msgid "[ arg... ]"
msgstr "[ argument… ]"

#: builtins.c:162
msgid "times"
msgstr "times"

#: builtins.c:164
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[argument] signal_spec…]"

#: builtins.c:166
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] název [název…]"

#: builtins.c:169
msgid "ulimit [-SHacdefilmnpqrstuvx] [limit]"
msgstr "ulimit [-SHacdefilmnpqrstuvx] [limit]"

#: builtins.c:172
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [mód]"

#: builtins.c:175
msgid "wait [id]"
msgstr "wait [id]"

#: builtins.c:179
msgid "wait [pid]"
msgstr "wait [pid]"

#: builtins.c:182
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for NÁZEV [in SLOVECH…] ; do PŘÍKAZY; done"

#: builtins.c:184
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( výr1; výr2; výr3 )); do PŘÍKAZY; done"

#: builtins.c:186
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select NÁZEV [in SLOVA…;] do PŘÍKAZY; done"

#: builtins.c:188
msgid "time [-p] pipeline"
msgstr "time [-p] kolona"

#: builtins.c:190
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case SLOVO in [VZOR [| VZOR]…) PŘÍKAZY ;;]… esac"

#: builtins.c:192
msgid ""
"if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else "
"COMMANDS; ] fi"
msgstr ""
"if PŘÍKAZY; then PŘÍKAZY; [ elif PŘÍKAZY; then PŘÍKAZY; ]… [ else PŘÍKAZY; ] "
"fi"

#: builtins.c:194
msgid "while COMMANDS; do COMMANDS; done"
msgstr "while PŘÍKAZY; do PŘÍKAZY; done"

#: builtins.c:196
msgid "until COMMANDS; do COMMANDS; done"
msgstr "until PŘÍKAZY; do PŘÍKAZY; done"

#: builtins.c:198
msgid "coproc [NAME] command [redirections]"
msgstr ""

#: builtins.c:200
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function jméno { PŘÍKAZY ; } nebo jméno () { PŘÍKAZY ; }"

#: builtins.c:202
msgid "{ COMMANDS ; }"
msgstr "{ PŘÍKAZY ; }"

#: builtins.c:204
msgid "job_spec [&]"
msgstr "úloha [&]"

#: builtins.c:206
msgid "(( expression ))"
msgstr "(( výraz ))"

#: builtins.c:208
msgid "[[ expression ]]"
msgstr "[[ výraz ]]"

# XXX: "variable" je literál na seznamy vestavěných příkazů
#: builtins.c:210
msgid "variables - Names and meanings of some shell variables"
msgstr "variables – názvy a významy některých proměnných shellu"

#: builtins.c:213
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | adresář]"

#: builtins.c:217
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:221
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:224
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [název_volby…]"

#: builtins.c:226
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v proměnná] formát [argumenty]"

#: builtins.c:229
msgid ""
"complete [-abcdefgjksuv] [-pr] [-o option] [-A action] [-G globpat] [-W "
"wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] "
"[name ...]"
msgstr ""
"complete [-abcdefgjksuv] [-pr] [-o přepínač] [-A akce] [-G globvzor] [-W "
"seznam_slov]  [-F funkce] [-C příkaz] [-X filtrvzor] [-P předpona] [-S "
"přípona] [název…]"

#: builtins.c:233
msgid ""
"compgen [-abcdefgjksuv] [-o option]  [-A action] [-G globpat] [-W wordlist]  "
"[-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr ""
"compgen [-abcdefgjksuv] [-o přepínač]  [-A akce] [-G globvzor] [-W "
"seznam_slov]  [-F funkce] [-C příkaz] [-X filtrvzor] [-P předpona] [-S "
"přípona] [slovo]"

#: builtins.c:237
msgid "compopt [-o|+o option] [name ...]"
msgstr "compopt [-o|+o přepínač] [název…]"

#: builtins.c:240
msgid ""
"mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c "
"quantum] [array]"
msgstr ""
"mapfile [-n počet] [-O počátek] [-s počet] [-t] [-u fd] [-C volání] [-c "
"množství] [pole]"

#: builtins.c:242
#, fuzzy
msgid ""
"readarray [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c "
"quantum] [array]"
msgstr ""
"mapfile [-n počet] [-O počátek] [-s počet] [-t] [-u fd] [-C volání] [-c "
"množství] [pole]"

#: builtins.c:254
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tPrint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has "
"been\n"
"    defined."
msgstr ""
"Definuje nebo zobrazí aliasy.\n"
"    \n"
"    „alias“ bez argumentů vypíše na standardní výstup seznam aliasů ve "
"znovu\n"
"    použitelném formátu NÁZEV=HODNOTA.\n"
"    \n"
"    Jinak bude definován alias pro každý NÁZEV, který má zadanou HODNOTU.\n"
"    Závěrečná mezera v HODNOTĚ způsobí, že při expanzi bude následující "
"slovo\n"
"    zkontrolováno na substituci aliasů.\n"
"    \n"
"    Přepínače:\n"
"      -p\tVypíše všechny definované aliasy ve znovu použitelném formátu\n"
"    \n"
"    Návratový kód:\n"
"    alias vrátí pravdu, pokud nebyl zadán NÁZEV, pro který není žádný alias\n"
"    definován."

#: builtins.c:276
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions.\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Odstraní každý NÁZEV ze seznamů definovaných aliasů.\n"
"    \n"
"    Přepínače:\n"
"      -a\todstraní všechny definice aliasů.    \n"
"    Vrací úspěch, pokud NÁZEV není neexistující alias."

#: builtins.c:289
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their "
"values\n"
"      -s                 List key sequences that invoke macros and their "
"values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named "
"function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Nastaví klávesové zkratky a proměnné Readline.\n"
"    \n"
"    Naváže posloupnost kláves na Readline funkci nebo makro nebo nastaví\n"
"    Readline proměnnou. Syntaxe nepřepínačových argumentů je shodná se\n"
"    syntaxí ~/.inputrc, ale musí být zadána jako jediný argument:\n"
"    např. bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Přepínače:\n"
"      -m  klávmapa       Použije KLÁVMAPU jako klávesovou mapu pro trvání\n"
"                         tohoto příkazu. Možné klávesové mapy jsou emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command a vi-insert.\n"
"      -l                 Vypíše seznam názvů funkcí.\n"
"      -P                 Vypíše seznam názvů funkcí a klávesových vazeb.\n"
"      -p                 Vypíše seznam funkcí a klávesových vazeb ve "
"formátu,\n"
"                         který lze použít jako vstup.\n"
"      -S                 Vypíše seznam posloupností kláves,\n"
"                         které vyvolávají makra, a jejich hodnoty.\n"
"      -s                 Vypíše seznam posloupností kláves,\n"
"                         která vyvolávají makra, a jejich hodnoty ve "
"formátu,\n"
"                         který lze použít jako vstup.      -"
"V                 Vypíše seznam názvů proměnných a hodnot.\n"
"      -v                 Vypíše seznam názvů proměnných a hodnot ve "
"formátu,\n"
"                         který lze použít jako vstup.\n"
"      -q  název-funkce   Dotáže se, které klávesy vyvolají zadanou funkci.\n"
"      -u  název-funkce   Zruší všechny vazby na klávesy, které jsou "
"napojeny\n"
"                         na zadanou funkci.\n"
"      -r  klávposl       Odstraní vazbu na KLÁVPOSL.\n"
"      -f  soubor         Načte vazby kláves ze SOUBORU.\n"
"      -x  klávposl:příkaz-shellu\n"
"                         Způsobí, že bude vykonán PŘÍKAZ-SHELLU, když bude\n"
"                         zadána KLÁVPOSL.\n"
"    \n"
"    Návratový kód:\n"
"    bind vrací 0, pokud není zadán nerozpoznaný přepínač nebo nedojde "
"k chybě."

#: builtins.c:326
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Ukončí smyčku for, whle nebo until.\n"
"    \n"
"    Ukončí smyčku FOR, WHILE nebo UNTIL. Je-li zadáno N, ukončí N\n"
"    obklopujících smyček.\n"
"    \n"
"    Návratový kód:\n"
"    Návratový kód je 0, pokud N je větší nebo rovno 1."

#: builtins.c:338
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Obnoví smyčku for, while nebo until.\n"
"    \n"
"    Přejde k další iteraci obklopující smyčky FOR, WHILE nebo UNTIL.\n"
"    Je-li zadáno N, bude tak učiněno v N. obklopující smyčce.    \n"
"    Návratový kód:\n"
"    Návratový kód je 0, pokud N je větší nebo rovno 1."

#: builtins.c:350
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the "
"function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin.."
msgstr ""
"Provede vestavěný příkaz shellu.\n"
"    \n"
"    Provede VESTAVĚNÝ-PŘÍKAZ-SHELLU s argumenty ARGUMENTY, aniž by se "
"uplatnilo\n"
"    vyhledávání příkazu. Toto se hodí, když si přejete reimplementovat\n"
"    vestavěný příkaz shellu jako funkci shellu, avšak potřebujete spustit\n"
"    vestavěný příkaz uvnitř této funkce.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací návratový kód VESTAVĚNÉHO-PŘÍKAZU-SHELLU, nebo nepravdu, pokud\n"
"    VESTAVĚNÝ-PŘÍKAZ-SHELLU není vestavěným příkazem shellu."

#: builtins.c:365
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Vrátí kontext aktuálního podprogramu.\n"
"    \n"
"    Bez VÝRAZU vrátí „$řádek $název_souboru“. S VÝRAZEM vrátí\n"
"    „$řádek $podprogram $název_souboru“; tuto zvláštní informaci lze\n"
"    využít pro výpis zásobníku volání.\n"
"    \n"
"    Hodnota VÝRAZU určuje, kolik rámců volání se má zpětně projít od toho\n"
"    současného; vrcholový rámec má číslo 0.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací 0, pokud shell provádí shellovou funkci a VÝRAZ je platný."

#: builtins.c:383
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of "
"the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory "
"containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon "
"(:).\n"
"    A null directory name is the same as the current directory.  If DIR "
"begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is "
"set,\n"
"    the word is assumed to be  a variable name.  If that variable has a "
"value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"        -L\tforce symbolic links to be followed\n"
"        -P\tuse the physical directory structure without following symbolic\n"
"    \tlinks\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed; non-zero otherwise."
msgstr ""
"Změní pracovní adresář shellu.\n"
"    \n"
"    Změní aktuální adresář na ADR. Implicitní ADR je hodnota proměnné "
"shellu\n"
"    HOME.\n"
"    \n"
"    Proměnná CDPATH definuje vyhledávací cestu pro adresář obsahující ADR.\n"
"    Názvy náhradních adresářů v CDPATH se oddělují dvojtečkou (:). Prázdný\n"
"    název adresáře je stejný jako aktuální adresář. Začíná-li ADR na "
"lomítko\n"
"    (/), nebude CDPATH použita.\n"
"    \n"
"    Nebude-li adresář nalezen a přepínač shellu „cdable_vars“ bude "
"nastaven,\n"
"    pak se dané slovo zkusí jakožto název proměnné. Má-li taková proměnná\n"
"    hodnotu, pak její hodnota se použije jako ADR.\n"
"    \n"
"    Přepínače:\n"
"        -L\tvynutí následování symbolických odkazů\n"
"        -P\tnařizuje použít fyzickou adresářovou strukturu namísto\n"
"    \tnásledování symbolických odkazů\n"
"    \n"
"    Symbolické odkazy se implicitně následují, jako by bylo zadáno „-L“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací 0, byl-li adresář změněn, jinak nenulovou hodnotu."

#: builtins.c:411
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Vypíše název současného pracovního adresáře.\n"
"    \n"
"    Přepínače:\n"
"      -L\tvypíše hodnotu $PWD, pokud pojmenovává současný pracovní\n"
"    \tadresář\n"
"      -P\tvypíše fyzický adresář prostý všech symbolických odkazů\n"
"    \n"
"    Implicitně se „pwd“ chová, jako by bylo zadáno „-L“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací 0, nebyl-li zadán neplatný přepínač a mohl-li být současný\n"
"    adresář přečten."

#: builtins.c:428
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Prázdný příkaz.\n"
"    \n"
"    Žádný účinek, tento příkaz nic nedělá.\n"
"    \n"
"    Návratový kód:\n"
"    Vždy uspěje."

#: builtins.c:439
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Vrátí výsledek úspěchu.\n"
"    \n"
"    Návratový kód:\n"
"    Vždy uspěje."

#: builtins.c:448
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Vrátí výsledek neúspěchu.\n"
"    \n"
"    Návratový kód:\n"
"    Vždy selže."

#: builtins.c:457
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke "
"commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p\tuse a default value for PATH that is guaranteed to find all of\n"
"    \tthe standard utilities\n"
"      -v\tprint a description of COMMAND similar to the `type' builtin\n"
"      -V\tprint a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Provede jednoduchý příkaz nebo zobrazí podrobnosti o příkazech.\n"
"    \n"
"    Spustí PŘÍKAZ s ARGUMENTY ignoruje funkce shellu, nebo zobrazí "
"informace\n"
"    o zadaných PŘÍKAZECH. Lze využít, když je třeba vyvolat příkazy "
"z disku,\n"
"    přičemž existuje funkce stejného jména.\n"
"    \n"
"    Přepínače:\n"
"      -p\tpro PATH bude použita implicitní hodnota, která zaručuje,\n"
"    \tže budou nalezeny všechny standardní nástroje\n"
"      -v\tzobrazí popis PŘÍKAZU podobný vestavěnému příkazu „type“\n"
"      -V\tzobrazí podrobnější popis každého PŘÍKAZU\n"
"    \n"
"    Návratový kód:\n"
"    Vrací návratový kód PŘÍKAZU, nebo selže, nebyl–li příkaz nalezen."

#: builtins.c:476
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \tsource file when debugging)\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert NAMEs to lower case on assignment\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert NAMEs to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the "
"`local'\n"
"    command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Nastaví hodnoty a atributy proměnných.\n"
"    \n"
"    Deklaruje proměnné a nastaví jim atributy. Nejsou-li zadány NÁZVY,\n"
"    zobrazí atributy a hodnoty všech proměnných.\n"
"    \n"
"    Přepínače:\n"
"      -f\tomezí akce nebo výpis na názvy funkcí a deklarace\n"
"      -F\tomezí výpis jen na názvy funkcí (a číslo řádku a název\n"
"    \tzdrojového souboru, je-li zapnuto ladění)\n"
"      -p zobrazí atributy a hodnotu každého NÁZVU\n"
"    \n"
"    Přepínače, které nastavují atributy:\n"
"      -a\tučiní NÁZVY číslovanými poli (je-li podporováno)\n"
"      -A\tučiní NÁZVY asociativními poli (je-li podporováno)\n"
"      -i\tpřiřadí NÁZVŮM atribut „integer“ (číslo)\n"
"      -l\tpřevede NÁZVY na malá písmena v době přiřazení\n"
"      -r\tučiní NÁZVY jen pro čtení\n"
"      -t\tpřiřadí NÁZVŮM atribut „trace“ (sledování)\n"
"      -u\tpřevede NÁZVY na velká písmena v době přiřazení\n"
"      -x\tvyexportuje NÁZVY\n"
"    \n"
"    Pomocí „+“ namísto „-“ daný atribut vypnete.\n"
"    \n"
"    Proměnné s atributem integer jsou aritmeticky vyhodnoceny (vizte příkaz\n"
"    „let“), jakmile je do proměnné přiřazeno.\n"
"    \n"
"    Je-li použito uvnitř funkce, učiní „declare“ NÁZVY lokálními stejně "
"jako\n"
"    příkaz „local“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací úspěch, pokud nebyl zadán neplatný přepínač a nedošlo k chybě."

#: builtins.c:512
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Obsolete.  See `help declare'."
msgstr ""
"Nastaví hodnoty a atributy proměnných\n"
"    \n"
"    Příkaz je zastaralý. Vizte „help declare“."

#: builtins.c:520
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, an error occurs,\n"
"    or the shell is not executing a function."
msgstr ""
"Definuje lokální proměnné.\n"
"    \n"
"    Vytvoří lokální proměnnou pojmenovanou NÁZEV a přiřadí jí HODNOTU. "
"PŘEPÍNAČ\n"
"    smí může být jakýkoliv přepínač přípustný u „declare“\n"
"    \n"
"    Lokální proměnné lze použít jen uvnitř funkcí, budou viditelné jen "
"v dané\n"
"    funkci a jejich potomcích.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací úspěch, nebyl-li zadán neplatný přepínač, nenastala-li chyba a\n"
"    vykonává-li shell funkci."

#: builtins.c:537
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \tcan be one or two hex digits\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Vypíše své argumenty na standardní výstup.\n"
"    \n"
"    Zobrazí své ARGUMENTY na standardním výstupu a ukončí je z novým "
"řádkem.\n"
"    \n"
"    Přepínače:\n"
"      -n\tnepřipojuje nový řádek\n"
"      -e\tzapne interpretování následujících znaků uvozených zpětným "
"lomítkem\n"
"      -E\texplicitně potlačí interpretování znaků uvozených zpětným "
"lomítkem\n"
"    \n"
"    „echo“ interpretuje následující znaky uvozené zpětným lomítkem:\n"
"      \\a\tpoplach (zvonek)\n"
"      \\b\tbackspace\n"
"      \\c\tpotlačí další výstup\n"
"      \\E\tznak escapu\n"
"      \\f\tposun formuláře (form feed)\n"
"      \\n\tnový řádek\n"
"      \\r\tnávrat vozíku\n"
"      \\t\tvodorovný tabulátor\n"
"      \\v\tsvislý tabulátor\n"
"      \\\\\tzpětné lomítko\n"
"      \\0nnn\tznak, jehož ASCII kód je NNN (osmičkově). NNN smí být\n"
"    \t0 až 3 osmičkové číslice\n"
"      \\xHH\tosmibitový znak, jehož hodnota je HH (šestnáctkově). HH smí\n"
"    \tbýt jedna nebo dvě šestnáctkové číslice\n"
"    \n"
"    Návratový kód:\n"
"    Vrací úspěch, nedojde-li k chybě zápisu na výstup."

#: builtins.c:571
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Vypíše argumenty na standardní výstup.\n"
"    \n"
"    Na standardním výstupu zobrazí ARGUMENTY následované odřádkováním.\n"
"    \n"
"    Přepínače:\n"
"      -n\tneodřádkovává\n"
"    \n"
"    Vrací úspěch, nedojte-li k chybě zápisu na výstup."

#: builtins.c:586
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Povoluje a zakazuje vestavěné příkazy shellu.\n"
"    \n"
"    Povoluje a zakazuje vestavěné příkazy shellu. Zakázání vám umožní\n"
"    spustit program z disku, který má stejné jméno jako vestavěný příkaz\n"
"    shellu, aniž byste museli zadávat celou cestu.\n"
"    \n"
"    Přepínače:\n"
"      -a\tvypíše seznam vestavěných příkazů a vyznačí, který je a který "
"není\n"
"    \tpovolen\n"
"      -n\tzakáže každý NÁZEV nebo zobrazí seznam zakázaných vestavěných\n"
"    \tpříkazů\n"
"      -p\tvypíše seznam vestavěných příkazů ve znovu použitelné podobě\n"
"      -s\tvypíše pouze názvy posixových „speciálních“ vestavěných příkazů\n"
"    \n"
"    Přepínače řídící dynamické nahrávání:\n"
"      -f\tZavede vestavěný příkaz NÁZEV ze sdíleného objektu NÁZEV_SOUBORU\n"
"      -d\tOdstraní vestavění příkaz zavedený pomocí –f\n"
"    \n"
"    Bez přepínačů povolí všechny NÁZVY.\n"
"    \n"
"    Abyste používali „test“ z $PATH namísto verze vestavěné do shellu,\n"
"    napište „enable -n test“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací úspěch, je-li NÁZEV vestavěným příkazem shellu a nevyskytne-li\n"
"    se chyba."

#: builtins.c:614
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the "
"shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Spustí argumenty jako příkaz shellu.\n"
"    \n"
"    ARGUMENTY sloučí do jediného řetězce, použije jej jako vstup shellu\n"
"    a vykoná výsledné příkazy.\n"
"    Návratový kód:\n"
"    Vrátí návratový kód příkazu, nebo úspěch, byl-li příkaz prázdný."

#: builtins.c:626
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters ($0 - $9), but if\n"
"    more arguments are given, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Rozebere přepínačové argumenty.\n"
"    \n"
"    Getopts se používá v shellových procedurách na rozebrání pozičních\n"
"    parametrů jakožto přepínačů.\n"
"    \n"
"    OPTSTRING obsahuje písmena přepínačů, které mají být rozeznány, Je-li\n"
"    písmeno následováno dvojtečkou, po přepínači se očekává argument, který\n"
"    by měl být od přepínače oddělen bílým místem.\n"
"    \n"
"    Pokaždé když je getopts zavolán, je následující přepínač umístěn do\n"
"    proměnné $name (proměnná je inicializována, neexistuje-li) a pořadí\n"
"    dalšího argumentu, který čeká na zpracování, do proměnné shellu OPTIND.\n"
"    OPTIND je inicializována na 1 vždy, když je zavolán shell nebo shellový\n"
"    skript. Pokud přepínač vyžaduje argument, getopts umístí tento argument\n"
"    do proměnné shellu OPTARG.\n"
"    \n"
"    getopts hlásí chyby jedním ze dvou způsobů. Pokud prvním znakem "
"OPTSTRING\n"
"    je dvojtečka, getopts hlásí chyby tichým způsobem. V tomto režimu žádné\n"
"    chybové zprávy nejsou vypisovány. Když se narazí na neplatný přepínač,\n"
"    getopts umístí tento znak do OPTARG. Pokud není nalezen povinný "
"argument,\n"
"    getopts umístí „:“ do NAME a OPTARG nastaví na znak nalezeného "
"přepínače.\n"
"    Pokud getopts nepracuje v tomto tichém režimu a je nalezen neplatný\n"
"    přepínač, getopts umístí „?“ do NAME a zruší OPTARG. Když nenajde "
"povinný\n"
"    argument, je do NAME zapsán „?“, OPTARG zrušen a vytištěna diagnostická\n"
"    zpráva.\n"
"    \n"
"    Pokud proměnná shellu OPTERR má hodnotu 0, getopts vypne vypisování\n"
"    chybových zpráv, dokonce i když první znak OPTSTRING není dvojtečka.\n"
"    Implicitní hodnota OPTERR je 1.\n"
"    \n"
"    Normálně getopts zpracovává poziční parametry ($0–$9), avšak následuje-"
"li\n"
"    getopts více argumentů, budou rozebrány tyto namísto pozičních.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, byl-li nalezen nějaký přepínač. Neúspěch vrátí, když "
"dojde\n"
"    na konec přepínačů nebo nastane-li chyba."

#: builtins.c:668
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not "
"specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\t\texecute COMMAND with an empty environment\n"
"      -l\t\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, "
"unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error "
"occurs."
msgstr ""
"Nahradí shell zadaným příkazem.\n"
"    \n"
"    Vykoná PŘÍKAZ, přičemž nahradí tento shell zadaným programem.  "
"ARGUMENTY\n"
"    se stanou argumenty PŘÍKAZU. Není-li PŘÍKAZ zadán, přesměrování "
"zapůsobí\n"
"    v tomto shellu.\n"
"    \n"
"    Přepínače:\n"
"      -a název\tpředá název jakožto nultý argument PŘÍKAZU\n"
"      -c\t\tspustí PŘÍKAZ s prázdným prostředím\n"
"      -t\t\tdo nultého argumentu PŘÍKAZU umístí pomlčku\n"
"    \n"
"    Pokud příkaz nemůže být proveden, neinteraktivní shell bude ukončen,\n"
"    pokud přepínač shellu „execfail“ není nastaven.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud byl PŘÍKAZ nalezen a nedošlo k chybě přesměrování."

#: builtins.c:689
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Ukončí shell.\n"
"    \n"
"    Ukončí tento shell se stavem N. Bez N bude návratový kód roven kódu\n"
"    posledně prováděného příkazu."

#: builtins.c:698
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not "
"executed\n"
"    in a login shell."
msgstr ""
"Ukončí přihlašovací shell.\n"
"    \n"
"    Ukončí přihlašovací (login) shell se stavem N. Nebyl-li příkaz zavolán\n"
"    z přihlašovacího shellu, vrátí chybu."

#: builtins.c:708
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history "
"list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then "
"EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error "
"occurs."
msgstr ""
"Zobrazí nebo vykoná příkazy ze seznamu historie.\n"
"    \n"
"    fc se používá na vypsání, úpravu a znovu provedení příkazů ze seznamu\n"
"    historie. PRVNÍ a POSLEDNÍ mohou být čísla určující rozsah nebo PRVNÍ "
"může být\n"
"    řetězec, což určuje nejnovější příkaz začínající na zadaný řetězec.\n"
"    \n"
"    Přepínače:\n"
"       -e ENÁZEV\tvybere editor. Implicitní je FCEDIT, pak EDITOR, pak vi.\n"
"       -l\tvypisuje řádky namísto jejich upravování\n"
"       -n\tvypne číslování řádků při jejich vypisování\n"
"       -r\tobrátí pořadí řádků (nejnovější budou první)\n"
"    \n"
"    Forma příkazu „fc -s [vzor=náhrada… [příkaz]“ znamená, že PŘÍKAZ bude\n"
"    po nahrazení STARÝ=NOVÝ znovu vykonán.\n"
"    \n"
"    Užitečný alias je r='fc -s', takže napsání „r cc“ spustí poslední "
"příkaz\n"
"    začínající na „cc“ a zadání „r“ znovu spustí poslední příkaz.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch nebo kód provedeného příkazu. Nenulový kód, vyskytne-li se\n"
"    chyba."

#: builtins.c:738
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Přepne úlohu na popředí.\n"
"    \n"
"    Přesune úlohu určenou pomocí ÚLOHA na popředí a učiní ji aktuální "
"úlohou.\n"
"    Není-li ÚLOHA zadána, použije se úloha, o které si shell myslí, že je\n"
"    aktuální.\n"
"    \n"
"    Návratový kód:\n"
"    Kód úlohy přesunuté do popředí, nebo došlo-li k chybě, kód selhání."

#: builtins.c:753
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if "
"they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's "
"notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Přesune úlohy do pozadí.\n"
"    \n"
"    Přepne každou úlohu určenou pomocí ÚLOHA na pozadí, jako by byla\n"
"    spuštěna s „&“. Ne-li ÚLOHA uvedena, použije se úloha, o které si shell\n"
"    myslí, že je aktuální.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud je správa úloh zapnuta a nedošlo-li k nějaké chybě."

#: builtins.c:767
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is "
"displayed.\n"
"    \n"
"    Options:\n"
"      -d\t\tforget the remembered location of each NAME\n"
"      -l\t\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME is the full pathname of NAME\n"
"      -r\t\tforget all remembered locations\n"
"      -t\t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\t\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Zapamatuje si nebo zobrazí umístění programu.\n"
"    \n"
"    Pro každý NÁZEV je určena plná cesta k příkazu a je zapamatována. Nejsou-"
"li\n"
"    zadány žádné argumenty, budou vypsány informace o zapamatovaných "
"příkazech.\n"
"    \n"
"    Přepínače:\n"
"      -d\t\tzapomene zapamatovaná umístění každého NÁZVU\n"
"      -l\t\tvypíše v takové podobě, kterou lze opět použít jako vstup\n"
"      -p cesta\tpoužije NÁZEV_CESTY jako plnou cestu k NÁZVU\n"
"      -r\t\tzapomene všechna zapamatovaná umístění\n"
"      -t\t\tvypíše zapamatované umístění každého NÁZVU a každému umístění\n"
"      \t\tpředepíše odpovídající NÁZEV, bylo zadáno více NÁZVŮ\n"
"    Argumenty:\n"
"      NÁZEV\t\tKaždý NÁZEV je vyhledán v $PATH a přidán do seznamu\n"
"    \t\tzapamatovaných příkazů.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud byl NÁZEV nalezen a nebyl-li zadán neplatný přepínač."

#: builtins.c:792
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifiying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is "
"given."
msgstr ""
"Zobrazí podrobnosti o vestavěných příkazech.\n"
"    \n"
"    Zobrazí stručný souhrn vestavěných příkazů. Je-li zadán VZOREK,\n"
"    vrátí podrobnou nápovědu ke všem příkazům odpovídajícím VZORKU, jinak "
"je\n"
"    vytištěn seznam syntaxe vestavěných příkazů.\n"
"    \n"
"    Přepínače:\n"
"      -d\tvypíše krátké pojednání na každé téma\n"
"      -m\tzobrazí použití v jakoby manuálovém formátu\n"
"      -s\tvypíše pouze krátký popis použití o každém příkazu odpovídajícímu\n"
"    \tVZORKU\n"
"    \n"
"    Argumenty:\n"
"      VZOREK\tVzorek určující téma nápovědy\n"
"    \n"
"    Návratový kód:\n"
"    Vrací úspěch, pokud byl nalezen VZOREK a nebyl zadán neplatný přepínač."

# FIXME: bash-4.0-pre1: Orphaned line between -w and -p option. It belongs to -n.
#: builtins.c:816
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at offset OFFSET.\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"      -r\tread the history file and append the contents to the history\n"
"    \tlist\n"
"      -w\twrite the current history to the history file\n"
"    \tand append them to the history list\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if $HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the $HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed "
"otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Zobrazí nebo upraví seznam historie.\n"
"    \n"
"    Zobrazí seznam historie s očíslovanými řádky. Řádky vypsané s „*“ byly\n"
"    změněny. Argument N říká, že se vypíše pouze posledních N řádek.\n"
"    \n"
"    Přepínače:\n"
"      -c\tvyprázdní seznam historie smazáním všech položek\n"
"      -d pozice\tsmaže ze seznamu historie položku na pozici POZICE\n"
"    \n"
"      -a\tpřipojí řádky historie z této relace do souboru historie\n"
"      -n\tnačte všechny řádky historie, které ještě nebyly načteny,\n"
"    \tze souboru historie a připojí je do seznamu historie\n"
"      -r\tnačte soubor historie a obsah připojí do seznamu historie\n"
"      -w\tzapíše současnou historii do souboru historie\n"
"    \n"
"      -p\tprovede expanzi historie na každém ARGUMENTU a výsledek zobrazí,\n"
"    \taniž by cokoliv uložil do seznamu historie\n"
"      -s\tpřipojí ARGUMENTY do seznamu historie jako jednu položku\n"
"    \n"
"    Je-li zadán JMÉNO_SOUBORU, tak ten je použit jako soubor historie. "
"Jinak\n"
"    pokud $HISTFILE má hodnotu, tato je použita, jinak ~/.bash_history.\n"
"    \n"
"    Je-li proměnná $HISTTIMEFORMAT nastavena a není-li prázdná, její "
"hodnota\n"
"    se použije jako formátovací řetězec pro strftime(3) při výpisu časových\n"
"    razítek spojených s každou položkou historie. Jinak žádná časová "
"razítka\n"
"    nebudou vypisována.    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a nedošlo k chybě."

#: builtins.c:852
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlist only processes that have changed status since the last\n"
"    \tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Zobrazí stav úloh.\n"
"    \n"
"    Vypíše aktivní úlohy. ÚLOHA omezuje výstup na danou úlohu. Bez uvedení\n"
"    přepínačů bude vypsán stav všech aktivních úloh.\n"
"    \n"
"    Přepínače:\n"
"      -l\tvypíše navíc ID procesů\n"
"      -n\tvypíše pouze procesy, které od minulého oznámení změnily stav\n"
"      -p\tvypíše pouze ID procesů\n"
"      -r\tzúží výstup jen na běžící úlohy\n"
"      -s\tzúží výstup jen na pozastavené úlohy\n"
"    \n"
"    Je-li použito -x, bude spuštěn příkaz, jakmile všechny úlohy uvedené "
"mezi\n"
"    ARGUMENTY budou nahrazeny ID procesu, který je vedoucím skupiny dané "
"úlohy.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a nevyskytla se "
"chyba.\n"
"    Byl-ly použit přepínač -x, vrátí návratový kód PŘÍKAZU."

#: builtins.c:879
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Odstraní úlohy ze současného shellu.\n"
"    \n"
"    Z tabulky aktivních úloh odebere každou ÚLOHU. Nebudou-li ÚLOHY zadány,\n"
"    shell použije vlastní představu o současné úloze.\n"
"    \n"
"    Přepínače:\n"
"      -a\todstraní všechny úlohy, pokud nebyla žádná ÚLOHA určena\n"
"      -h\toznačí každou ÚLOHU tak, že jí nebude zaslán SIGHUP, až shell sám\n"
"    \tobdrží tento signál\n"
"      -r\todstraní jen běžící úlohy\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač nebo ÚLOHA."

#: builtins.c:898
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \tassumed to be signal numbers for which names should be listed\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Zašle signál úloze.\n"
"    \n"
"    Zašle procesu určeném PID (nebo ÚLOHOU) signál zadaný pomocí SIGSPEC\n"
"    nebo ČÍSSIG. Není-li SIGSPEC ani ČÍSSIG zadán, pak se předpokládá "
"SIGTERM.\n"
"    \n"
"    Přepínače:\n"
"      -s sig\tSIG je název signálu\n"
"      -n sig\tSIG je číslo signálu\n"
"      -l\tvypíše čísla signálů; pokud „-l“ následují argumenty, má\n"
"    \tse za to, že se jedná o čísla signálů, pro které se mají vyspat\n"
"    \tjejich názvy.\n"
"    \n"
"    Kill je vestavěný příkaz shellu ze dvou důvodů: umožňuje použít\n"
"    identifikátory úloh namísto ID procesů a umožní zabíjet procesy i poté,\n"
"    co jste dosáhli limitu počtu procesů, které smíte vytvořit.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a nedošlo k chybě."

#: builtins.c:921
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are "
"listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise.."
msgstr ""
"Vyhodnotí aritmetický výraz.\n"
"    \n"
"    Vyhodnotí každý ARGUMENT jako aritmetický výraz. Vyhodnocení je\n"
"    prováděno v celých číslech o pevné šířce bez kontrol přetečení, avšak\n"
"    dělení 0 je zachyceno a označeno za chybu. Následující seznam operátorů\n"
"    je rozdělen do skupin podle úrovní přednosti. Skupiny jsou seřazeny\n"
"    v sestupném pořadí přednosti.\n"
"    \n"
"    \tid++, id--\tnásledné zvýšení, snížení proměnné\n"
"    \t++id, --id\tpřednostní zvýšení, snížení proměnné\n"
"    \t-, +\t\tunární mínus, plus\n"
"    \t!, ~\t\tlogická a bitová negace\n"
"    \t**\t\tumocnění\n"
"    \t*, /, %\t\tnásobení, dělení, zbytková třída\n"
"    \t+, -\t\tsčítání, odečítání\n"
"    \t<<, >>\t\tlevý a pravý bitový posun\n"
"    \t<=, >=, <, >\tporovnání\n"
"    \t==, !=\t\trovnost, nerovnost\n"
"    \t&\t\tbitové a zároveň (AND)\n"
"    \t^\t\tbitové vylučující nebo (XOR)\n"
"    \t|\t\tbitové nebo (OR)\n"
"    \t&&\t\tlogické a zároveň (AND)\n"
"    \t||\t\tlogické nebo (OR)\n"
"    \tVÝRAZ ? VÝRAZ : VÝRAZ\n"
"    \t\t\tpodmíněný operátor\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tpřiřazení\n"
"    \n"
"    Proměnné shellu jsou povolené operandy. Název proměnné je uvnitř výrazu\n"
"    nahrazen její hodnotou (s automatickým převodem na celé číslo pevné "
"šířky).\n"
"    Proměnná nemusí mít atribut integer (číslo) zapnutý, aby byla "
"použitelná\n"
"    ve výrazu.\n"
"    \n"
"    Operátory se vyhodnocují v pořadí přednosti. Podvýrazy v závorkách jsou\n"
"    vyhodnoceny přednostně a smí přebít pravidla přednosti uvedená výše.\n"
"    \n"
"    Návratový kód:\n"
"    Pokud poslední ARGUMENT je vyhodnocen na 0, let vrátí 1. Jinak je\n"
"    navrácena 0."

#: builtins.c:966
#, fuzzy
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with "
"word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as "
"word\n"
"    delimiters.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY "
"variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\t\tuse Readline to obtain the line in an interactive shell\n"
"      -i text\tUse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\t\tdo not allow backslashes to escape any characters\n"
"      -s\t\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of input "
"is\n"
"    \t\tnot read withint TIMEOUT seconds.  The value of the TMOUT\n"
"    \t\tvariable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns success only\n"
"    \t\tif input is available on the specified file descriptor.  The\n"
"    \t\texit status is greater than 128 if the timeout is exceeded\n"
"      -u fd\t\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times "
"out,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Načte ze standardního vstupu jeden řádek a rozdělí jej na pole.\n"
"    \n"
"    Ze standardního vstupu, nebo deskriptoru souboru FD, je-li zadán\n"
"    přepínač -u, je načten jeden řádek. Řádek se rozdělí ba pole jako při\n"
"    dělení na slova a první slovo je přiřazeno do prvního JMÉNA, druhé "
"slovo\n"
"    do druhého JMÉNA a tak dále, přičemž přebývající slova se přiřadí do\n"
"    posledního JMÉNA. Pouze znaky uvedené v $IFS jsou považovány za\n"
"    oddělovače slov.\n"
"    \n"
"    Nejsou-li uvedeny žádná JMÉNA, načtený řádek bude uložen do proměnné "
"REPLY.\n"
"    \n"
"    Přepínače:\n"
"      -a pole\tnačtená slova budou přiřazena do postupných prvků POLE\n"
"    \t\tpočínaje nulou\n"
"      -d oddělovač\tpokračuje, dokud se není načten první znak ODDĚLOVAČE\n"
"    \t\tnamísto nového řádku\n"
"      -e\t\tv interaktivním shellu bude řádek načten pomocí Readline\n"
"      -i text\tpoužije TEXT jako prvotní text pro Readline\n"
"      -n p_znaků\tvrátí řízení po načtení P_ZNAKŮ znaků, aniž by čekal na\n"
"    \t\tnový řádek\n"
"      -p výzva\tvypíše řetězec VÝZVA bez závěrečného nového řádku,\n"
"    \t\tdříve než se zahájí načítání\n"
"      -r\t\tnepovolí zpětná lomítka pro escapování jakýchkoliv znaků\n"
"      -s\t\tvstup pocházející z terminálu nebude zobrazován\n"
"      -t limit\tumožní vypršení časového limitu a vrácení chyby, pokud\n"
"    \t\tnebude načten celý řádek do LIMIT sekund. Hodnota proměnné\n"
"    \t\tTMOUT představuje implicitní limit. TIMEOUT smí být desetinné\n"
"    \t\tčíslo. Návratový kód bude větší než 128, pokud časový limit\n"
"    \t\tvyprší.\n"
"      -u fd\t\tčte z deskriptoru souboru FD namísto standardního vstupu\n"
"    \n"
"    Návratový kód:\n"
"    Návratový kód je nula, pokud se nenarazí na konec souboru, časový limit\n"
"    pro čtení nevyprší nebo není poskytnut neplatný deskriptor souboru jako\n"
"    argument -u."

#: builtins.c:1006
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Návrat z shellové funkce.\n"
"    \n"
"    Způsobí ukončení funkce nebo skriptu načteného přes „source“ "
"s návratovou\n"
"    hodnotou určenou N. Je-li N vynecháno, návratový kód bude roven "
"poslednímu\n"
"    příkazu vykonanému uvnitř dotyčné funkce nebo skriptu.\n"
"    \n"
"    Návratová hodnota:\n"
"    Vrátí N, nebo selže, pokud shell neprovádí funkci nebo skript."

#: builtins.c:1019
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero "
"status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not follow symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG trap is inherited by shell functions.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Nastaví nebo zruší hodnoty přepínačů shellu a pozičních parametrů.\n"
"    \n"
"    Změní hodnoty atributům shellu a pozičním parametrům, nebo zobrazí "
"názvy\n"
"    a hodnoty proměnných shellu.\n"
"    \n"
"    Přepínače:\n"
"      -a  Označí měněné nebo vytvářené proměnné pro export.\n"
"      -b  Neprodleně oznámí ukončení úlohy.\n"
"      -e  Neprodleně skončí, pokud nějaký příkaz skončí s nenulovým kódem.\n"
"      -f  Zakáže vytváření jmen souborů (globbing).\n"
"      -h  Zapamatuje si umístění příkazů tehdy, když jsou vyhledány.\n"
"      -k  Všechny přiřazovací argumenty budou umístěny do prostředí\n"
"          příkazu. Nejenom ty, co předchází název příkazu.\n"
"      -m  Správa úloh je zapnuta.\n"
"      -n  Příkazy načte, ale neprovede je.\n"
"      -o NÁZEV_PŘEPÍNAČE\n"
"          Nastaví proměnnou odpovídající NÁZVU_PŘEPÍNAČE:\n"
"              allexport    stejné jako -a\n"
"              braceexpand  stejné jako -B\n"
"              emacs        použije emacsový způsob editace na řádku\n"
"              errexit      stejné jako -e\n"
"              errtrace     stejné jako -E\n"
"              functrace    stejné jako -T\n"
"              hashall      stejné jako -h\n"
"              histexpand   stejné jako -H\n"
"              history      zapne historii příkazů\n"
"              ignoreeof    shell neskončí, když načte EOF (konec souboru)\n"
"              interactive-comments\n"
"                           povolí, aby se v interaktivních příkazech\n"
"                           objevovaly komentáře\n"
"              keyword      stejné jako -k\n"
"              monitor      stejné jako -m\n"
"              noclobber    stejné jako -C\n"
"              noexec       stejné jako -n\n"
"              noglob       stejné jako -f\n"
"              nolog        v současnosti přijímáno, ale ignorováno\n"
"              notify       stejné jako -b\n"
"              nounset      stejné jako -u\n"
"              onecmd       stejné jako -t\n"
"              physical     stejné jako -P\n"
"              pipefail     návratová hodnota kolony je status posledního\n"
"                           příkazu, který skončil s nenulovým kódem.\n"
"                           Návratová hodnota je nula, pokud žádný z příkazů\n"
"                           neskončil s nenulovým kódem.\n"
"              posix        změní chování bashe tam, kde implicitní chování\n"
"                           se liší od standardu 1003.2, tak, aby bylo\n"
"                           v souladu se standardem\n"
"              privileged   stejné jako -p\n"
"              verbose      stejné jako -v\n"
"              vi           použije vi způsob editace na řádku\n"
"              xtrace       stejné jako -x\n"
"      -p  Zapnuto, kdykoliv reálné a efektivní ID uživatele se neshodují.\n"
"          Vypne zpracování souboru $ENV a importování shellových funkcí.\n"
"          Vypnutí tohoto přepínače způsobí, že efektivní UID a GID budou\n"
"          nastavena na reálná UID a GID.\n"
"      -t  Skončí po načtení a provedení jednoho příkazu.\n"
"      -u  Při substituci považuje nenastavené proměnné za chybu.\n"
"      -v  Vstupní řádky shellu se budou vypisovat tak, jak budou načítány.\n"
"      -x  Vypisuje příkazy a jejich argumenty tak, jak jsou spouštěny.\n"
"      -B  Shell bude provádět závorkovou (brace) expanzi.\n"
"      -C  Je-li nastaveno, zakáže přepsání již existujících běžných souborů\n"
"          při přesměrování výstupu.\n"
"      -E  Je-li nastaveno, trap ERR (zachytávání chyb) bude děděn do\n"
"          funkcí shellu.\n"
"      -H  Zapne ! způsob nahrazování histore. Tento příznak je automaticky\n"
"          zapnut při interaktivním shellu.\n"
"      -P  Je-li nastaveno, nebudou následovány symbolické odkazy při\n"
"          provádění příkazů jako změna pracovního adresáře pomocí „cd“.\n"
"      -T  Je-li nastaveno, trap DEBUG (obsluha ladění) bude děděna do\n"
"          funkcí shellu.\n"
"      -   Přiřadí jakékoliv zbývající argumenty do pozičních parametrů.\n"
"          Přepínače -x a -v budou vypnuty.\n"
"    \n"
"    Použití + místo - způsobí, že tyto příznaky budou vypnuty. Příznaky lze "
"též\n"
"    použít při volání shellu. Aktuální množinu příznaků je možno nalézt "
"v $-.\n"
"    Přebývajících n ARGUMENTŮ jsou poziční parametry a budou přiřazeny,\n"
"    v pořadí, do $1, $2, … $n. Nejsou-li zadány žádné ARGUMENTY, budou\n"
"    vytištěny všechny proměnné shellu.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný argument."

#: builtins.c:1101
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that "
"fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Odstraňuje hodnoty a atributy proměnných a funkcí shellu.\n"
"    \n"
"    Pro každé JMÉNO odstraní odpovídající proměnnou nebo funkci.\n"
"    \n"
"    Přepínače:\n"
"      -f\tpovažuje každé JMÉNO za funkci shellu\n"
"      -v\tpovažuje každé JMÉNO za proměnnou shellu\n"
"    \n"
"    Bez těchto dvou příznaků unset nejprve zkusí zrušit proměnnou a pokud "
"toto\n"
"    selže, tak zkusí zrušit funkci.\n"
"    \n"
"    Některé proměnné nelze odstranit. Vizte příkaz „readonly“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a JMÉNO není jen pro\n"
"    čtení."

#: builtins.c:1121
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before "
"exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Nastaví atribut exportovat proměnné shellu.\n"
"    \n"
"    Každý NÁZEV je označen pro automatické exportování do prostředí "
"následně\n"
"    prováděných příkazů. Je-li zadána HODNOTA, před exportem přiřadí "
"HODNOTU.\n"
"    \n"
"    Přepínače:\n"
"      -f\tvztahuje se na funkce shellu\n"
"      -n\todstraní vlastnost exportovat každému NÁZVU\n"
"      -p\tzobrazí seznam všech exportovaných proměnných a funkcí\n"
"    \n"
"    Argument „--“ zakazuje zpracování dalších přepínačů.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač nebo NÁZEV."

#: builtins.c:1140
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Označí proměnné shellu za nezměnitelné.\n"
"    \n"
"    Označí každý NÁZEV jako jen pro čtení, hodnoty těchto NÁZVŮ nebude "
"možné\n"
"    změnit následným přiřazením. Je-li zadána HODNOTA, před označením za "
"jen\n"
"    pro čtení přiřadí HODNOTU.\n"
"    \n"
"    Přepínače:\n"
"      -a\tvztahuje se na proměnné typu číslované pole\n"
"      -A\tvztahuje se na proměnné typu asociativní pole\n"
"      -f\tvztahuje se funkce shellu\n"
"      -p\tzobrazí seznam všech proměnných a funkcí jen pro čtení\n"
"    \n"
"    Argument „--“ zakáže zpracování dalších přepínačů.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač nebo NÁZEV."

#: builtins.c:1161
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Posune poziční parametry.\n"
"    \n"
"    Přejmenuje poziční parametry $N+1, $N+2, … na $1, $2, …\n"
"    Není-li zadáno N, předpokládá se 1.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud N není záporný a není větší než $#."

#: builtins.c:1173 builtins.c:1188
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Vykoná příkazy obsažené ze souboru v současném shellu.\n"
"    \n"
"    Načte a provede příkazy z NÁZEV_SOUBORU v tomto shellu. Položky v $PATH\n"
"    jsou použity pro nalezení adresáře obsahujícího NÁZEV_SOUBORU. Jsou-li\n"
"    zadány nějaké ARGUMENTY, stanou se pozičními parametry při běhu\n"
"    NÁZVU_SOUBORU.\n"
"    \n"
"    Návratový kód:\n"
"    Vrací návratový kód posledního provedeného příkazu z NÁZVU_SOUBORU.\n"
"    Selže, pokud NÁZEV_SOUBORU nelze načíst."

#: builtins.c:1204
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Pozastaví běh shellu.\n"
"    \n"
"    Pozastaví provádění tohoto shellu do doby, něž bude obdržen signál\n"
"    SIGCONT. Není-li vynuceno, přihlašovací shell nelze pozastavit.\n"
"    \n"
"    Přepínače:\n"
"      -f\tvynutí pozastavení, i když se jedná o přihlašovací (login) shellu\n"
"    \n"
"    Návratový kód:\n"
"    Vrací úspěch, pokud je správa úloh zapnuta a nevyskytla se chyba."

#: builtins.c:1220
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators as well, and numeric comparison operators.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last "
"read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 "
"lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Vyhodnotí podmínkový výraz.\n"
"    \n"
"    Skončí s kódem 0 (pravda) nebo 1 (nepravda) podle vyhodnocení VÝRAZU.\n"
"    Výraz smí být unární nebo binární. Unární výrazy se často používají pro\n"
"    zjištění stavu souboru. Rovněž jsou k dispozici řetězcové operátory a\n"
"    operátory číselného porovnání.\n"
"    \n"
"    Souborové operátory:\n"
"    \n"
"      -a SOUBOR      Pravda, pokud soubor existuje.\n"
"      -b SOUBOR      Pravda, pokud soubor je blokovým zařízením.\n"
"      -c SOUBOR      Pravda, pokud soubor je znakovým zařízením.\n"
"      -d SOUBOR      Pravda, pokud soubor je adresářem.\n"
"      -e SOUBOR      Pravda, pokud soubor existuje.\n"
"      -f SOUBOR      Pravda, pokud soubor existuje a je to běžný soubor.\n"
"      -g SOUBOR      Pravda, pokud soubor je SGID.\n"
"      -h SOUBOR      Pravda, pokud soubor je symbolickým odkazem.\n"
"      -L SOUBOR      Pravda, pokud soubor je symbolickým odkazem.\n"
"      -k SOUBOR      Pravda, pokud soubor má nastavený „sticky“ bit.\n"
"      -p SOUBOR      Pravda, pokud soubor je pojmenovanou rourou.\n"
"      -r SOUBOR      Pravda, pokud soubor je vámi čitelný.\n"
"      -s SOUBOR      Pravda, pokud soubor existuje a je neprázdný.\n"
"      -S SOUBOR      Pravda, pokud soubor je socketem.\n"
"      -t FD          Pravda, pokud FD (deskriptor souboru) je otevřený na\n"
"                     terminálu.\n"
"      -u SOUBOR      Pravda, pokud soubor je SUID.\n"
"      -w SOUBOR      Pravda, pokud soubor je vámi zapisovatelný.\n"
"      -x SOUBOR      Pravda, pokud soubor je vámi spustitelný.\n"
"      -O SOUBOR      Pravda, pokud soubor je vámi efektivně vlastněn.\n"
"      -G SOUBOR      Pravda, pokud soubor je efektivně vlastněn vaší\n"
"                     skupinou.\n"
"      -N SOUBOR      Pravda, pokud soubor byl změněn po posledním čtení.\n"
"    \n"
"      SOUBOR1 -nt SOUBOR2\n"
"                     Pravda, pokud je SOUBOR1 novější než SOUBOR2 (podle "
"času\n"
"                     změny obsahu).\n"
"    \n"
"      SOUBOR1 -ot SOUBOR2\n"
"                     Pravda, pokud SOUBOR1 je starší než SOUBOR2.\n"
"    \n"
"      SOUBOR1 -ef SOUBOR2\n"
"                     Pravda, pokud SOUBOR1 je pevným odkazem na SOUBOR2.\n"
"    \n"
"    Řetězcové operátory:\n"
"    \n"
"      -z ŘETĚZEC     Pravda, pokud ŘETĚZEC je prázdný.\n"
"    \n"
"      -n ŘETĚZEC\n"
"         ŘETĚZEC     Pravda, pokud ŘETĚZEC není prázdný.\n"
"    \n"
"      ŘETĚZEC1 = ŘETĚZEC2\n"
"                     Pravda, pokud jsou řetězce shodné.\n"
"      ŘETĚZEC1 != ŘETĚZEC2\n"
"                     Pravda, pokud se řetězce neshodují.\n"
"      ŘETĚZEC1 < ŘETĚZEC2\n"
"                     Pravda, pokud se ŘETĚZEC1 řadí lexikograficky před\n"
"                     ŘETĚZEC2.\n"
"      ŘETĚZEC1 > ŘETĚZEC2\n"
"                     Pravda, pokud se ŘETĚZEC1 řadí lexikograficky za\n"
"                     ŘETĚZEC2.\n"
"    \n"
"    Další operátory:\n"
"    \n"
"      -o PŘEPÍNAČ    Pravda, pokud je přepínač shellu PŘEPÍNAČ zapnut.\n"
"      ! VÝRAZ        Pravda, pokud je VÝRAZ nepravdivý.\n"
"      VÝRAZ1 -a VÝRAZ2\n"
"                     Pravda, pokud oba VÝRAZ1 I VÝRAZ2 jsou pravdivé.\n"
"      VÝRAZ1 -o VÝRAZ2\n"
"                     Pravda, pokud VÝRAZ1 NEBO VÝRAZ2 je pravdivý.\n"
"    \n"
"      ARGUMENT1 OP ARGUMENT2\n"
"                     Aritmetické testy. OP je jeden z -eq, -ne, -lt,\n"
"                     -le, -gt nebo -ge.\n"
"    \n"
"    Aritmetické binární operátory vracejí pravdu, pokud ARGUMENT1 je roven,\n"
"    neroven, menší než, menší než nebo roven, větší než, větší než nebo\n"
"    roven ARGUMENTU2.    \n"
"    Návratový kód:\n"
"    Vrací úspěch, je-li VÝRAZ vyhodnocen jako pravdivý. Selže, je-li VÝRAZ\n"
"    vyhodnocen jako nepravdivý nebo je-li zadán neplatný argument."

#: builtins.c:1296
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Vyhodnotí podmínkový výraz.\n"
"    \n"
"    Toto je synonymum pro vestavěný příkaz „test“, až na to, že poslední\n"
"    argument musí být doslovně „]“, aby se shodoval s otevírající „[“."

#: builtins.c:1305
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of "
"its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Zobrazí časy procesu.\n"
"    \n"
"    Vypíše celkovou dobu procesu shellu a všech jeho potomků, kterou "
"strávili\n"
"    v uživatelském a jaderném (system) prostoru.\n"
"    \n"
"    Návratový kód:\n"
"    Vždy uspěje."

#: builtins.c:1317
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives "
"signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  "
"If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands "
"associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal "
"number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is "
"given."
msgstr ""
"Zachytávání signálů a jiných událostí.\n"
"    \n"
"    Definuje a aktivuje obsluhy, které budou spuštěny, když shell obdrží\n"
"    signály nebo nastanou určité podmínky.\n"
"    \n"
"    Příkaz ARGUMENT bude načten a proveden, až shell obdrží signál(y)\n"
"    SIGNAL_SPEC. Pokud ARGUMENT chybí (a je zadán jeden SIGNAL_SPEC) nebo "
"je\n"
"    „-“, každý určený signál bude přenastaven zpět na svoji původní "
"hodnotu.\n"
"    Je-li ARGUMENT prázdný řetězec, každý SIGNAL_SPEC bude shellem a "
"příkazy\n"
"    z něj spuštěnými ignorován.\n"
"    \n"
"    Je-li SIGNAL_SPEC „EXIT (0)“, bude ARGUMENT proveden při ukončování "
"tohoto\n"
"    shellu. Je-li SIGNAL_SPEC „DEBUG“, bude ARGUMENT proveden před každým\n"
"    jednoduchým příkazem.\n"
"    \n"
"    Nejsou-li poskytnuty žádné argumenty, trap vypíše seznam příkazů "
"navázaných\n"
"    na všechny signály.\n"
"    \n"
"    Přepínače:\n"
"      -l\tvypíše seznam jmen signálů a jim odpovídajících čísel\n"
"      -p\tzobrazí příkazy navázané na každý SIGNAL_SPEC\n"
"    \n"
"    Každý SIGNAL_SPEC je buďto jméno signálu ze <signal.h>, nebo číslo "
"signálu.\n"
"    U jmen signálů nezáleží na velikosti písmen a předpona SIG je "
"nepovinná.\n"
"    Aktuálnímu shellu lze zaslat signál pomocí „kill -signal $$“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud SIGSPEC a zadané přepínače jsou platné."

#: builtins.c:1349
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \tincludes aliases, builtins, and functions, if and only if\n"
"    \tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \tbuiltin, or function, and returns the name of the disk file\n"
"    \tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \tor nothing if `type -t NAME' would not return `file'.\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t`function', `builtin', `file' or `', if NAME is an alias, shell\n"
"    \treserved word, shell function, shell builtin, disk file, or not\n"
"    \tfound, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not "
"found."
msgstr ""
"Zobrazí informace o typu příkazu.\n"
"    \n"
"    O každém NÁZVU řekne, jak by byl interpretován, kdyby byl použit jako\n"
"    název příkazu.\n"
"    \n"
"    Přepínače\n"
"      -a\tzobrazí všechna místa, kde se nalézá spustitelný program\n"
"    \tpojmenovaný NÁZEV. To zahrnuje aliasy, vestavěné příkazy a funkce\n"
"    \tjen a pouze tehdy, když není rovněž použit přepínač -p.\n"
"      -f\tpotlačí hledání mezi funkcemi shellu\n"
"      -P\tvynutí prohledání PATH na každý NÁZEV, dokonce i když se\n"
"    \tjedná o alias, vestavěný příkaz nebo funkci, a vrátí název\n"
"    \tsouboru na disku, který by byl spuštěn\n"
"      -p\tbuď vrátí jméno souboru na disku, který by byl spuštěn,\n"
"    \tnebo nic, pokud „type -t NÁZEV“ by nevrátil „file“ (soubor)\n"
"      -t\tvypíše jedno slovo z těchto: „alias“, „keyword“, „function“,\n"
"    \t„builtin“, „file“ nebo „“, je-li NÁZEV alias, klíčové slovo\n"
"    \tshellu, shellová funkce, vestavěný příkaz shellu, soubor na\n"
"    \tdisku nebo nenalezený příkaz\n"
"    \n"
"    Argumenty:\n"
"      NÁZEV\tNázev příkazu určený k výkladu.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud všechny NÁZVY byly nalezeny. Selže, pokud některé\n"
"    nalezeny nebyly."

#: builtins.c:1380
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and "
"processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Upravuje omezení (limity) zdrojů shellu.\n"
"    \n"
"    Poskytuje kontrolu nad zdroji dostupnými shellu a procesům z něj\n"
"    spuštěných (na systémech, které takovou kontrolu umožňují).\n"
"    \n"
"    Přepínače:\n"
"      -S\tpoužije se „měkké“ (soft) omezení zdroje\n"
"      -H\tpoužije se „tvrdé“ (hard) omezení zdroje\n"
"      -a\tnahlásí všechna současná omezení (limity)\n"
"      -b\tvelikost vyrovnávací paměti socketů\n"
"      -c\tmaximální velikost vytvářených core souborů (výpis paměti "
"programu)\n"
"      -d\tmaximální velikost datového segmentu procesu\n"
"      -e\tmaximální plánovací priorita  („nice“)\n"
"      -f\tmaximální velikost souborů zapsaných shellem a jeho potomky\n"
"      -i\tmaximální počet čekajících signálů\n"
"      -l\tmaximální velikost paměti, kterou může proces zamknout\n"
"      -m\tmaximální velikost rezidentní paměti (resident set size)\n"
"      -n\tmaximální počet otevřených deskriptorů souboru\n"
"      -p\tvelikost vyrovnávací paměti rour\n"
"      -q\tmaximální počet bajtů ve frontě posixových zpráv\n"
"      -r\tmaximální priorita plánování v reálném čase\n"
"      -s\tmaximální velikost zásobníku\n"
"      -t\tmaximální množství procesorového času v sekundách\n"
"      -u\tmaximální počet procesů uživatele\n"
"      -v\tvelikost virtuální paměti\n"
"      -x\tmaximální počet zámků na souborech\n"
"    \n"
"    Je-li zadán LIMIT, jedná se o novou hodnotu daného zdroje. Zvláštní\n"
"    hodnoty LIMITU „soft“, „hard“ a „unlimited“ znamenají současný měkký\n"
"    limit, současný tvrdý limit a žádný limit. V opačném případě bude\n"
"    zobrazena současná hodnota limitu daného zdroje. Není-li zadán žádný\n"
"    přepínač, pak se předpokládá -f.\n"
"    \n"
"    Hodnoty jsou v násobcích 1024 bajtů, kromě -t, která je v sekundách,\n"
"    -p, která je v násobcích 512 bajtů, a -u, což je absolutní počet "
"procesů.\n"
"    \n"
"    Návratová hodnota:\n"
"    Vrací úspěch, pokud nebyl zadán neplatný přepínač a nevyskytla se chyba."

#: builtins.c:1425
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Zobrazí nebo nastaví uživatelskou masku práv.\n"
"    \n"
"    Nastaví Uživatelskou masku práv vytvářených souborů na MÓD. Je-li\n"
"    MÓD vynechán, bude vytištěna současná hodnota masky.\n"
"    \n"
"    Začíná-li MÓD číslicí, bude interpretován jako osmičkové číslo, jinak\n"
"    jako řetězec symbolického zápisu práv tak, jak jej chápe chmod(1).\n"
"    \n"
"    Přepínače:\n"
"      -p\tje-li MÓD vynechán, bude výstup v podobě, kterou lze použít\n"
"    \tjako vstup\n"
"      -S\tučiní výstup symbolický, jinak bude výstupem osmičkové číslo\n"
"    \n"
"    Návratový kód\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný MÓD nebo přepínač."

#: builtins.c:1445
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for the process identified by ID, which may be a process ID or a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a a job specification, waits for all "
"processes\n"
"    in the job's pipeline.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of ID; fails if ID is invalid or an invalid option "
"is\n"
"    given."
msgstr ""
"Počká na dokončení úlohy a vrátí její návratový kód.\n"
"    \n"
"    Počká na proces určený ID, což může být ID procesu nebo identifikace\n"
"    úlohy, a nahlásí jeho návratový kód. Není-li ID zadáno, počká na "
"všechny\n"
"    právě aktivní dětské procesy a návratovým kódem bude nula. Je-li ID\n"
"    identifikátorem úlohy, počká na všechny procesy z kolony úlohy.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí kód ID, selže, pokud ID není platný nebo byl zadán neplatný "
"přepínač."

#: builtins.c:1463
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for the specified process and reports its termination status.  If\n"
"    PID is not given, all currently active child processes are waited for,\n"
"    and the return code is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of ID; fails if ID is invalid or an invalid option "
"is\n"
"    given."
msgstr ""
"Počká na dokončení procesu a vrátí jeho návratový kód.\n"
"    \n"
"    Počká na zadaný proces a nahlásí jeho návratový kód. Není-li PID zadán,\n"
"    bude se čekat na všechny právě aktivní procesy potomků a návratová "
"hodnota\n"
"    bude nula. PID musí být ID procesu.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí kód ID, selže, pokud ID není platný nebo byl zadán neplatný "
"přepínač."

#: builtins.c:1478
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Pro každý prvek seznamu vykoná příkazy.\n"
"    \n"
"    Smyčka „for“ provede posloupnost příkazů pro každý prvek v seznamu "
"položek.\n"
"    Pokud „in SLOVECH…;“ není přítomno, pak se předpokládá „in \"$@\"“. "
"NÁZEV\n"
"    bude postupně nastaven na každý prvek ve SLOVECH a PŘÍKAZY budou "
"provedeny.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí kód naposledy provedeného příkazu."

#: builtins.c:1492
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Aritmetika smyček.\n"
"    \n"
"    Ekvivalentní k\n"
"    \t(( VÝR1 ))\n"
"    \twhile (( VÝR2 )); do\n"
"    \t\tPŘÍKAZY\n"
"    \t\t(( VÝR3 ))\n"
"    \tdone\n"
"    VÝR1, VÝR2 a VÝR3 jsou aritmetické výrazy. Chybí-li některý výraz,\n"
"    chová se, jako by byl vyhodnocen na 1.    \n"
"    Návratový kód:\n"
"    Vrátí kód naposledy vykonaného příkazu."

#: builtins.c:1510
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Vybere slova ze seznamu a vykoná příkazy.\n"
"    \n"
"    SLOVA jsou expandována a vytvoří seznam slov. Množina expandovaných "
"slov\n"
"    je vytištěna na standardní chybový výstup, každé předchází číslo.  Není-"
"li\n"
"    „in SLOVA“ přítomno, předpokládá se „in \"$@\"“. Pak je zobrazena výzva "
"PS3\n"
"    a jeden řádek načten ze standardního vstupu. Pokud je řádek tvořen "
"číslem\n"
"    odpovídajícím jednomu ze zobrazených slov, pak NÁZEV bude nastaven na "
"toto\n"
"    slovo. Pokud je řádek prázdný, SLOVA a výzva budou znovu zobrazeny. Je-"
"li\n"
"    načten EOF (konec souboru), příkaz končí. Načtení jakékoliv jiné "
"hodnoty\n"
"    nastaví NÁZEV na prázdný řetězec. Načtený řádek bude uložen do proměnné\n"
"    REPLY. Po každém výběru budou provedeny PŘÍKAZY, dokud nebude vykonán\n"
"    příkaz „break“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí kód naposledy prováděného příkazu."

#: builtins.c:1531
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Nahlásí čas spotřebovaný prováděním kolony.\n"
"    \n"
"    Vykoná KOLONU a zobrazí přehled reálného času, uživatelského\n"
"    procesorového času a systémového procesorového času stráveného "
"prováděním\n"
"    KOLONY poté, co skončí.\n"
"    \n"
"    Přepínače:\n"
"      -p\tzobrazí přehled časů v přenositelném posixovém formátu\n"
"    \n"
"    Hodnota proměnné TIMEFORMAT se použije jako specifikace výstupního "
"formátu.\n"
"    \n"
"    Návratový kód:\n"
"    Návratová hodnota je návratová hodnota KOLONY."

#: builtins.c:1548
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Provede příkazy podle shody se vzorem.\n"
"    \n"
"    Výběrově provede PŘÍKAZY na základě shody SLOVA se VZOREM. Znak „|“\n"
"    se používá na oddělení násobných VZORŮ.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí kód naposledy provedeného příkazu."

#: builtins.c:1560
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then "
"the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list "
"is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  "
"Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of "
"the\n"
"    entire construct is the exit status of the last command executed, or "
"zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Vykoná příkazy na základě splnění podmínky.\n"
"    \n"
"    Provede seznam „if PŘÍKAZŮ“. Bude-li jeho návratový kód nula, pak bude\n"
"    proveden seznam „then PŘÍKAZŮ“. Jinak bude proveden popořadě každý "
"seznam\n"
"    „elif PŘÍKAZŮ“ a bude-li jeho návratový kód nula, odpovídající seznam\n"
"    „then PŘÍKAZŮ“ bude proveden a příkaz if skončí. V opačném případě bude\n"
"    proveden seznam „else PŘÍKAZŮ“, pokud existuje. Návratová hodnota celé\n"
"    konstrukce je návratovou hodnotou posledního provedeného příkazu nebo "
"nula,\n"
"    pokud žádná z testovaných podmínek není pravdivá.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí kód naposledy provedeného příkazu."

#: builtins.c:1577
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS as long as the final command in the\n"
"    `while' COMMANDS has an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Vykonává příkazy, dokud test úspěšně prochází.\n"
"    \n"
"    Expanduje a provádí PŘÍKAZY tak dlouho, dokud poslední příkaz ve "
"„while“\n"
"    PŘÍKAZECH má nulový návratový kód.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí kód naposledy provedeného příkazu."

#: builtins.c:1589
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS as long as the final command in the\n"
"    `until' COMMANDS has an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Vykonává příkazy, dokud test končí neúspěšně.\n"
"    \n"
"    Expanduje a provádí PŘÍKAZY tak dlouho, dokud poslední příkaz ve "
"„until“\n"
"    PŘÍKAZECH má nenulový návratový kód.    \n"
"    Návratový kód:\n"
"    Vrátí kód naposledy provedeného příkazu."

#: builtins.c:1601
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of COMMAND."
msgstr ""

#: builtins.c:1615
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is "
"invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Definuje funkci shellu.\n"
"    \n"
"    Vytvoří shellovou funkci pojmenovanou NÁZEV. Volána jakožto jednoduchý\n"
"    příkaz spustí PŘÍKAZY v kontextu volajícího shellu. Je-li vyvolán "
"NÁZEV,\n"
"    budou funkci předány argumenty jako $1…$n a název funkce bude umístěn "
"do\n"
"    $FUNCNAME.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud NÁZEV není jen pro čtení."

#: builtins.c:1629
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Seskupí příkazy do jednotky.\n"
"    \n"
"    Spustí množinu příkazů v jedné skupině. Toto je jeden ze způsobů,\n"
"    jak přesměrovat celou množinu příkazů.    \n"
"    Návratový kód:\n"
"    Vrátí kód naposledy spuštěného příkazu."

#: builtins.c:1641
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Obnoví úlohu do popředí.\n"
"    \n"
"    Ekvivalent k argumentu ÚLOHA příkazu „fg“. Obnoví pozastavenou úlohu\n"
"    nebo úlohu na pozadí. ÚLOHA může určovat buď název úlohy, nebo číslo "
"úlohy.\n"
"    Přidání „&“ za ÚLOHU přesune úlohu na pozadí, jako by identifikátor "
"úlohy\n"
"    byl argumentem příkazu „bg“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí kód obnovené úlohy."

#: builtins.c:1656
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to \"let EXPRESSION\".\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Vyhodnotí aritmetický výraz.\n"
"    \n"
"    VÝRAZ bude vyhodnocen podle pravidel aritmetického vyhodnocování.\n"
"    Ekvivalentní k „let VÝRAZ“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí 1, pokud se VÝRAZ vyhodnotí na 0. Jinak vrátí 0."

# XXX: „coniditional command“ znamená podmínka, výraz podmínky. Nikoliv
# příkaz, který by byl vykonán na základě splnění jiné podmínky. Tj. překlad
# „podmíněný příkaz“ je chybný.
# Toto je nápověda k vestavěnému příkazu „[“.
#: builtins.c:1668
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the "
"conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries "
"used\n"
"    by the `test' builtin, and may be combined using the following "
"operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Vykoná podmínkový příkaz.\n"
"    \n"
"    Vrátí status 0 nebo 1 podle vyhodnocení výrazu podmínky VÝRAZ. Výrazy\n"
"    se skládají ze stejných primitiv jako u vestavěného příkazu „test“ a\n"
"    mohou být kombinovány za pomoci následujících operátorů:\n"
"    \n"
"      ( VÝRAZ )\tVrátí hodnotu VÝRAZU\n"
"      ! VÝRAZ\t\tPravda, pokud VÝRAZ je nepravdivý; jinak nepravda\n"
"      VÝR1 && VÝR2\tPravda, pokud oba VÝR1 i VÝR2 jsou pravdivé;\n"
"    \t\tjinak nepravda\n"
"      VÝR1 || VÝR2\tPravda, pokud VÝR1 nebo VÝR2 je pravdivý; jinak "
"nepravda\n"
"    \n"
"    Jsou-li použity operátory „==“ a „!=“, řetězec napravo od operátoru je\n"
"    použit jako vzor a bude uplatněno porovnávání proti vzoru. Je-li použit\n"
"    operátor „=~, řetězec napravo do operátoru je uvažován jako regulární\n"
"    výraz.\n"
"    \n"
"    Operátory && a || nevyhodnocují VÝR2, pokud VÝR1 je dostatečný na "
"určení\n"
"    hodnoty výrazu.\n"
"    \n"
"    Návratový kód:\n"
"    0 nebo 1 podle hodnoty VÝRAZU."

#: builtins.c:1694
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"Názvu běžných proměnných shellu a jejich význam.\n"
"    \n"
"    BASH_VERSION\tInformace o verzi tohoto Bashe.\n"
"    CDPATH\tDvojtečkou oddělený seznam adresářů, který se prohledává\n"
"    \t\tna adresáře zadané jako argumenty u „cd“.\n"
"    GLOBIGNORE\tDvojtečkou oddělený seznam vzorů popisujících jména "
"souborů,\n"
"    \t\tkterá budou ignorována při expanzi cest.\n"
"    HISTFILE\tJméno souboru, kde je uložena historie vašich příkazů.\n"
"    HISTFILESIZE\tMaximální počet řádků, které tento soubor smí obsahovat.\n"
"    HISTSIZE\tMaximální počet řádků historie, které jsou dostupné uvnitř\n"
"    \t\tběžícího shellu.\n"
"    HOME\tCelá cesta do vašeho domovského adresáře.\n"
"    HOSTNAME\tJméno současného stroje.\n"
"    HOSTTYPE\tDruh CPU, na které tento Bash běží.\n"
"    IGNOREEOF\tŘídí reakci shellu na přijetí znaku EOF (konec souboru)\n"
"    \t\tpři samotném vstupu. Je-li nastaveno, pak její hodnota udává\n"
"    \t\tpočet znaků EOF, které mohou bezprostředně následovat na prázdném\n"
"    \t\třádku, dříve než shell skončí (implicitní hodnota je 10). Není-li\n"
"    \t\tnastaveno, EOF značí konec vstupu.\n"
"    MACHTYPE\tŘetězec popisující systém, na kterém tento Bash běží.\n"
"    MAILCHECK\tJak často, v sekundách, kontroluje Bash novou poštu.\n"
"    MAILPATH\tDvojtečkou oddělený seznam názvů souborů, které Bash\n"
"    \t\tkontroluje na novou poštu.\n"
"    OSTYPE\tVerze Unixu, na kterém tento Bash běží.\n"
"    PATH\tDvojtečkou oddělený seznam adresářů, které jsou prohledávány\n"
"    \t\tna příkazy.\n"
"    PROMPT_COMMAND\tPříkaz, který je proveden před vytištěním každé\n"
"    \t\tprimární výzvy shellu.\n"
"    PS1\t\tŘetězec prvotní výzvy shellu.\n"
"    PS2\t\tŘetězec druhotné výzvy shellu.\n"
"    PWD\t\tCelé jméno cesty do aktuálního adresáře.\n"
"    SHELLOPTS\tDvojtečkou oddělený seznam zapnutých přepínačů shellu.\n"
"    TERM\tNázev druhu současného terminálu.\n"
"    TIMEFORMAT\tVýstupní formát časové statistiky zobrazované vyhrazeným\n"
"    \t\tslovem „time“.\n"
"    auto_resume\tNeprázdná hodnota znamená, že slovo příkazu objevující se\n"
"    \t\tna řádce automaticky je nejprve vyhledáno v seznamu\n"
"    \t\tprávě pozastavených úloh. Je-li tam nalezeno, daná úloha bude\n"
"    \t\tpřepnuta na popředí. Hodnota „exact“ znamená, že slovo příkazu\n"
"    \t\tse musí přesně shodovat s příkazem v seznamu pozastavených úloh.\n"
"    \t\tHodnota „substring“ znamená, že slovo příkazu se musí shodovat\n"
"    \t\ts podřetězcem úlohy. Jakákoliv jiná hodnota znamená, že příkaz\n"
"    \t\tmusí být předponou pozastavené úlohy.\n"
"    histchars\tZnaky řídící expanzi historie a rychlé nahrazování.\n"
"    \t\tPrvní znak je znak nahrazení historie, obvykle „!“. Druhý je\n"
"    \t\tznak „rychlého nahrazování“, obvykle „^“. Třetí je znak\n"
"    \t\t„komentáře historie“, obvykle „#“.\n"
"    HISTIGNORE\tDvojtečkou oddělený seznam vzorů používaný na\n"
"    \t\trozlišení, které příkazy by měly být uloženy do seznamu\n"
"    \t\thistorie.\n"

#: builtins.c:1751
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Přidá adresáře do zásobníku.\n"
"    \n"
"    Přidá adresář na vrchol zásobníku adresářů nebo zásobník zrotuje tak,\n"
"    že nový vrchol zásobníku se stane současným pracovním adresářem. Bez\n"
"    argumentů prohodí dva vrchní adresáře.\n"
"    \n"
"    Přepínače:\n"
"      -n\tPotlačí obvyklou změnu adresáře, když se na zásobník přidávají\n"
"    \tadresáře, takže změněn bude pouze zásobník.\n"
"    \n"
"    Argumenty:\n"
"      +N\tZrotuje zásobník tak, že N. adresář (počítáno zleva na seznamu\n"
"    \tzobrazovaném pomocí „dirs“, počínaje nulou) se dostane na vrchol.\n"
"    \n"
"      -N\tZrotuje zásobník tak, že N. adresář (počítáno zprava na seznamu\n"
"    \tzobrazovaném pomocí „dirs“, počínaje nulou) se dostane na vrchol.\n"
"    \n"
"      adresář\n"
"    \tPřidá ADRESÁŘ na vrchol zásobníku adresářů a učiní jej novým\n"
"    \tsoučasným pracovním adresářem.\n"
"    \n"
"    Zásobník adresářů si můžete prohlédnout příkazem „dirs“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný argument a změna adresáře\n"
"    neselhala."

#: builtins.c:1785
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Odebere adresáře ze zásobníku.\n"
"    \n"
"    Odstraní položky ze zásobníku adresářů. Bez argumentů odstraní adresář\n"
"    z vrcholu zásobníku a přepne do nového adresáře na vrchu zásobníku.\n"
"    \n"
"    Přepínače:\n"
"      -n\tPotlačí obvyklou změnu adresáře, když se ze zásobníku odebírají\n"
"    \tadresáře, takže změněn bude pouze zásobník.\n"
"    \n"
"    Argumenty:\n"
"      +N\tOdstraní N. položku počítáno zleva na seznamu zobrazovaném\n"
"    \tpomocí „dirs“, počínaje nulou. Na příklad: „popd +0“ odstraní\n"
"    první adresář, „popd -1“ druhý.\n"
"    \n"
"      -N\tOdstraní N. položku počítáno zprava na seznamu zobrazovaném\n"
"    \tpomocí „dirs“, počínaje nulou. Na příklad: „popd -0“ odstraní\n"
"    poslední adresář, „popd -1“ další vedle posledního.\n"
"    \n"
"    Zásobník adresářů si můžete prohlédnout příkazem „dirs“.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný argument nebo neselhala změna\n"
"    adresáře."

#: builtins.c:1815
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Zobrazí zásobník adresářů.\n"
"    \n"
"    Zobrazí seznam právě pamatovaných adresářů. Adresáře si najdou cestu\n"
"    na seznam příkazem „pushd“ a procházet seznamem zpět lze příkazem "
"„popd“.\n"
"    \n"
"    Přepínače:\n"
"      -c\tvyprázdní zásobník adresářů tím, že smaže všechny jeho prvky\n"
"      -l\tnevypíše vlnkou zkrácené verze adresářů, které jsou relativní\n"
"    \tvašemu domovskému adresáři\n"
"      -p\tvypíše zásobník adresářů po jedné položce na řádek\n"
"      -v\tvypíše zásobník adresářů po jedné položce na řádek, přičemž\n"
"    \tnázvu adresáře předřadí jeho umístění na zásobníku\n"
"    \n"
"    Argumenty:\n"
"      +N\tzobrazí N. položku počítáno zleva na seznamu, který zobrazuje\n"
"    \tdirs, když je vyvolán bez přepínačů, počínaje nulou.\n"
"    \n"
"      -N\tzobrazí N. položku počítáno zprava na seznamu, který zobrazuje\n"
"    \tdirs, když je vyvolán bez přepínačů, počínaje nulou.    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a nevyskytla se chyba."

#: builtins.c:1844
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list all shell options with an indication of whether or not "
"each\n"
"    is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Zapne nebo vypne volby (přepínače) shellu.\n"
"    \n"
"    Změní nastavení každého přepínače shellu NÁZEV_VOLBY. Bez přepínačových\n"
"    argumentů vypíše seznam všech přepínačů shellu s příznakem, zda je, "
"nebo\n"
"    není nastaven.\n"
"    Přepínače:\n"
"      -o\tomezí NÁZVY_VOLEB na ty, které jsou definovány pro použití\n"
"    \ts „set -o“\n"
"      -p\tvypíše každou volbu shellu s určením jejího stavu\n"
"      -q\tpotlačí výstup\n"
"      -s\tzapne (nastaví) každý NÁZEV_VOLBY\n"
"      -u\tvypne (odnastaví) každý NÁZEV_VOLBY\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, je-li NÁZEV_VOLBY zapnut. Selže, byl-li zadán neplatný\n"
"    přepínač nebo je-li NÁZEV_VOLBY vypnut."

#: builtins.c:1865
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: "
"plain\n"
"    characters, which are simply copied to standard output; character "
"escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next "
"successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in printf"
"(1)\n"
"    and printf(3), printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or "
"assignment\n"
"    error occurs."
msgstr ""
"Naformátuje a vypíše ARGUMENTY podle definice FORMÁTU.\n"
"    \n"
"    Přepínače:\n"
"      -v proměnná\tvýstup umístí do proměnné shellu PROMĚNNÁ namísto\n"
"    \t\todeslání na standardní výstup.\n"
"    \n"
"    FORMÁT je řetězec znaků, který obsahuje tři druhy objektů: obyčejné "
"znaky,\n"
"    které jsou prostě zkopírovány na standardní výstup, posloupnosti "
"escapových\n"
"    znaků, které jsou zkonvertovány a zkopírovány na standardní výstup a\n"
"    formátovací definice, z nichž každá způsobí vytištění dalšího "
"argumentu.\n"
"    \n"
"    Tento printf interpretuje vedle standardních formátovacích definic\n"
"    popsaných v printf(1) a printf(3) též:\n"
"    \n"
"      %b\texpanduje posloupnosti escapované zpětným lomítkem\n"
"    \t\tv odpovídajícím argumentu\n"
"      %q\toescapuje argument takovým způsobem, že jej bude možné\n"
"    \t\tpoužít jako vstup shellu\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a nedošlo k chybě\n"
"    zápisu nebo přiřazení."

#: builtins.c:1892
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no "
"options\n"
"    are supplied, existing completion specifications are printed in a way "
"that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \tNAMEs are supplied, all completion specifications\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Určuje, jak budou argumenty doplňovány pomocí knihovny Readline.\n"
"    \n"
"    Pro každý NÁZEV udává, jak se budou doplňovat argumenty. Nejsou-li\n"
"    zadány žádné přepínače, budou vypsány existující pravidla doplňování\n"
"    v podobě vhodné pro jejich znovu užití na vstupu.\n"
"    \n"
"    Přepínače:\n"
"      -p\tvypíše existující pravidla doplňování v znovu použitelném tvaru\n"
"      -r\todstraní pro každý NÁZEV doplňovací pravidlo, nebo není-li zadán\n"
"    \tžádný NÁZEV, zruší všechna pravidla\n"
"    \n"
"    Při doplňování se akce uplatňují v pořadí, v jakém by byla tímto "
"příkazem\n"
"    vypsána pravidla psaná velkými písmeny.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a nevyskytla se chyba."

#: builtins.c:1915
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches "
"against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Zobrazí možná doplnění v závislosti na přepínačích.\n"
"    \n"
"    Je zamýšleno pro použití uvnitř shellových funkcí generujících možná\n"
"    doplnění. Je-li poskytnut volitelný argument SLOVO, budou vygenerovány\n"
"    shody se SLOVEM.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a nevyskytla se chyba."

# FIXME: Příkaz compopt je ve verzi 4.0 zcela nový. Je třeba prozkoumat, co
# přesně dělá, aby bylo možné správně přeložit slovo „option“, tak aby se
# nepletlo s pomlčkovými přepínači příkazu.
# FIXME: Je třeba dohledat msgid pro řádek se syntaxí příkazu a patřičně ji
# opravit.
# TODO: Tento překlad je vemli kostrbatý a místy nedává smysl. Je třeba
# ujednotit pravidlo–pravidla doplnění–doplňování (completion specification).
#: builtins.c:1930
#, fuzzy
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are "
"supplied,\n"
"    the completion currently begin executed.  If no OPTIONs are givenm, "
"print\n"
"    the completion options for each NAME or the current completion "
"specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"Upraví nebo zobrazí možnosti doplňování.\n"
"    \n"
"    Pozmění volby doplňování u každého NÁZVU, nebo, není-li zadán žádný\n"
"    NÁZEV, právě probíhající doplnění. Nejsou-li zadány žádné VOLBY, vypíše\n"
"    volby doplňování pro každý NÁZEV nebo pravidlo současného doplnění.\n"
"    \n"
"    Přepínače:\n"
"    \t-o volba\tNastaví volbu doplňování VOLBA u každého NÁZVU\n"
"    \n"
"    Pomocí „+o“ namísto „-o“ zadanou volbu vypnete.\n"
"    \n"
"    Argumenty:\n"
"    Každý NÁZEV ukazuje na příkaz, pro který pravidlo doplnění musí být\n"
"    předem definováno pomocí vestavěného příkazu „complete“. Nejsou-li "
"zadány\n"
"    žádné NÁZVY, musí být compopt volán funkcí, která právě generuje "
"doplnění,\n"
"    a změněny budou volby tohoto právě běžícího generátoru doplnění.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a NÁZEV již měl\n"
"    definováno pravidlo pro doplnění."

#: builtins.c:1958
#, fuzzy
msgid ""
"Read lines from the standard input into an array variable.\n"
"    \n"
"    Read lines from the standard input into the array variable ARRAY, or "
"from\n"
"    file descriptor FD if the -u option is supplied.  The variable MAPFILE "
"is\n"
"    the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are "
"copied.\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default "
"index is 0.\n"
"      -s count \tDiscard the first COUNT lines read.\n"
"      -t\t\tRemove a trailing newline from each line read.\n"
"      -u fd\t\tRead lines from file descriptor FD instead of the standard "
"input.\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read.\n"
"      -c quantum\tSpecify the number of lines read between each call to "
"CALLBACK.\n"
"    \n"
"    Arguments:\n"
"      ARRAY\t\tArray variable name to use for file data.\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned as an additional argument.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY "
"before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly."
msgstr ""
"Načte řádky ze souboru do proměnné typu pole.\n"
"    \n"
"    Načte řádky ze standardního vstupu nebo z deskriptoru souboru FD, byl-"
"li\n"
"    zadán přepínač -u, do proměnné POLE, která je typu pole. Implicitním "
"POLEM\n"
"    je proměnná MAPFILE.\n"
"    \n"
"    Přepínače:\n"
"      -n počet\tZkopíruje nejvýše POČET řádků. Je-li POČET 0,\n"
"    \t\tzkopíruje všechny řádky.\n"
"      -O počátek\tPřiřazování do POLE začne na indexu POČÁTEK.\n"
"    \t\tImplicitní index je 0.\n"
"      -s počet\tZahodí prvních POČET načtených řádků.\n"
"      -t\t\tOdstraní znaky konce řádku z každého načteného řádku.\n"
"      -u fd\t\tŘádky čte z deskriptoru souboru FD namísto ze\n"
"    \t\tstandardního vstupu.\n"
"      -C volání\tVyhodnotí VOLÁNÍ pokaždé, když je načteno MNOŽSTVÍ\n"
"    \t\třádků.\n"
"      -c množství\tUdává počet řádků, které je třeba přečíst, mezi\n"
"    \t\tkaždým zavoláním VOLÁNÍ.\n"
"    \n"
"    Argumenty:\n"
"      POLE\t\tNázev proměnné typu pole, do které budou přiřazena data\n"
"    \t\tze souboru.\n"
"    \n"
"    Je-li uvedeno -C bez -c, implicitní množství bude 5000.\n"
"    \n"
"    Nebude-li explicitně udán počátek, mapfile vyprázdní POLE před tím,\n"
"    než do něj začne přiřazovat.\n"
"    \n"
"    Návratový kód:\n"
"    Vrátí úspěch, pokud nebyl zadán neplatný přepínač a POLE nebylo jen pro\n"
"    čtení."

#: builtins.c:1990
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""

#~ msgid " "
#~ msgstr " "

#~ msgid "Without EXPR, returns returns \"$line $filename\".  With EXPR,"
#~ msgstr "Bez VÝRAZU vrací „$line $filename“. S VÝRAZEM "

#~ msgid "returns \"$line $subroutine $filename\"; this extra information"
#~ msgstr "vrací „$line $subroutine $filename“. Tyto údaje"

#~ msgid "can be used used to provide a stack trace."
#~ msgstr "lze využít při výpisu zásobníku volání."

#~ msgid ""
#~ "The value of EXPR indicates how many call frames to go back before the"
#~ msgstr "Hodnota VÝRAZ značí, kolik rámců volání se má jít zpět před"

#~ msgid "current one; the top frame is frame 0."
#~ msgstr "současný rámec, vrcholový rámec má číslo 0."

#~ msgid "%s: invalid number"
#~ msgstr "%s: chybné číslo"

#~ msgid "Shell commands matching keywords `"
#~ msgstr "Příkazy shellu shodující se s klíčovými slovy „"

#~ msgid "Display the list of currently remembered directories.  Directories"
#~ msgstr "Zobrazí seznam právě zapamatovaných adresářů. Adresáře"

#~ msgid "find their way onto the list with the `pushd' command; you can get"
#~ msgstr "se na seznam umisťují příkazem „pushd“, předchozí stav seznamu lze"

#~ msgid "back up through the list with the `popd' command."
#~ msgstr "vrátit příkazem „popd“."

#~ msgid ""
#~ "The -l flag specifies that `dirs' should not print shorthand versions"
#~ msgstr "Příznak -l značí, že „dirs“ nemá vypisovat zkrácené verze adresářů,"

#~ msgid ""
#~ "of directories which are relative to your home directory.  This means"
#~ msgstr "které leží pod vaším domovským adresářem. To znamená, že „~/bin“"

#~ msgid "that `~/bin' might be displayed as `/homes/bfox/bin'.  The -v flag"
#~ msgstr "smí být zobrazen jako „/homes/bfox/bin“. Příznak -v způsobí, že"

#~ msgid "causes `dirs' to print the directory stack with one entry per line,"
#~ msgstr ""
#~ "„dirs“ vypíše zásobník adresářů záznam po záznamu na samostatné řádky"

#~ msgid ""
#~ "prepending the directory name with its position in the stack.  The -p"
#~ msgstr "a před název adresáře uvede jeho pořadí v zásobníku. Příznak -p"

#~ msgid "flag does the same thing, but the stack position is not prepended."
#~ msgstr "dělá to samé, ale bez informace o umístění na zásobníku."

#~ msgid ""
#~ "The -c flag clears the directory stack by deleting all of the elements."
#~ msgstr "Příznak -c vyprázdní zásobník smazáním všem prvků."

#~ msgid ""
#~ "+N   displays the Nth entry counting from the left of the list shown by"
#~ msgstr "+N   zobrazí N. položku počítáno zleva na seznamu, který by ukázal"

#~ msgid "     dirs when invoked without options, starting with zero."
#~ msgstr "     příkaz dirs bez jakýchkoliv přepínačů, počítáno od nuly."

#~ msgid ""
#~ "-N   displays the Nth entry counting from the right of the list shown by"
#~ msgstr "-N   zobrazí N. položku počítáno zprava na seznamu, který by ukázal"

#~ msgid "Adds a directory to the top of the directory stack, or rotates"
#~ msgstr ""
#~ "Přidá adresář na vrchol zásobníku adresářů, nebo rotuje zásobník tak,"

#~ msgid "the stack, making the new top of the stack the current working"
#~ msgstr "že nový vrchol zásobníku se stane pracovním adresářem."

#~ msgid "directory.  With no arguments, exchanges the top two directories."
#~ msgstr "Bez argumentů prohodí horní dva adresáře."

#~ msgid "+N   Rotates the stack so that the Nth directory (counting"
#~ msgstr "+N   Zrotuje zásobník tak, že N. adresář (počítáno"

#~ msgid "     from the left of the list shown by `dirs', starting with"
#~ msgstr "     zleva seznamu, který by ukázal „dirs“, počínaje od"

#~ msgid "     zero) is at the top."
#~ msgstr "     nuly) se dostane na vrchol."

#~ msgid "-N   Rotates the stack so that the Nth directory (counting"
#~ msgstr "-N   Zrotuje zásobník tak, že N. adresář (počítáno"

#~ msgid "     from the right of the list shown by `dirs', starting with"
#~ msgstr "     zprava seznamu, který by ukázal „dirs“, počínaje od"

#~ msgid "-n   suppress the normal change of directory when adding directories"
#~ msgstr ""
#~ "-n   potlačí obvyklou změnu pracovního adresáře při přidávání adresářů"

#~ msgid "     to the stack, so only the stack is manipulated."
#~ msgstr "     na zásobník, takže se změní jen obsah zásobníku."

#~ msgid "dir  adds DIR to the directory stack at the top, making it the"
#~ msgstr "adr  přidá ADR na vrchol zásobníku adresářů a učiní jej"

#~ msgid "     new current working directory."
#~ msgstr "     novým pracovním adresářem."

#~ msgid "You can see the directory stack with the `dirs' command."
#~ msgstr "Zásobník adresářů si lze prohlédnout příkazem „dirs“."

#~ msgid "Removes entries from the directory stack.  With no arguments,"
#~ msgstr "Odstraní položky ze zásobníku adresářů. Bez argumentů"

#~ msgid "removes the top directory from the stack, and cd's to the new"
#~ msgstr "odstraní adresář z vrcholu zásobníku a přepne se do nového"

#~ msgid "top directory."
#~ msgstr "vrcholového adresáře."

#~ msgid "+N   removes the Nth entry counting from the left of the list"
#~ msgstr "+N   odstraní N. položku počítáno zleva na seznamu,"

#~ msgid "     shown by `dirs', starting with zero.  For example: `popd +0'"
#~ msgstr "     který by ukázal „dirs“, počínaje nulou. Například „popd +0“"

#~ msgid "     removes the first directory, `popd +1' the second."
#~ msgstr "     odstraní první adresář, „popd +1“ druhý."

#~ msgid "-N   removes the Nth entry counting from the right of the list"
#~ msgstr "-N   odstraní N. položku počítáno zprava na seznamu,"

#~ msgid "     shown by `dirs', starting with zero.  For example: `popd -0'"
#~ msgstr "     který by ukázal „dirs“, počínaje nulou. Například: „popd -0“"

#~ msgid "     removes the last directory, `popd -1' the next to last."
#~ msgstr "     odstraní poslední adresář, “popd -1“ předposlední."

#~ msgid ""
#~ "-n   suppress the normal change of directory when removing directories"
#~ msgstr ""
#~ "-n   potlačí obvyklou změnu pracovního adresáře při odebírání adresářů"

#~ msgid "     from the stack, so only the stack is manipulated."
#~ msgstr "     ze zásobníku, takže pouze zásobník dozná změny."

#~ msgid "allocated"
#~ msgstr "alokováno"

#~ msgid "freed"
#~ msgstr "uvolněno"

#~ msgid "requesting resize"
#~ msgstr "požadující velikost"

#~ msgid "just resized"
#~ msgstr "právě změněna velikost"

#~ msgid "bug: unknown operation"
#~ msgstr "chyba: neznámá operace"

#~ msgid "malloc: watch alert: %p %s "
#~ msgstr "malloc: výstraha sledování: %p %s"

#~ msgid ""
#~ "Exit from within a FOR, WHILE or UNTIL loop.  If N is specified,\n"
#~ "    break N levels."
#~ msgstr ""
#~ "Ukončí smyčku FOR, WHILE nebo UNTIL. Je-li zadáno N, ukončí N úrovní."

#~ msgid ""
#~ "Run a shell builtin.  This is useful when you wish to rename a\n"
#~ "    shell builtin to be a function, but need the functionality of the\n"
#~ "    builtin within the function itself."
#~ msgstr ""
#~ "Spustí vestavěný příkaz shellu. Toto se hodí, přejete-li si přejmenovat\n"
#~ "    vestavěný příkaz na funkci, avšak funkcionalitu vestavěného příkazu\n"
#~ "    potřebujete v téže funkci."

#~ msgid ""
#~ "Print the current working directory.  With the -P option, pwd prints\n"
#~ "    the physical directory, without any symbolic links; the -L option\n"
#~ "    makes pwd follow symbolic links."
#~ msgstr ""
#~ "Vypíše současný pracovní adresář. S přepínačem -P vypíše pwd fyzický\n"
#~ "    adresář prostý všech symbolický odkazů; přepínač -L přinutí pwd\n"
#~ "    následovat symbolické odkazy."

#~ msgid "Return a successful result."
#~ msgstr "Vrací výsledek úspěchu."

#~ msgid ""
#~ "Runs COMMAND with ARGS ignoring shell functions.  If you have a shell\n"
#~ "    function called `ls', and you wish to call the command `ls', you can\n"
#~ "    say \"command ls\".  If the -p option is given, a default value is "
#~ "used\n"
#~ "    for PATH that is guaranteed to find all of the standard utilities.  "
#~ "If\n"
#~ "    the -V or -v option is given, a string is printed describing "
#~ "COMMAND.\n"
#~ "    The -V option produces a more verbose description."
#~ msgstr ""
#~ "Spustí PŘÍKAZ s ARGUMENTY ignoruje funkce shellu. Máte-li shellovou\n"
#~ "    funkci pojmenovanou „ls“, a chcete-li zavolat příkaz „ls“, použijte\n"
#~ "    „command ls“. Je-li zadán přepínač -p, bude pro PATH použita "
#~ "implicitní\n"
#~ "    hodnota, která zaručuje, že budou nalezeny všechny standardní "
#~ "nástroje.\n"
#~ "    Je-li zadán přepínač -V nebo -v, bude vytištěn řetězec popisující "
#~ "PŘÍKAZ.\n"
#~ "    Přepínač -V produkuje podrobnější popis."

#~ msgid ""
#~ "Declare variables and/or give them attributes.  If no NAMEs are\n"
#~ "    given, then display the values of variables instead.  The -p option\n"
#~ "    will display the attributes and values of each NAME.\n"
#~ "    \n"
#~ "    The flags are:\n"
#~ "    \n"
#~ "      -a\tto make NAMEs arrays (if supported)\n"
#~ "      -f\tto select from among function names only\n"
#~ "      -F\tto display function names (and line number and source file name "
#~ "if\n"
#~ "    \tdebugging) without definitions\n"
#~ "      -i\tto make NAMEs have the `integer' attribute\n"
#~ "      -r\tto make NAMEs readonly\n"
#~ "      -t\tto make NAMEs have the `trace' attribute\n"
#~ "      -x\tto make NAMEs export\n"
#~ "    \n"
#~ "    Variables with the integer attribute have arithmetic evaluation (see\n"
#~ "    `let') done when the variable is assigned to.\n"
#~ "    \n"
#~ "    When displaying values of variables, -f displays a function's name\n"
#~ "    and definition.  The -F option restricts the display to function\n"
#~ "    name only.\n"
#~ "    \n"
#~ "    Using `+' instead of `-' turns off the given attribute instead.  "
#~ "When\n"
#~ "    used in a function, makes NAMEs local, as with the `local' command."
#~ msgstr ""
#~ "Deklaruje proměnné a/nebo jim nastaví atributy. Nejsou-li zadány NÁZVY,\n"
#~ "    tak místo toho zobrazí hodnoty proměnných. Přepínač -p zobrazí "
#~ "atributy\n"
#~ "    a hodnoty pro každý NÁZEV.\n"
#~ "    \n"
#~ "    Příznaky jsou:\n"
#~ "    \n"
#~ "      -a\tučiní NÁZVY poli (je-li podporováno)\n"
#~ "      -f\tvybírá pouze mezi názvy funkcí\n"
#~ "      -F\tzobrazí názvy funkcí (a číslo řádku a název zdrojového "
#~ "souboru,\n"
#~ "        \tje-li zapnuto ladění) bez definic\n"
#~ "      -i\tpřiřadí NÁZVŮM atribut „integer“ (číslo)\n"
#~ "      -r\tučiní NÁZVY jen pro čtení\n"
#~ "      -t\tpřiřadí NÁZVŮM atribut „trace“ (sledování)\n"
#~ "      -x\tvyexportuje NÁZVY\n"
#~ "    \n"
#~ "    Proměnné s atributem integer jsou aritmeticky vyhodnoceny (vizte "
#~ "„let“),\n"
#~ "    když je do proměnné přiřazováno.\n"
#~ "    \n"
#~ "    Při zobrazování hodnot proměnných -f zobrazí názvy a definice "
#~ "funkcí.\n"
#~ "    Přepínač -F omezí výpis jen na názvy funkcí.\n"
#~ "    \n"
#~ "    Pomocí „+“ namísto „-“ daný atribut odeberete. Je-li použito uvnitř\n"
#~ "    funkce, učiní NÁZVY lokální stejně jako příkaz „local“."

#~ msgid "Obsolete.  See `declare'."
#~ msgstr "Zastaralé. Vizte „declare“."

#~ msgid ""
#~ "Create a local variable called NAME, and give it VALUE.  LOCAL\n"
#~ "    can only be used within a function; it makes the variable NAME\n"
#~ "    have a visible scope restricted to that function and its children."
#~ msgstr ""
#~ "Vytvoří lokální proměnnou pojmenovanou NÁZEV a přiřadí jí HODNOTU.\n"
#~ "    LOCAL smí být použito jen uvnitř funkcí. Učiní proměnnou NÁZEV "
#~ "viditelnou\n"
#~ "    jen v dané funkci a jejích potomcích."

#~ msgid ""
#~ "Output the ARGs.  If -n is specified, the trailing newline is suppressed."
#~ msgstr ""
#~ "Vypíše ARGUMENTY. Je-li zadáni -n, závěrečný konec řádku bude potlačen."

#~ msgid ""
#~ "Enable and disable builtin shell commands.  This allows\n"
#~ "    you to use a disk command which has the same name as a shell\n"
#~ "    builtin without specifying a full pathname.  If -n is used, the\n"
#~ "    NAMEs become disabled; otherwise NAMEs are enabled.  For example,\n"
#~ "    to use the `test' found in $PATH instead of the shell builtin\n"
#~ "    version, type `enable -n test'.  On systems supporting dynamic\n"
#~ "    loading, the -f option may be used to load new builtins from the\n"
#~ "    shared object FILENAME.  The -d option will delete a builtin\n"
#~ "    previously loaded with -f.  If no non-option names are given, or\n"
#~ "    the -p option is supplied, a list of builtins is printed.  The\n"
#~ "    -a option means to print every builtin with an indication of whether\n"
#~ "    or not it is enabled.  The -s option restricts the output to the "
#~ "POSIX.2\n"
#~ "    `special' builtins.  The -n option displays a list of all disabled "
#~ "builtins."
#~ msgstr ""
#~ "Povolí nebo zakáže vestavěný příkaz shellu. To vám umožňuje použít\n"
#~ "    příkaz z disku, který má stejné jméno jako vestavěný příkaz shellu, "
#~ "aniž\n"
#~ "    byste museli zadávat celou cestu. Je-li použito -n, NÁZVY se stanou\n"
#~ "    zakázanými, jinak budou povoleny. Například „test“ z PATH namísto "
#~ "verze\n"
#~ "    vestavěné do shellu lze používat tak, že napíšete „enable -n test“. "
#~ "Na\n"
#~ "    systémech podporujících dynamické zavádění přepínač -f může být "
#~ "použit\n"
#~ "    pro zavedení nových vestavěných příkazů ze sdíleného objektu "
#~ "NÁZEV_SOUBORU.\n"
#~ "    Přepínač -d odstraní vestavěný příkaz zavedený přes -f. Není-li "
#~ "zadán\n"
#~ "    žádný přepínač nebo je-li zadán přepínač -p, bude vypsán seznam "
#~ "vestavěných\n"
#~ "    příkazů. Přepínač -a znamená, že budou vypsány všechny vestavěné "
#~ "příkazy a\n"
#~ "    u každého bude vyznačeno, zda je povolen nebo zakázán. Přepínač -s "
#~ "omezí\n"
#~ "    výpis na příkazy uvedené v POSIX.2. Přepínač -n zobrazí seznam všech\n"
#~ "    zakázaných vestavěných příkazů."

#~ msgid ""
#~ "Read ARGs as input to the shell and execute the resulting command(s)."
#~ msgstr "Načte ARGUMENTY jako vstup shellu a výsledný příkaz(y) provede."

#~ msgid ""
#~ "Exec FILE, replacing this shell with the specified program.\n"
#~ "    If FILE is not specified, the redirections take effect in this\n"
#~ "    shell.  If the first argument is `-l', then place a dash in the\n"
#~ "    zeroth arg passed to FILE, as login does.  If the `-c' option\n"
#~ "    is supplied, FILE is executed with a null environment.  The `-a'\n"
#~ "    option means to make set argv[0] of the executed process to NAME.\n"
#~ "    If the file cannot be executed and the shell is not interactive,\n"
#~ "    then the shell exits, unless the shell option `execfail' is set."
#~ msgstr ""
#~ "Provede SOUBOR, přičemž nahradí tento shell zadaným programem.\n"
#~ "    Není-li SOUBOR zadán, přesměrování zapůsobí v tomto shellu. Je-li "
#~ "prvním\n"
#~ "    argumentem „-l“, bude do nultého argumentu SOUBORU umístěna pomlčka "
#~ "tak,\n"
#~ "    jak to dělá login. Je-li zadán přepínač „-c“, bude SOUBOR spuštěn\n"
#~ "    s prázdným prostředím. Přepínač „-a“ znamená, že argv[0] prováděného\n"
#~ "    procesu bude nastaven na NÁZEV. Pokud soubor nemůže být proveden a "
#~ "shell\n"
#~ "    není interaktivní, pak shell bude ukončen, pokud přepínač shellu\n"
#~ "    „execfail“ není nastaven."

#~ msgid "Logout of a login shell."
#~ msgstr "Odhlásí z přihlašovacího (login) shellu."

#~ msgid ""
#~ "For each NAME, the full pathname of the command is determined and\n"
#~ "    remembered.  If the -p option is supplied, PATHNAME is used as the\n"
#~ "    full pathname of NAME, and no path search is performed.  The -r\n"
#~ "    option causes the shell to forget all remembered locations.  The -d\n"
#~ "    option causes the shell to forget the remembered location of each "
#~ "NAME.\n"
#~ "    If the -t option is supplied the full pathname to which each NAME\n"
#~ "    corresponds is printed.  If multiple NAME arguments are supplied "
#~ "with\n"
#~ "    -t, the NAME is printed before the hashed full pathname.  The -l "
#~ "option\n"
#~ "    causes output to be displayed in a format that may be reused as "
#~ "input.\n"
#~ "    If no arguments are given, information about remembered commands is "
#~ "displayed."
#~ msgstr ""
#~ "Pro každý NÁZEV je určena plná cesta k příkazu a je zapamatována.\n"
#~ "    Za použití přepínače -p se vezme NÁZEV_CESTY za plnou cestu k NÁZVU "
#~ "a\n"
#~ "    žádné vyhledávání cesty se nekoná. Přepínač -r způsobí, že shell "
#~ "zapomene\n"
#~ "    všechny zapamatovaná umístění. Přepínač -d způsobí, že shell "
#~ "zapomene\n"
#~ "    zapamatovaná umístění každého NÁZVU. Je-li zadán přepínač -t, bude "
#~ "vypsána\n"
#~ "    plná cesta ke každému NÁZVU. Je-li s -t zadáno více NÁZVŮ, NÁZEV "
#~ "bude\n"
#~ "    vypsán před uloženou celou cestou. Přepínač -l vytvoří takový "
#~ "výstup,\n"
#~ "    který lze opět použít jako vstup. Nejsou-li zadány žádné argumenty,\n"
#~ "    budou vypsány informace o zapamatovaných příkazech."

#~ msgid ""
#~ "Display helpful information about builtin commands.  If PATTERN is\n"
#~ "    specified, gives detailed help on all commands matching PATTERN,\n"
#~ "    otherwise a list of the builtins is printed.  The -s option\n"
#~ "    restricts the output for each builtin command matching PATTERN to\n"
#~ "    a short usage synopsis."
#~ msgstr ""
#~ "Zobrazí užitečné informace o vestavěných příkazech. Je-li zadán VZOREK,\n"
#~ "    vrátí podrobnou nápovědu ke všem příkazům odpovídajícím VZORKU, jinak "
#~ "je\n"
#~ "    vytištěn seznam vestavěných příkazů. Přepínač -s omezí výstup "
#~ "o každém\n"
#~ "    vestavěném příkazu odpovídajícího VZORKU na stručný popis použití."

#~ msgid ""
#~ "By default, removes each JOBSPEC argument from the table of active jobs.\n"
#~ "    If the -h option is given, the job is not removed from the table, but "
#~ "is\n"
#~ "    marked so that SIGHUP is not sent to the job if the shell receives a\n"
#~ "    SIGHUP.  The -a option, when JOBSPEC is not supplied, means to remove "
#~ "all\n"
#~ "    jobs from the job table; the -r option means to remove only running "
#~ "jobs."
#~ msgstr ""
#~ "Implicitně odstraní každý argument ÚLOHA z tabulky aktivních úloh. Je-li\n"
#~ "    zadán přepínač -h, úloha není odstraněna z tabulky, ale je označena "
#~ "tak.\n"
#~ "    že úloze nebude zaslán SIGHUP, když shell obdrží SIGHUP. Přepínač -"
#~ "a,\n"
#~ "    pokud není uvedena ÚLOHA, znamená, že všechny úlohy budou odstraněny\n"
#~ "    z tabulky úloh. Přepínač -r znamená, že pouze běžící úlohy budou\n"
#~ "    odstraněny."

#~ msgid ""
#~ "Causes a function to exit with the return value specified by N.  If N\n"
#~ "    is omitted, the return status is that of the last command."
#~ msgstr ""
#~ "Způsobí ukončení funkce s návratovou hodnotou uvedenou v N. Je-li\n"
#~ "    N vynecháno, návratový kód je roven poslednímu příkazu."

#~ msgid ""
#~ "For each NAME, remove the corresponding variable or function.  Given\n"
#~ "    the `-v', unset will only act on variables.  Given the `-f' flag,\n"
#~ "    unset will only act on functions.  With neither flag, unset first\n"
#~ "    tries to unset a variable, and if that fails, then tries to unset a\n"
#~ "    function.  Some variables cannot be unset; also see readonly."
#~ msgstr ""
#~ "Pro každé JMÉNO odstraní odpovídající proměnnou nebo funkci.\n"
#~ "    Spolu s „-v“ bude unset fungovat jen na proměnné. S příznakem „-f“ "
#~ "bude\n"
#~ "    unset fungovat jen na funkce. Bez těchto dvou příznaků unset nejprve "
#~ "zkusí\n"
#~ "    zrušit proměnnou a pokud toto selže, tak zkusí zrušit funkci. "
#~ "Některé\n"
#~ "    proměnné nelze odstranit. Taktéž vizte příkaz „readonly“."

#~ msgid ""
#~ "NAMEs are marked for automatic export to the environment of\n"
#~ "    subsequently executed commands.  If the -f option is given,\n"
#~ "    the NAMEs refer to functions.  If no NAMEs are given, or if `-p'\n"
#~ "    is given, a list of all names that are exported in this shell is\n"
#~ "    printed.  An argument of `-n' says to remove the export property\n"
#~ "    from subsequent NAMEs.  An argument of `--' disables further option\n"
#~ "    processing."
#~ msgstr ""
#~ "NÁZVY jsou označeny pro automatické exportování do prostředí následně\n"
#~ "    prováděných příkazů. Je-li zadán přepínač -f, NÁZVY se vztahují "
#~ "k funkcím.\n"
#~ "    Nejsou-li zadány žádné NÁZVY nebo je-li zadáno „-p“, bude vytištěn "
#~ "seznam\n"
#~ "    všech názvů, které jsou v tomto shellu exportovány. Argument „-n“ "
#~ "nařizuje\n"
#~ "    odstranit vlastnost exportovat z následujících NÁZVŮ. Argument „--“\n"
#~ "    zakazuje zpracování dalších přepínačů."

#~ msgid ""
#~ "The given NAMEs are marked readonly and the values of these NAMEs may\n"
#~ "    not be changed by subsequent assignment.  If the -f option is given,\n"
#~ "    then functions corresponding to the NAMEs are so marked.  If no\n"
#~ "    arguments are given, or if `-p' is given, a list of all readonly "
#~ "names\n"
#~ "    is printed.  The `-a' option means to treat each NAME as\n"
#~ "    an array variable.  An argument of `--' disables further option\n"
#~ "    processing."
#~ msgstr ""
#~ "Zadané NÁZVY budou označeny jako jen pro čtení a hodnoty těchto NÁZVŮ\n"
#~ "    nebude možné změnit následným přiřazením. Je-li zadán přepínač -f, "
#~ "pak\n"
#~ "    funkce těchto NÁZVŮ budou takto označeny. Nejsou-li zadány žádné "
#~ "argumenty\n"
#~ "    nebo je-li zadáno „-p“, bude vytištěn seznam všech jmen jen pro "
#~ "čtení.\n"
#~ "    Přepínač „-a“ znamená, že s každým NÁZVEM bude zacházeno jako "
#~ "s proměnnou\n"
#~ "    typu pole. Argument „--“ zakáže zpracování dalších přepínačů."

#~ msgid ""
#~ "The positional parameters from $N+1 ... are renamed to $1 ...  If N is\n"
#~ "    not given, it is assumed to be 1."
#~ msgstr ""
#~ "Poziční parametry budou přejmenovány z $N+1 na $1 atd. Není-li N zadáno,\n"
#~ "    předpokládá se 1."

#~ msgid ""
#~ "Suspend the execution of this shell until it receives a SIGCONT\n"
#~ "    signal.  The `-f' if specified says not to complain about this\n"
#~ "    being a login shell if it is; just suspend anyway."
#~ msgstr ""
#~ "Pozastaví provádění tohoto shellu do doby, něž bude obdržen signál\n"
#~ "    SIGCONT. „-f“, je-li zadán, potlačí stížnost na to, že se jedná\n"
#~ "    o přihlašovací shell (pokud tomu tak je), a prostě pozastaví činnost."

#~ msgid ""
#~ "Print the accumulated user and system times for processes run from\n"
#~ "    the shell."
#~ msgstr ""
#~ "Vypíše celkovou dobu procesu spuštěného z shellu, kterou strávil\n"
#~ "    v uživatelském a jaderném (system) prostoru."

#~ msgid ""
#~ "For each NAME, indicate how it would be interpreted if used as a\n"
#~ "    command name.\n"
#~ "    \n"
#~ "    If the -t option is used, `type' outputs a single word which is one "
#~ "of\n"
#~ "    `alias', `keyword', `function', `builtin', `file' or `', if NAME is "
#~ "an\n"
#~ "    alias, shell reserved word, shell function, shell builtin, disk "
#~ "file,\n"
#~ "    or unfound, respectively.\n"
#~ "    \n"
#~ "    If the -p flag is used, `type' either returns the name of the disk\n"
#~ "    file that would be executed, or nothing if `type -t NAME' would not\n"
#~ "    return `file'.\n"
#~ "    \n"
#~ "    If the -a flag is used, `type' displays all of the places that "
#~ "contain\n"
#~ "    an executable named `file'.  This includes aliases, builtins, and\n"
#~ "    functions, if and only if the -p flag is not also used.\n"
#~ "    \n"
#~ "    The -f flag suppresses shell function lookup.\n"
#~ "    \n"
#~ "    The -P flag forces a PATH search for each NAME, even if it is an "
#~ "alias,\n"
#~ "    builtin, or function, and returns the name of the disk file that "
#~ "would\n"
#~ "    be executed."
#~ msgstr ""
#~ "O každém NÁZVU řekne, jak by byl interpretován, kdyby byl použit jako\n"
#~ "    název příkazu.\n"
#~ "    \n"
#~ "    Je-li použit přepínač -t, „type“ vypíše jedno slovo z těchto: "
#~ "„alias“,\n"
#~ "    „keyword“, „function“, „builtin“, „file“ nebo „“, je-li NÁZEV alias,\n"
#~ "    klíčové slovo shellu, shellová funkce, vestavěný příkaz shellu, "
#~ "soubor\n"
#~ "    na disku nebo nenalezený soubor.\n"
#~ "    \n"
#~ "    Je-li použit přepínač -p, „type“ buď vrátí jméno souboru na disku, "
#~ "který\n"
#~ "    by byl spuštěn, nebo nic, pokud „type -t NÁZEV“ by nevrátil „file“.\n"
#~ "    \n"
#~ "    Je-li použit přepínač -a, „type“ zobrazí všechna místa, kde se "
#~ "nalézá\n"
#~ "    spustitelný program pojmenovaný „soubor“. To zahrnuje aliasy, "
#~ "vestavěné\n"
#~ "    příkazy a funkce jen a pouze tehdy, když není rovněž použit přepínač -"
#~ "p.\n"
#~ "    \n"
#~ "    Přepínač -f potlačí hledání mezi funkcemi shellu.\n"
#~ "    \n"
#~ "    Přepínač -P vynutí prohledání PATH na každý NÁZEV, dokonce i když se\n"
#~ "    jedná o alias, vestavěný příkaz nebo funkci, a vrátí název souboru "
#~ "na\n"
#~ "    disku, který by byl spuštěn."

#~ msgid ""
#~ "The user file-creation mask is set to MODE.  If MODE is omitted, or if\n"
#~ "    `-S' is supplied, the current value of the mask is printed.  The `-"
#~ "S'\n"
#~ "    option makes the output symbolic; otherwise an octal number is "
#~ "output.\n"
#~ "    If `-p' is supplied, and MODE is omitted, the output is in a form\n"
#~ "    that may be used as input.  If MODE begins with a digit, it is\n"
#~ "    interpreted as an octal number, otherwise it is a symbolic mode "
#~ "string\n"
#~ "    like that accepted by chmod(1)."
#~ msgstr ""
#~ "Uživatelská maska práv vytvářených souborů je nastavena na MÓD. Je-li\n"
#~ "    MÓD vynechán nebo je-li uvedeno „-S“, bude vytištěna současná "
#~ "hodnota\n"
#~ "    masky. Přepínač „-S“ učiní výstup symbolický, jinak bude výstupem\n"
#~ "    osmičkové číslo. Je-li zadáno „-p“ a MÓD je vynechán, bude výstup ve\n"
#~ "    formátu, který lze použít jako vstup. Začíná-li MÓD číslicí, bude\n"
#~ "    interpretován jako osmičkové číslo, jinak jako řetězec symbolického "
#~ "zápisu\n"
#~ "    práv tak, jak jej chápe chmod(1)."

#~ msgid ""
#~ "Wait for the specified process and report its termination status.  If\n"
#~ "    N is not given, all currently active child processes are waited for,\n"
#~ "    and the return code is zero.  N is a process ID; if it is not given,\n"
#~ "    all child processes of the shell are waited for."
#~ msgstr ""
#~ "Počká na zadaný proces a nahlásí jeho návratový kód. Není-li N zadáno,\n"
#~ "    bude se čekat na všechny právě aktivní procesy potomků a návratová "
#~ "hodnota\n"
#~ "    bude nula. N je ID procesu. Není-li zadáno, bude se čekat na všechny\n"
#~ "    procesy potomků tohoto shellu."

#~ msgid ""
#~ "Create a simple command invoked by NAME which runs COMMANDS.\n"
#~ "    Arguments on the command line along with NAME are passed to the\n"
#~ "    function as $0 .. $n."
#~ msgstr ""
#~ "Vytvoří jednoduchý příkaz volaný JMÉNEM, který spustí PŘÍKAZY. Argumenty\n"
#~ "    z příkazové řádky spolu se JMÉNEM budou předány do funkce jako $0…$n."

#~ msgid ""
#~ "Toggle the values of variables controlling optional behavior.\n"
#~ "    The -s flag means to enable (set) each OPTNAME; the -u flag\n"
#~ "    unsets each OPTNAME.  The -q flag suppresses output; the exit\n"
#~ "    status indicates whether each OPTNAME is set or unset.  The -o\n"
#~ "    option restricts the OPTNAMEs to those defined for use with\n"
#~ "    `set -o'.  With no options, or with the -p option, a list of all\n"
#~ "    settable options is displayed, with an indication of whether or\n"
#~ "    not each is set."
#~ msgstr ""
#~ "Přepne hodnoty proměnných řídící volitelné chování. Přepínač -s znamená,\n"
#~ "    že se každý NÁZEV_VOLBY zapne (nastaví). Přepínač -u každý "
#~ "NÁZEV_VOLBY\n"
#~ "    vypne. Přepínač -q potlačí výstup. Zda je nebo není nastaven každý\n"
#~ "    NÁZEV_VOLBY, indikuje návratový kód. Přepínač -o omezí NÁZVY_VOLEB na "
#~ "ty,\n"
#~ "    které jsou definovány pro použití s „set -o“. Bez přepínačů nebo\n"
#~ "    s přepínačem -p je zobrazen seznam všech nastavitelných voleb včetně\n"
#~ "    indikace, zda je každá nastavena."

#~ msgid ""
#~ "For each NAME, specify how arguments are to be completed.\n"
#~ "    If the -p option is supplied, or if no options are supplied, "
#~ "existing\n"
#~ "    completion specifications are printed in a way that allows them to "
#~ "be\n"
#~ "    reused as input.  The -r option removes a completion specification "
#~ "for\n"
#~ "    each NAME, or, if no NAMEs are supplied, all completion "
#~ "specifications."
#~ msgstr ""
#~ "U každého NÁZVU sdělí, jak budou argumenty doplněny. Je-li zadán\n"
#~ "    přepínač -p nebo není-li zadán přepínač žádný, budou existující "
#~ "definice\n"
#~ "    doplňování vytištěny tak. že je bude možné znovu použít jako vstup.\n"
#~ "    Přepínač -r odstraní definici doplnění pro každý NÁZEV nebo chybí-li "
#~ "NÁZVY,\n"
#~ "    odstraní všechny definice."
