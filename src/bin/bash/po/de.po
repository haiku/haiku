# German language file for GNU Bash 4.0
# Copyright (C) 1996 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Nils Naumann <nnau@gmx.net>, 1996, 2008.
msgid ""
msgstr ""
"Project-Id-Version: bash 4.0-pre1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2009-02-19 14:53-0500\n"
"PO-Revision-Date: 2008-12-20 16:56+0100\n"
"Last-Translator: Nils Naumann <nnau@gmx.net>\n"
"Language-Team: German <translation-team-de@lists.sourceforge.net>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"

#: arrayfunc.c:50
msgid "bad array subscript"
msgstr "Falscher Feldbezeichner."

#: arrayfunc.c:313 builtins/declare.def:474
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: Kann nicht das indizierte in ein assoziatives Array umwandeln."

#: arrayfunc.c:479
#, c-format
msgid "%s: invalid associative array key"
msgstr "%s: Ungültiger Schlüssel für das assoziative Array."

#: arrayfunc.c:481
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: Kann nicht auf einen nicht-numerischen Index zuweisen."

#: arrayfunc.c:517
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr ""

#: bashhist.c:379
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: Kann die Datei %s nicht erzeugen."

#: bashline.c:3413
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr ""

#: bashline.c:3491
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: Das erste nicht Leerzeichen ist nicht `\\'."

#: bashline.c:3520
#, c-format
msgid "no closing `%c' in %s"
msgstr "fehlende schließende `%c' in %s."

#: bashline.c:3554
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: Fehlender Doppelpunkt."

#: builtins/bind.def:120 builtins/bind.def:123
msgid "line editing not enabled"
msgstr ""

#: builtins/bind.def:206
#, c-format
msgid "`%s': invalid keymap name"
msgstr "`%s': Ungültiger KEYMAP Name."

#: builtins/bind.def:245
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: Nicht lesbar: %s"

#: builtins/bind.def:260
#, c-format
msgid "`%s': cannot unbind"
msgstr "`%s': Bindung kann nicht gelöst werden."

#: builtins/bind.def:295 builtins/bind.def:325
#, c-format
msgid "`%s': unknown function name"
msgstr "%s: Unbekannter Funktionsname."

#: builtins/bind.def:303
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s ist keiner Taste zugeordnet.\n"

#: builtins/bind.def:307
#, c-format
msgid "%s can be invoked via "
msgstr "%s kann aufgerufen werden durch "

#: builtins/break.def:77 builtins/break.def:117
msgid "loop count"
msgstr "Schleifen Zähler"

#: builtins/break.def:137
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "nur in einer `for', `while' oder `until' Schleife sinnvoll."

#: builtins/caller.def:133
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns "
msgstr ""

#: builtins/cd.def:215
msgid "HOME not set"
msgstr "HOME ist nicht zugewiesen."

#: builtins/cd.def:227
msgid "OLDPWD not set"
msgstr "OLDPWD ist nicht zugewiesen."

# Debug Ausgabe
#: builtins/common.c:101
#, c-format
msgid "line %d: "
msgstr "Zeile %d: "

#: builtins/common.c:139 error.c:260
#, c-format
msgid "warning: "
msgstr "Warnung: "

#: builtins/common.c:153
#, c-format
msgid "%s: usage: "
msgstr "%s: Gebrauch: "

#: builtins/common.c:166 test.c:822
msgid "too many arguments"
msgstr "Zu viele Argumente."

#: builtins/common.c:191 shell.c:493 shell.c:774
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: Ein numerischer Paremeter ist erforderlich."

#: builtins/common.c:198
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: Ein numerischer Parameter ist erforderlich."

#: builtins/common.c:205
#, c-format
msgid "%s: not found"
msgstr "%s: Nicht gefunden."

#: builtins/common.c:214 shell.c:787
#, c-format
msgid "%s: invalid option"
msgstr "%s: Ungültige Option"

#: builtins/common.c:221
#, c-format
msgid "%s: invalid option name"
msgstr "%s: Ungültiger Optionsname."

#: builtins/common.c:228 general.c:231 general.c:236
#, c-format
msgid "`%s': not a valid identifier"
msgstr "`%s': Ist kein gültiger Bezeichner."

#: builtins/common.c:238
msgid "invalid octal number"
msgstr "Ungültige Oktalzahl."

#: builtins/common.c:240
msgid "invalid hex number"
msgstr "Ungültige hexadezimale Zahl."

#: builtins/common.c:242 expr.c:1255
msgid "invalid number"
msgstr "Ungültige Zahl."

#: builtins/common.c:250
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: Ungültige Signalbezeichnung."

#: builtins/common.c:257
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "`%s': Ist keine gültige Prozess- oder Jobbezeichnung."

#: builtins/common.c:264 error.c:453
#, c-format
msgid "%s: readonly variable"
msgstr "%s: Schreibgeschützte Variable."

#: builtins/common.c:272
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s ist außerhalb des Gültigkeitsbereiches."

#: builtins/common.c:272 builtins/common.c:274
msgid "argument"
msgstr "Argument"

#: builtins/common.c:274
#, c-format
msgid "%s out of range"
msgstr "%s ist außerhalb des Gültigkeitsbereiches."

#: builtins/common.c:282
#, c-format
msgid "%s: no such job"
msgstr "%s: Kein solche Job."

#: builtins/common.c:290
#, c-format
msgid "%s: no job control"
msgstr "%s: Keine Job Steuerung in dieser Shell."

#: builtins/common.c:292
msgid "no job control"
msgstr "Keine Job Steuerung in dieser Shell."

#: builtins/common.c:302
#, c-format
msgid "%s: restricted"
msgstr "%s: gesperrt"

#: builtins/common.c:304
msgid "restricted"
msgstr "gesperrt"

#: builtins/common.c:312
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: Ist kein Shell Kommando."

#: builtins/common.c:321
#, c-format
msgid "write error: %s"
msgstr "Schreibfehler: %s."

#: builtins/common.c:329
#, c-format
msgid "error setting terminal attributes: %s"
msgstr ""

#: builtins/common.c:331
#, c-format
msgid "error getting terminal attributes: %s"
msgstr ""

#: builtins/common.c:563
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: Kann das nicht aktuelle Verzeichnis wiederfinden: %s: %s\n"

#: builtins/common.c:629 builtins/common.c:631
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: Mehrdeutige Job Bezeichnung."

#: builtins/complete.def:270
#, c-format
msgid "%s: invalid action name"
msgstr ""

#: builtins/complete.def:430 builtins/complete.def:615
#: builtins/complete.def:813
#, c-format
msgid "%s: no completion specification"
msgstr ""

#: builtins/complete.def:667
msgid "warning: -F option may not work as you expect"
msgstr "Warnung: Die -F Option könnte unerwartete Ergebnisse liefern."

#: builtins/complete.def:669
msgid "warning: -C option may not work as you expect"
msgstr "Warnung: Die -C Option könnte unerwartete Ergebnisse liefern."

#: builtins/complete.def:786
msgid "not currently executing completion function"
msgstr ""

#: builtins/declare.def:122
msgid "can only be used in a function"
msgstr "kann nur innerhalb einer Funktion benutzt werden."

#: builtins/declare.def:353
msgid "cannot use `-f' to make functions"
msgstr "Mit `-f' können keine Funktionen erzeugt werden."

#: builtins/declare.def:365 execute_cmd.c:4818
#, c-format
msgid "%s: readonly function"
msgstr "%s: Schreibgeschützte Funktion."

#: builtins/declare.def:461
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: Kann Feldvariablen nicht auf diese Art löschen."

#: builtins/declare.def:468
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr ""

#: builtins/enable.def:137 builtins/enable.def:145
msgid "dynamic loading not available"
msgstr ""

#: builtins/enable.def:312
#, c-format
msgid "cannot open shared object %s: %s"
msgstr ""

#: builtins/enable.def:335
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr ""

#: builtins/enable.def:459
#, c-format
msgid "%s: not dynamically loaded"
msgstr ""

#: builtins/enable.def:474
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: Kann nicht löschen: %s"

#: builtins/evalfile.c:134 builtins/hash.def:169 execute_cmd.c:4675
#: shell.c:1439
#, c-format
msgid "%s: is a directory"
msgstr "%s: ist ein Verzeichnis."

#: builtins/evalfile.c:139
#, c-format
msgid "%s: not a regular file"
msgstr "%s: Ist keine normale Datei."

#: builtins/evalfile.c:147
#, c-format
msgid "%s: file is too large"
msgstr "%s: Die Datei ist zu groß."

#: builtins/evalfile.c:185 execute_cmd.c:4745 shell.c:1449
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: Kann die Datei nicht ausführen."

#: builtins/exec.def:212
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: Kann nicht ausführen: %s"

#: builtins/exit.def:65
#, c-format
msgid "logout\n"
msgstr "Abgemeldet\n"

#: builtins/exit.def:88
msgid "not login shell: use `exit'"
msgstr "Keine Login Shell: Mit exit abmelden."

#: builtins/exit.def:120
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Es gibt noch angehaltene Prozesse.\n"

#: builtins/exit.def:122
#, c-format
msgid "There are running jobs.\n"
msgstr "Es gibt noch laufende Prozesse.\n"

#: builtins/fc.def:261
msgid "no command found"
msgstr "Kein Kommando gefunden."

#: builtins/fc.def:341
msgid "history specification"
msgstr ""

#: builtins/fc.def:362
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: Kann die tempräre Datei nicht öffnen: %s"

#: builtins/fg_bg.def:149 builtins/jobs.def:282
msgid "current"
msgstr ""

#: builtins/fg_bg.def:158
#, c-format
msgid "job %d started without job control"
msgstr "Job %d wurde ohne Jobsteuerung gestartet."

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: Ungültige Option -- %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: Diese Option erfordert ein Argument -- %c\n"

#: builtins/hash.def:92
msgid "hashing disabled"
msgstr ""

#: builtins/hash.def:138
#, c-format
msgid "%s: hash table empty\n"
msgstr ""

#: builtins/hash.def:244
#, c-format
msgid "hits\tcommand\n"
msgstr ""

#: builtins/help.def:130
#, c-format
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] ""
msgstr[1] ""

#: builtins/help.def:168
#, c-format
msgid ""
"no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr ""

#: builtins/help.def:185
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: Kann die Datei nicht öffnen: %s"

#: builtins/help.def:337
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Die Shell Kommandos sind intern definiert.  Mit `help' kann eine Liste\n"
"angesehen werden.  Durch `help Name' wird eine Beschreibung der\n"
"Funktion `Name' angezeigt.  Die Dokumentation ist mit `info bash'\n"
"einsehbar.  Detaillierte Beschreibungen der Shellkommandos sind mit\n"
"`man -k' oder `info' abrufbar.\n"
"\n"
"Ein Stern (*) neben dem Namen kennzeichnet deaktivierte Kommandos.\n"
"\n"

#: builtins/history.def:154
msgid "cannot use more than one of -anrw"
msgstr ""

#: builtins/history.def:186
msgid "history position"
msgstr ""

#: builtins/history.def:365
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: History Substitution gescheitert."

#: builtins/inlib.def:71
#, c-format
msgid "%s: inlib failed"
msgstr "%s: inlib gescheitert."

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "Keine weiteren Optionen mit `-x' erlaubt."

#: builtins/kill.def:197
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: Die Argumente müssen Prozess- oder Jobbezeichnungen sein."

#: builtins/kill.def:260
msgid "Unknown error"
msgstr "Unbekannter Fehler."

#: builtins/let.def:95 builtins/let.def:120 expr.c:501 expr.c:516
msgid "expression expected"
msgstr "Ausdruck erwartet."

#: builtins/mapfile.def:241 builtins/read.def:272
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr ""

#: builtins/mapfile.def:249 builtins/read.def:279
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr ""

#: builtins/mapfile.def:258 builtins/mapfile.def:296
#, c-format
msgid "%s: invalid line count"
msgstr ""

#: builtins/mapfile.def:269
#, c-format
msgid "%s: invalid array origin"
msgstr ""

#: builtins/mapfile.def:286
#, c-format
msgid "%s: invalid callback quantum"
msgstr ""

#: builtins/mapfile.def:318
msgid "empty array variable name"
msgstr ""

#: builtins/mapfile.def:339
msgid "array variable support required"
msgstr ""

#: builtins/printf.def:367
#, c-format
msgid "`%s': missing format character"
msgstr ""

#: builtins/printf.def:544
#, c-format
msgid "`%c': invalid format character"
msgstr ""

#: builtins/printf.def:571
#, c-format
msgid "warning: %s: %s"
msgstr "Warnung: %s: %s"

#: builtins/printf.def:750
msgid "missing hex digit for \\x"
msgstr ""

#: builtins/pushd.def:195
msgid "no other directory"
msgstr "kein anderes Verzeichnis"

#: builtins/pushd.def:462
msgid "<no current directory>"
msgstr "<kein aktuelles Verzeichnis>"

#: builtins/pushd.def:506
msgid "directory stack empty"
msgstr "der Verzeichnisstapel ist leer"

#: builtins/pushd.def:508
msgid "directory stack index"
msgstr ""

#: builtins/pushd.def:683
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""

#: builtins/pushd.def:705
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Legt ein Verzeichniseintrag auf den Verzeichnisstapel ab oder rotiert\n"
"den Stapel so, dass das aktuelle Verzeichnis oben liegt.  Ohne Argumente\n"
"werden die beiden oberen Einträge vertauscht.\n"
"\n"
"    Optionen: \n"
"       -n\tVermeidet das Wechseln des Verzeichnisses, so dass\n"
"\tnur der Verzeichnisstapel geändert wird.\n"
"\n"
"    Argumente:\n"
"      +N\tRotiert den Verzeichnisstapel, dass das N-te Verzeichnis\n"
"\tvon links, das von `dirs' angezeigt wird, nach oben kommt.  Die Zählung\n"
"\tbeginnt dabei mit Null.\n"
"\n"
"      -N\tRotiert den Verzeichnisstapel, dass das N-te Verzeichnis\n"
"\tvon rechts, das von `dirs' angezeigt wird, nach oben kommt.  Die \n"
"\tZählung beginnt dabei mit Null.\n"
"\n"
"      dir\tLegt DIR auf den Verzeichnisstapel und wechselt in dieses\n"
"      Verzeichnis.\n"
"    \n"
"    Das `dirs' Kommando zeigt den Verueichnisstapel an."

#: builtins/pushd.def:730
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Erntfernt Einträge vom Stapel.  Ohne Argumente wird der oberste Eintrag\n"
"    gelöscht und anschließend in das das neue oben liegede Verzeichnis\n"
"    gewechselt.\n"
"    \n"
"    Optionen:\n"
"      -n\tVermeidet das Wechseln des Verzeichnisses, so dass\n"
"\tnur der Verzeichnisstapel geändert wird.\n"
"    \n"
"    Argumente:\n"
"      +N\tEntfernt den N-ten Eintrag von links, der von `dirs'\n"
"\tangezeigt wird.  Dabei beginnt die Zählung von Null.  So\n"
"\tentfernt z.B. `popd +0' den ersten und `popd +1' den zweiten\n"
"\tEintrag.\n"
"    \n"
"      -N\tEntfernt den N-ten Eintrag von rechts, der von `dirs'\n"
"\tangezeigt wird.  Dabei beginnt die Zählung von Null.  So\n"
"\tentfernt z.B. `popd -0' den letzten und `popd +1' den vorletzten\n"
"\tEintrag.\n"
"    \n"
"    Das `dirs' Kommando zeigt den Verzeichnisstapel an."

#: builtins/read.def:248
#, c-format
msgid "%s: invalid timeout specification"
msgstr ""

#: builtins/read.def:574
#, c-format
msgid "read error: %d: %s"
msgstr "Lesefehler: %d: %s"

#: builtins/return.def:73
msgid "can only `return' from a function or sourced script"
msgstr ""

#: builtins/set.def:768
msgid "cannot simultaneously unset a function and a variable"
msgstr ""

#: builtins/set.def:805
#, c-format
msgid "%s: cannot unset"
msgstr ""

#: builtins/set.def:812
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr ""

#: builtins/set.def:823
#, c-format
msgid "%s: not an array variable"
msgstr ""

#: builtins/setattr.def:186
#, c-format
msgid "%s: not a function"
msgstr ""

#: builtins/shift.def:71 builtins/shift.def:77
msgid "shift count"
msgstr ""

#: builtins/shopt.def:254
msgid "cannot set and unset shell options simultaneously"
msgstr ""

#: builtins/shopt.def:319
#, c-format
msgid "%s: invalid shell option name"
msgstr ""

#: builtins/source.def:128
msgid "filename argument required"
msgstr ""

#: builtins/source.def:153
#, c-format
msgid "%s: file not found"
msgstr "%s: Datei nicht gefunden."

#: builtins/suspend.def:101
msgid "cannot suspend"
msgstr ""

# logout
#: builtins/suspend.def:111
msgid "cannot suspend a login shell"
msgstr "Kann die Loginshell nicht unterbrechen."

#: builtins/type.def:234
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr ""

#: builtins/type.def:255
#, c-format
msgid "%s is a shell keyword\n"
msgstr ""

#: builtins/type.def:274
#, c-format
msgid "%s is a function\n"
msgstr "%s ist eine Funktion.\n"

#: builtins/type.def:296
#, c-format
msgid "%s is a shell builtin\n"
msgstr ""

#: builtins/type.def:317 builtins/type.def:391
#, c-format
msgid "%s is %s\n"
msgstr ""

#: builtins/type.def:337
#, c-format
msgid "%s is hashed (%s)\n"
msgstr ""

#: builtins/ulimit.def:372
#, c-format
msgid "%s: invalid limit argument"
msgstr ""

#: builtins/ulimit.def:398
#, c-format
msgid "`%c': bad command"
msgstr "`%c': Falsches Kommando."

#: builtins/ulimit.def:427
#, c-format
msgid "%s: cannot get limit: %s"
msgstr ""

#: builtins/ulimit.def:453
msgid "limit"
msgstr "Grenze"

#: builtins/ulimit.def:465 builtins/ulimit.def:765
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: Kann die Grenze nicht ändern: %s"

#: builtins/umask.def:118
msgid "octal number"
msgstr ""

#: builtins/umask.def:231
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr ""

#: builtins/umask.def:286
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr ""

#: error.c:89 error.c:320 error.c:322 error.c:324
msgid " line "
msgstr " Zeile "

#: error.c:164
#, c-format
msgid "last command: %s\n"
msgstr "Letztes Kommando: %s\n"

#: error.c:172
#, c-format
msgid "Aborting..."
msgstr "Abbruch..."

#: error.c:405
msgid "unknown command error"
msgstr ""

#: error.c:406
msgid "bad command type"
msgstr ""

# Programmierfehler
#: error.c:407
msgid "bad connector"
msgstr ""

#: error.c:408
#, fuzzy
msgid "bad jump"
msgstr "Falscher Sprung %d."

#: error.c:446
#, c-format
msgid "%s: unbound variable"
msgstr "%s ist nicht gesetzt."

#: eval.c:181
#, c-format
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\aZu lange keine Eingabe: Automatisch ausgeloggt.\n"

#: execute_cmd.c:491
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "Kann nicht die Standardeingabe von /dev/null umleiten: %s"

#: execute_cmd.c:1112
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: `%c': Ungültiges Formatzeichen."

#: execute_cmd.c:2011
msgid "pipe error"
msgstr "Pipe-Fehler"

#: execute_cmd.c:4363
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: Verboten:  `/' ist in Kommandonamen unzulässig."

#: execute_cmd.c:4454
#, c-format
msgid "%s: command not found"
msgstr "%s: Kommando nicht gefunden."

#: execute_cmd.c:4708
#, fuzzy, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: ist ein Verzeichnis."

#: execute_cmd.c:4857
#, fuzzy, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "Kann fd %d nicht auf fd 0 verdoppeln: %s"

#: expr.c:241
msgid "expression recursion level exceeded"
msgstr "Zu viele Rekursionen in Ausdruck."

#: expr.c:265
#, fuzzy
msgid "recursion stack underflow"
msgstr "Rekursionsstapel leer."

#: expr.c:379
msgid "syntax error in expression"
msgstr "Syntaxfehler im Ausdruck."

#: expr.c:419
msgid "attempted assignment to non-variable"
msgstr "Zuweisung zu einer Nicht-Variablen versucht."

#: expr.c:440 expr.c:445 expr.c:756
msgid "division by 0"
msgstr "Division durch 0."

#: expr.c:471
#, fuzzy
msgid "bug: bad expassign token"
msgstr "Fehler: Falsches Zuweisungszeichen %d."

#: expr.c:513
msgid "`:' expected for conditional expression"
msgstr "`:' erwartet für ein bedingten Ausdruck."

#: expr.c:781
msgid "exponent less than 0"
msgstr "Der Exponent ist kleiner als 0."

#: expr.c:826
msgid "identifier expected after pre-increment or pre-decrement"
msgstr ""
"Nach einem Präinkrement oder Prädekrement wird ein Bezeichner erwartet."

#: expr.c:854
msgid "missing `)'"
msgstr "Fehlende `)'"

#: expr.c:897 expr.c:1175
#, fuzzy
msgid "syntax error: operand expected"
msgstr "Syntax Fehler: Unerwartetes Dateiende."

#: expr.c:1177
msgid "syntax error: invalid arithmetic operator"
msgstr "Syntaxfehler: Ungültiger arithmetischer Operator."

#: expr.c:1201
#, fuzzy, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s: %s: %s (Fehlerverursachendes Wort ist \\\"%s\\\").\n"

#: expr.c:1259
msgid "invalid arithmetic base"
msgstr "Ungültige Basis."

#: expr.c:1279
msgid "value too great for base"
msgstr "Der Wert ist zu groß für die aktuelle Basis."

#: expr.c:1328
#, fuzzy, c-format
msgid "%s: expression error\n"
msgstr "Umlenkfehler"

#: general.c:61
msgid "getcwd: cannot access parent directories"
msgstr "getwd: Kann nicht auf das übergeordnete Verzeichnis zugreifen."

#: input.c:94 subst.c:4559
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "Konnte den No-Delay Modus für fd %d nicht wieder herstellen."

#: input.c:258
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "Kann keinen neuen Filedeskriptor für die Eingabe von fd %d zuweisen."

# Debug Ausgabe
#: input.c:266
#, fuzzy, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "check_bash_input: buffer already exists for new fd %d"

#: jobs.c:466
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: pgrp pipe"

#: jobs.c:887
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr ""

#: jobs.c:1005
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr ""

#: jobs.c:1110
#, c-format
msgid "add_process: process %5ld (%s) in the_pipeline"
msgstr ""

#: jobs.c:1113
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr ""

# Programmierfehler
#: jobs.c:1401
#, fuzzy, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: Prozeß-Nummer existiert nicht (%d)!\n"

#: jobs.c:1416
#, c-format
msgid "Signal %d"
msgstr "Signal %d"

#: jobs.c:1430 jobs.c:1455
msgid "Done"
msgstr "Fertig"

#: jobs.c:1435 siglist.c:122
msgid "Stopped"
msgstr "Angehalten"

#: jobs.c:1439
#, c-format
msgid "Stopped(%s)"
msgstr "Angehalten(%s)"

#: jobs.c:1443
msgid "Running"
msgstr "Läuft"

#: jobs.c:1457
#, c-format
msgid "Done(%d)"
msgstr "Fertig(%d)"

#: jobs.c:1459
#, c-format
msgid "Exit %d"
msgstr "Exit %d"

#: jobs.c:1462
msgid "Unknown status"
msgstr "Unbekannter Status"

#: jobs.c:1549
#, c-format
msgid "(core dumped) "
msgstr "(Speicherabzug geschrieben) "

#: jobs.c:1568
#, c-format
msgid "  (wd: %s)"
msgstr "  (wd: %s)"

# interner Fehler
#: jobs.c:1771
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr ""

#: jobs.c:2099 nojobs.c:585
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: Prozeß %ld wurde nicht von dieser Shell gestartet."

#: jobs.c:2326
#, c-format
msgid "wait_for: No record of process %ld"
msgstr ""

#: jobs.c:2598
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr ""

#: jobs.c:2820
#, c-format
msgid "%s: job has terminated"
msgstr "%s: Programm ist beendet."

#: jobs.c:2829
#, c-format
msgid "%s: job %d already in background"
msgstr ""

# Debug Ausgabe
#: jobs.c:3492
#, c-format
msgid "%s: line %d: "
msgstr "%s: Zeile %d: "

#: jobs.c:3506 nojobs.c:814
#, c-format
msgid " (core dumped)"
msgstr " (Speicherabzug geschrieben)"

#: jobs.c:3518 jobs.c:3531
#, c-format
msgid "(wd now: %s)\n"
msgstr "(gegenwärtiges Arbeitsverzeichnis ist: %s)\n"

# interner Fehler
#: jobs.c:3563
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_jobs: getpgrp war nicht erfolgreich."

# interner Fehler
#: jobs.c:3623
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: line discipline"

# interner Fehler
#: jobs.c:3633
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.c:3661
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr ""

#: jobs.c:3666
msgid "no job control in this shell"
msgstr "Keine Job Steuerung in dieser Shell."

#: lib/malloc/malloc.c:296
#, fuzzy, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc:  Fehler bei Speicherzuweisung: %s\n"

#: lib/malloc/malloc.c:312
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""

#: lib/malloc/malloc.c:313
msgid "unknown"
msgstr "Unbekannt"

#: lib/malloc/malloc.c:797
msgid "malloc: block on free list clobbered"
msgstr ""

#: lib/malloc/malloc.c:874
msgid "free: called with already freed block argument"
msgstr ""

#: lib/malloc/malloc.c:877
msgid "free: called with unallocated block argument"
msgstr ""

#: lib/malloc/malloc.c:896
msgid "free: underflow detected; mh_nbytes out of range"
msgstr ""

#: lib/malloc/malloc.c:902
msgid "free: start and end chunk sizes differ"
msgstr ""

#: lib/malloc/malloc.c:1001
msgid "realloc: called with unallocated block argument"
msgstr ""

#: lib/malloc/malloc.c:1016
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr ""

#: lib/malloc/malloc.c:1022
msgid "realloc: start and end chunk sizes differ"
msgstr ""

#: lib/malloc/table.c:177
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr ""

#: lib/malloc/table.c:184
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr ""

#: lib/malloc/table.c:220
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr ""

#: lib/sh/fmtulong.c:101
msgid "invalid base"
msgstr ""

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr ""

#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr ""

#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr ""

#: lib/sh/netopen.c:346
msgid "network operations not supported"
msgstr ""

# Du oder Sie?
#: mailcheck.c:433
msgid "You have mail in $_"
msgstr "Sie haben Post in $_."

#: mailcheck.c:458
msgid "You have new mail in $_"
msgstr "Sie haben neue Post in $_."

#: mailcheck.c:474
#, c-format
msgid "The mail in %s has been read\n"
msgstr "Die Post in %s wurde bereits gelesen.\n"

#: make_cmd.c:322
#, fuzzy
msgid "syntax error: arithmetic expression required"
msgstr "Syntaxfehler im Ausdruck."

#: make_cmd.c:324
#, fuzzy
msgid "syntax error: `;' unexpected"
msgstr "Syntax Fehler: Unerwartetes Dateiende."

#: make_cmd.c:325
#, fuzzy, c-format
msgid "syntax error: `((%s))'"
msgstr "Syntax Fehler"

# interner Fehler
#: make_cmd.c:567
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: Falscher Befehlstyp %d."

#: make_cmd.c:651
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr ""

#: make_cmd.c:746
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr ""

#: parse.y:2986 parse.y:3218
#, fuzzy, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "Dateiende beim Suchen nach `%c' erreicht."

#: parse.y:3722
#, fuzzy
msgid "unexpected EOF while looking for `]]'"
msgstr "Dateiende beim Suchen nach `%c' erreicht."

#: parse.y:3727
#, fuzzy, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "Syntaxfehler beim unerwarteten Wort `%s'"

#: parse.y:3731
#, fuzzy
msgid "syntax error in conditional expression"
msgstr "Syntaxfehler im Ausdruck."

#: parse.y:3809
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr ""

#: parse.y:3813
#, fuzzy
msgid "expected `)'"
msgstr "`)' erwartet."

#: parse.y:3841
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr ""

#: parse.y:3845
msgid "unexpected argument to conditional unary operator"
msgstr ""

#: parse.y:3885
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr ""

#: parse.y:3889
msgid "conditional binary operator expected"
msgstr ""

#: parse.y:3906
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr ""

#: parse.y:3910
msgid "unexpected argument to conditional binary operator"
msgstr ""

#: parse.y:3921
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr ""

#: parse.y:3924
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr ""

#: parse.y:3928
#, c-format
msgid "unexpected token %d in conditional command"
msgstr ""

#: parse.y:5195
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "Syntaxfehler beim unerwarteten Wort `%s'"

#: parse.y:5213
#, c-format
msgid "syntax error near `%s'"
msgstr "Syntaxfehler beim unerwarteten Wort `%s'"

#: parse.y:5223
msgid "syntax error: unexpected end of file"
msgstr "Syntax Fehler: Unerwartetes Dateiende."

#: parse.y:5223
msgid "syntax error"
msgstr "Syntax Fehler"

# Du oder Sie?
#: parse.y:5285
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Benutze \"%s\" um die Shell zu verlassen.\n"

#: parse.y:5447
msgid "unexpected EOF while looking for matching `)'"
msgstr "Dateiende beim Suchen nach passender `)' erreicht."

#: pcomplete.c:1018
#, c-format
msgid "completion: function `%s' not found"
msgstr ""

#: pcomplib.c:179
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr ""

#: print_cmd.c:285
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: Falsches Verbindungszeichen `%d'."

#: print_cmd.c:1348
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr ""

#: redir.c:105
msgid "file descriptor out of range"
msgstr ""

#: redir.c:148
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: Mehrdeutige Umlenkung."

#: redir.c:152
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: Kann existierende Datei nicht überschreiben."

#: redir.c:157
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: Gesperrt: Die Ausgabe darf nicht umgeleitet werden."

#: redir.c:162
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr ""

#: redir.c:517
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr ""

#: redir.c:1023
msgid "redirection error: cannot duplicate fd"
msgstr ""

#: shell.c:328
msgid "could not find /tmp, please create!"
msgstr "Konnte das /tmp Verzeichnis nicht finden, bitte anlegen."

#: shell.c:332
msgid "/tmp must be a valid directory name"
msgstr "/tmp muß ein gültiger Verzeichnisname sein."

#: shell.c:876
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: Ungültige Option"

#: shell.c:1638
msgid "I have no name!"
msgstr "Ich habe keinen Benutzernamen!"

#: shell.c:1778
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, Version %s-(%s)\n"

#: shell.c:1779
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Benutzung:\t%s [Lange GNU Option] [Option] ...\n"
"\t\t%s [Lange GNU Option] [Option] Script-Datei ...\n"

#: shell.c:1781
msgid "GNU long options:\n"
msgstr "Lange GNU Optionen:\n"

#: shell.c:1785
msgid "Shell options:\n"
msgstr "Shell-Optionen:\n"

#: shell.c:1786
msgid "\t-irsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-irsD oder -c Kommando\t\t(Nur Aufruf)\n"

#: shell.c:1801
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s oder Option -o\n"

#: shell.c:1807
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr "`%s -c \"help set\"' für mehr Informationen über Shell-Optionen.\n"

#: shell.c:1808
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr "`%s -c help' für mehr Information über Shell-Kommandos.\n"

#: shell.c:1809
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Mit dem `bashbug' Kommando können Fehler gemeldet werden.\n"

#: sig.c:583
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: Ungültige Operation"

#: siglist.c:47
msgid "Bogus signal"
msgstr "Falsches Signal."

#: siglist.c:50
msgid "Hangup"
msgstr "Aufgelegt"

#: siglist.c:54
msgid "Interrupt"
msgstr "Unterbrochen"

#: siglist.c:58
msgid "Quit"
msgstr "Quit"

#: siglist.c:62
msgid "Illegal instruction"
msgstr "Ungültige Anweisung."

# Was heisst das?
#: siglist.c:66
#, fuzzy
msgid "BPT trace/trap"
msgstr "BPT trace/trap"

#: siglist.c:74
msgid "ABORT instruction"
msgstr "Abbruchkommando"

#: siglist.c:78
msgid "EMT instruction"
msgstr "EMT-Kommando"

#: siglist.c:82
msgid "Floating point exception"
msgstr "Gleitkommafehler"

#: siglist.c:86
msgid "Killed"
msgstr "Gekillt"

#: siglist.c:90
msgid "Bus error"
msgstr "Bus-Fehler"

#: siglist.c:94
msgid "Segmentation fault"
msgstr "Speicherzugriffsfehler"

#: siglist.c:98
msgid "Bad system call"
msgstr "Falscher Systemaufruf"

#: siglist.c:102
msgid "Broken pipe"
msgstr "Unterbrochene Pipe"

#: siglist.c:106
msgid "Alarm clock"
msgstr "Wecker"

#: siglist.c:110
msgid "Terminated"
msgstr "Beendet"

#: siglist.c:114
msgid "Urgent IO condition"
msgstr "Dringende IO-Bedingung"

#: siglist.c:118
msgid "Stopped (signal)"
msgstr "Angehalten (Signal)"

#: siglist.c:126
msgid "Continue"
msgstr "Prozeßbearbeitung wieder aufgenommen."

#: siglist.c:134
msgid "Child death or stop"
msgstr "Kindprozeß abgebrochen oder gestoppt."

#: siglist.c:138
msgid "Stopped (tty input)"
msgstr "Angehalten (Terminaleingabe)"

#: siglist.c:142
msgid "Stopped (tty output)"
msgstr "Angehalten (Terminalausgabe)"

#: siglist.c:146
msgid "I/O ready"
msgstr "E/A fertig"

#: siglist.c:150
msgid "CPU limit"
msgstr "Rechenzeitgrenze"

#: siglist.c:154
msgid "File limit"
msgstr "Grenze für Dateigröße"

#: siglist.c:158
msgid "Alarm (virtual)"
msgstr "Alarm (Virtuell)"

#: siglist.c:162
msgid "Alarm (profile)"
msgstr "Alarm (Profil)"

#: siglist.c:166
msgid "Window changed"
msgstr "Fenster geändert."

#: siglist.c:170
msgid "Record lock"
msgstr "Datei blockiert."

#: siglist.c:174
msgid "User signal 1"
msgstr "Nutzer-Signal 1"

#: siglist.c:178
msgid "User signal 2"
msgstr "Nutzer-Signal 2"

#: siglist.c:182
msgid "HFT input data pending"
msgstr "HFT Eingabedaten ausstehend."

#: siglist.c:186
msgid "power failure imminent"
msgstr "Spannungsausfall steht bevor."

#: siglist.c:190
msgid "system crash imminent"
msgstr "Systemausfall steht bevor."

#: siglist.c:194
msgid "migrate process to another CPU"
msgstr "Verlege den Prozeß auf einen anderen Prozessor."

#: siglist.c:198
msgid "programming error"
msgstr "Programmierfehler"

#: siglist.c:202
msgid "HFT monitor mode granted"
msgstr "HFT-Monitormodus erlaubt."

#: siglist.c:206
msgid "HFT monitor mode retracted"
msgstr "HFT-Monitormodus abgeschaltet."

#: siglist.c:210
msgid "HFT sound sequence has completed"
msgstr "HFT-Tonfolge beendet."

#: siglist.c:214
msgid "Information request"
msgstr "Informationsanforderung"

#: siglist.c:222
msgid "Unknown Signal #"
msgstr "Unbekannte Signalnummer."

#: siglist.c:224
#, c-format
msgid "Unknown Signal #%d"
msgstr "Unbekanntes Signal Nr.: %d."

#: subst.c:1181 subst.c:1302
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "Falsche Ersetzung: Keine schließende `%s' in `%s' enthalten."

#: subst.c:2458
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: Kann einem Feldelement keine Liste zuweisen."

#: subst.c:4456 subst.c:4472
msgid "cannot make pipe for process substitution"
msgstr "Kann keine Pipe für die Prozeßersetzung erzeugen."

#: subst.c:4504
msgid "cannot make child for process substitution"
msgstr ""

#: subst.c:4549
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "Kann nicht die benannte Pipe %s zum lesen öffnen."

#: subst.c:4551
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "Kann nicht die benannte Pipe %s zum schreiben öffnen."

#: subst.c:4569
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "Kann die benannte Pipe %s nicht auf fd %d."

#: subst.c:4765
msgid "cannot make pipe for command substitution"
msgstr "Kann keine Pipes für Kommandoersetzung erzeugen."

#: subst.c:4799
msgid "cannot make child for command substitution"
msgstr "Kann keinen Unterprozess für die Kommandoersetzung erzeugen."

# interner Fehler
#: subst.c:4816
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "Kommandoersetzung: Kann Pipe nicht als fd 1 duplizieren."

#: subst.c:5318
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: Parameter ist Null oder nicht gesetzt."

# interner Fehler
#: subst.c:5608
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: Teilstring-Ausdruck < 0."

#: subst.c:6660
#, c-format
msgid "%s: bad substitution"
msgstr "%s: Falsche Variablenersetzung."

#: subst.c:6740
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: Kann so nicht zuweisen."

#: subst.c:7499
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "Falsche Ersetzung: Keine schließende \"`\" in %s."

#: subst.c:8375
#, c-format
msgid "no match: %s"
msgstr "Keine Entsprechung: %s"

#: test.c:145
msgid "argument expected"
msgstr "Argument erwartet."

#: test.c:154
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: Ganzzahliger Ausdruck erwartet."

#: test.c:262
msgid "`)' expected"
msgstr "`)' erwartet."

#: test.c:264
#, c-format
msgid "`)' expected, found %s"
msgstr "`)' erwartet, %s gefunden."

#: test.c:279 test.c:688 test.c:691
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: Einstelliger (unärer) Operator erwartet."

#: test.c:444 test.c:731
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: Zweistelliger (binärer) Operator erwartet."

#: test.c:806
msgid "missing `]'"
msgstr "Fehlende `]'"

#: trap.c:201
msgid "invalid signal number"
msgstr "Ungültige Signalnummer."

#: trap.c:324
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr ""

#: trap.c:328
#, c-format
msgid ""
"run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr ""

# Programmierfehler
#: trap.c:372
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: Falsches Signal %d."

#: variables.c:358
#, c-format
msgid "error importing function definition for `%s'"
msgstr "Fehler beim Importieren der Funktionsdefinition für `%s'."

#: variables.c:736
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr ""

#: variables.c:1898
msgid "make_local_variable: no function context at current scope"
msgstr ""

#: variables.c:3127
msgid "all_local_variables: no function context at current scope"
msgstr ""

#: variables.c:3344 variables.c:3353
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr ""

#: variables.c:3359
#, c-format
msgid "no `=' in exportstr for %s"
msgstr ""

#: variables.c:3794
msgid "pop_var_context: head of shell_variables not a function context"
msgstr ""

#: variables.c:3807
msgid "pop_var_context: no global_variables context"
msgstr ""

#: variables.c:3881
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr ""

#: version.c:46
#, fuzzy
msgid "Copyright (C) 2009 Free Software Foundation, Inc."
msgstr "Copyright (C) 2008 Free Software Foundation, Inc."

#: version.c:47
msgid ""
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl."
"html>\n"
msgstr ""
"Lizenz GPLv3+: GNU GPL Version 3 oder jünger <http://gnu.org/licenses/gpl."
"html>\n"

#: version.c:86
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, Version %s (%s)\n"

#: version.c:91
#, c-format
msgid "This is free software; you are free to change and redistribute it.\n"
msgstr "Dies ist freie Software.  Sie darf verändert und verteilt werden.\n"

#: version.c:92
#, c-format
msgid "There is NO WARRANTY, to the extent permitted by law.\n"
msgstr "Für dieses Programm besteht keinerlei Garantie.\n"

#: xmalloc.c:92
#, c-format
msgid "xmalloc: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "xmalloc: Kann %lu Bytes nicht reservieren (%lu bytes reserviert)."

#: xmalloc.c:94
#, c-format
msgid "xmalloc: cannot allocate %lu bytes"
msgstr "xmalloc: Kann nicht %lu Bytes reservieren."

#: xmalloc.c:114
#, c-format
msgid "xrealloc: cannot reallocate %lu bytes (%lu bytes allocated)"
msgstr "xrealloc: Kann %lu Bytes nicht reservieren (%lu bytes reserviert)."

#: xmalloc.c:116
#, c-format
msgid "xrealloc: cannot allocate %lu bytes"
msgstr "xrealloc: Kann nicht %lu Bytes reservieren."

#: xmalloc.c:150
#, c-format
msgid "xmalloc: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr ""
"xmalloc: %s:%d: Kann nicht %lu Bytes reservieren (%lu bytes reserviert)."

#: xmalloc.c:152
#, c-format
msgid "xmalloc: %s:%d: cannot allocate %lu bytes"
msgstr "xmalloc: %s:%d: Kann nicht %lu Bytes reservieren."

#: xmalloc.c:174
#, c-format
msgid "xrealloc: %s:%d: cannot reallocate %lu bytes (%lu bytes allocated)"
msgstr ""
"xrealloc: %s:%d: Kann nicht %lu Bytes reservieren (%lu bytes reserviert)."

#: xmalloc.c:176
#, c-format
msgid "xrealloc: %s:%d: cannot allocate %lu bytes"
msgstr "xrealloc: %s:%d: Kann nicht %lu Bytes reservieren."

#: builtins.c:43
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [Name[=Wert] ... ]"

#: builtins.c:47
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] Name [Name ...]"

#: builtins.c:51
msgid ""
"bind [-lpvsPVS] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-"
"x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr ""
"bind [-lpvsPVS] [-m Tastaturtabelle] [-f Dateiname] [-q Name] [-u Name] [-r "
"Tastenfolge:Shell Kommando] [Tastenfolge:readline Funktion oder Kommando]"

#: builtins.c:54
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:56
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:58
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [Shellkommando [Argument ...]]"

#: builtins.c:61
msgid "caller [expr]"
msgstr "caller [Ausdruck]"

#: builtins.c:64
msgid "cd [-L|-P] [dir]"
msgstr "cd [-L|-P] [Verzeichnis]"

#: builtins.c:66
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:68
msgid ":"
msgstr ":"

#: builtins.c:70
msgid "true"
msgstr "Wahr"

#: builtins.c:72
msgid "false"
msgstr "Falsch"

#: builtins.c:74
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] Kommando [Argument ...]"

#: builtins.c:76
msgid "declare [-aAfFilrtux] [-p] [name[=value] ...]"
msgstr "declare [-aAfFilrtux] [-p] [Name[=Wert] ...]"

#
#: builtins.c:78
msgid "typeset [-aAfFilrtux] [-p] name[=value] ..."
msgstr "typeset [-aAfFilrtux] [-p] Name[=Wert] ..."

#: builtins.c:80
msgid "local [option] name[=value] ..."
msgstr "local [Option] Name[=Wert] ..."

#: builtins.c:83
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [Argument ...]"

#: builtins.c:87
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [Argument ...]"

#: builtins.c:90
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f Dateiname] [Name ...]"

#: builtins.c:92
msgid "eval [arg ...]"
msgstr "eval [Argument ...]"

#: builtins.c:94
msgid "getopts optstring name [arg]"
msgstr "getopts Optionen Variable [Argumente]"

#: builtins.c:96
msgid "exec [-cl] [-a name] [command [arguments ...]] [redirection ...]"
msgstr "exec [-cl] [-a Name] [Kommando [Argumente ...]] [Umleitung ...]"

#: builtins.c:98
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:100
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:103
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr ""
"fc [-e Editor] [-lnr] [Anfang] [Ende] oder fc -s [Muster=Ersetzung] "
"[Kommando]"

#: builtins.c:107
msgid "fg [job_spec]"
msgstr "fg [Jobbezeichnung]"

#: builtins.c:111
msgid "bg [job_spec ...]"
msgstr "bg [Jobbezeichnung ...]"

#: builtins.c:114
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p Pfadname] [-dt] [Name ...]"

#: builtins.c:117
msgid "help [-ds] [pattern ...]"
msgstr "help [-ds] [Muster ...]"

#: builtins.c:121
msgid ""
"history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg "
"[arg...]"
msgstr ""
"history [-c] [-d Offset] [n] oder history -anrw [Dateiname] oder history -ps "
"Argument [Argument...]"

#: builtins.c:125
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [Jobbez. ...] or jobs -x Kommando [Arg]"

#: builtins.c:129
msgid "disown [-h] [-ar] [jobspec ...]"
msgstr "disown [-h] [-ar] [Jobbezeichnung ...]"

#: builtins.c:132
msgid ""
"kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l "
"[sigspec]"
msgstr ""
"kill [-s Signalname | -n Signalnummer | -Signalname] [pid | job] ... oder "
"kill -l [Signalname]"

#: builtins.c:134
msgid "let arg [arg ...]"
msgstr "let Argument [Argument ...]"

#: builtins.c:136
msgid ""
"read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-p prompt] [-t "
"timeout] [-u fd] [name ...]"
msgstr ""
"read [-ers] [-a Feld] [-d Begrenzer] [-i Text] [-n Zeichenanzahl] [-p "
"Prompt] [-t Zeitlimit] [-u fd] [Name ...]"

#: builtins.c:138
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:140
msgid "set [--abefhkmnptuvxBCHP] [-o option-name] [arg ...]"
msgstr "set [--abefhkmnptuvxBCHP] [-o Option] [ARG ...]"

#: builtins.c:142
msgid "unset [-f] [-v] [name ...]"
msgstr "unset [-f] [-v] [NAME ...]"

#: builtins.c:144
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [Name[=Wert] ...] oder export -p"

#: builtins.c:146
msgid "readonly [-af] [name[=value] ...] or readonly -p"
msgstr "readonly [-af] [Name[=Wert] ...] oder readonly -p"

#: builtins.c:148
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:150
msgid "source filename [arguments]"
msgstr "source Dateiname [Argumente]"

#: builtins.c:152
msgid ". filename [arguments]"
msgstr ". Dateiname [Argumente]"

#: builtins.c:155
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:158
msgid "test [expr]"
msgstr "test [Ausdruck]"

#: builtins.c:160
msgid "[ arg... ]"
msgstr "[ Argument... ]"

#: builtins.c:162
msgid "times"
msgstr "times"

#: builtins.c:164
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[Argument] Signalbezeichnung ...]"

#: builtins.c:166
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] Name [Name ...]"

#: builtins.c:169
msgid "ulimit [-SHacdefilmnpqrstuvx] [limit]"
msgstr "ulimit [-SHacdefilmnpqrstuvx] [Grenzwert]"

#: builtins.c:172
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [Modus]"

#: builtins.c:175
msgid "wait [id]"
msgstr "wait [id]"

#: builtins.c:179
msgid "wait [pid]"
msgstr "wait [pid]"

#: builtins.c:182
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for Name [in Wortliste ... ] ; do Kommandos; done"

#: builtins.c:184
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( Ausdr1; Ausdr2; Ausdr3 )); do Kommandos; done"

#: builtins.c:186
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select Name [in Wortliste ... ;] do Kommandos; done"

#: builtins.c:188
msgid "time [-p] pipeline"
msgstr ""

#: builtins.c:190
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case Wort in [Muster [| Muster]...) Kommandos ;;]... esac"

#: builtins.c:192
msgid ""
"if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else "
"COMMANDS; ] fi"
msgstr ""
"if Kommandos; then Kommandos; [ elif Kommandos; then Kommandos; ]... \n"
"\t[ else Kommandos; ] fi"

#: builtins.c:194
msgid "while COMMANDS; do COMMANDS; done"
msgstr "while Kommandos; do Kommandos; done"

#: builtins.c:196
msgid "until COMMANDS; do COMMANDS; done"
msgstr "until Kommandos; do Kommandos; done"

#: builtins.c:198
msgid "coproc [NAME] command [redirections]"
msgstr ""

#: builtins.c:200
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function Name { Kommandos ; } oder Name () { Kommandos ; }"

#: builtins.c:202
msgid "{ COMMANDS ; }"
msgstr "{ Kommandos ; }"

#: builtins.c:204
msgid "job_spec [&]"
msgstr "Jobbezeichnung [&]"

#: builtins.c:206
msgid "(( expression ))"
msgstr "(( Ausdruck ))"

#: builtins.c:208
msgid "[[ expression ]]"
msgstr "[[ Ausdruck ]]"

#: builtins.c:210
msgid "variables - Names and meanings of some shell variables"
msgstr "variables - Namen und Bedeutung einiger Shell Variablen"

#: builtins.c:213
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | Verzeichnis]"

#: builtins.c:217
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:221
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:224
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [Optionsname ...]"

#: builtins.c:226
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v var] Format [Argumente]"

#: builtins.c:229
msgid ""
"complete [-abcdefgjksuv] [-pr] [-o option] [-A action] [-G globpat] [-W "
"wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] "
"[name ...]"
msgstr ""
"complete [-abcdefgjksuv] [-pr] [-o Option] [-A Aktion] [-G Suchmuster] [-W "
"Wortliste]  [-F Funktion] [-C Kommando] [-X Filtermuster] [-P Prefix] [-S "
"Suffix] [Name ...]"

#: builtins.c:233
msgid ""
"compgen [-abcdefgjksuv] [-o option]  [-A action] [-G globpat] [-W wordlist]  "
"[-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr ""
"compgen [-abcdefgjksuv] [-o Option]  [-A Aktion] [-G Suchmuster] [-W "
"Wortliste]  [-F Funktion] [-C Kommando] [-X Filtermuster] [-P Prefix] [-S "
"Suffix] [Wort]"

#: builtins.c:237
msgid "compopt [-o|+o option] [name ...]"
msgstr "compopt [-o|+o Option] [Name ...]"

#: builtins.c:240
msgid ""
"mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c "
"quantum] [array]"
msgstr ""

#: builtins.c:242
msgid ""
"readarray [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c "
"quantum] [array]"
msgstr ""

#: builtins.c:254
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tPrint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has "
"been\n"
"    defined."
msgstr ""
"Definiert Aliase oder zeigt sie an.\n"
"    \n"
"    Ohne Argumente wird die Liste der Aliase (Synonyme) in der Form \n"
"    `alias Name=Wert' auf die Standardausgabe gedruckt.\n"
"\n"
"    Sonst wird ein Alias für jeden angegebenen Namen definiert, für den ein\n"
"    Wert angegeben wurde.  \n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tPrint all defined aliases in a reusable format\n"
"    \n"
"    Rückgabewert:\n"
"    Meldet Erfolg, außer wenn NAME nicht existiert."

#: builtins.c:276
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions.\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Entferne jeden Namen von der Aliasliste.\n"
"    \n"
"    Optionen:\n"
"      -a\tEnferne alle Alias Definitionen.\n"
"    \n"
"    Gibt immer Erfolg zurück, wenn der Name existiert."

#: builtins.c:289
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their "
"values\n"
"      -s                 List key sequences that invoke macros and their "
"values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named "
"function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""

#: builtins.c:326
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Beendet for, while oder until Schleifen.\n"
"    \n"
"    Break beendet eine FOR, WHILE oder UNTIL Schleife.  Wenn N angegeben "
"ist, werden N geschachtelte\n"
"    Schleifen beendet.\n"
"    \n"
"    Rückgabewert:\n"
"    Der Rückgabewert ist 0, es sei den N ist größer oder gleich 1."

#: builtins.c:338
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Springt zum Schleifenanfang von for, while, oder until Schleifen.\n"
"    \n"
"    Continoue springt zum Schleifenanfang der aktuellen FOR, WHILE oder "
"UNTIL \n"
"    Schleife. Wenn N angegeben ist, werden N wird zum Beginn der N-ten\n"
"    übergeordneten Schleife gesprungen.\n"
"    \n"
"    Rückgabewert:\n"
"    Der Rückgabewert ist 0, außer wenn N größer oder gleich 1 ist."

#: builtins.c:350
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the "
"function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin.."
msgstr ""

#: builtins.c:365
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""

#: builtins.c:383
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of "
"the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory "
"containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon "
"(:).\n"
"    A null directory name is the same as the current directory.  If DIR "
"begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is "
"set,\n"
"    the word is assumed to be  a variable name.  If that variable has a "
"value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"        -L\tforce symbolic links to be followed\n"
"        -P\tuse the physical directory structure without following symbolic\n"
"    \tlinks\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed; non-zero otherwise."
msgstr ""

#: builtins.c:411
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Gibt den Namen des aktuellen Arbeitsverzeichnis aus.\n"
"    \n"
"    Optionen:\n"
"      -L\tGibt den Wert der $PWD Umgebungsvariable aus, wenn diese\n"
"\tauf das aktuelle Arbeitsverzeichnis verweist.\n"
"\n"
"      -P\tGibt den wirklichen Verzeichnisnahen aus, ohne symbolische "
"Verweise.\n"
"    \n"
"    Standardmäßig wird die -L Option verwendet.\n"
"    \n"
"    Rückgabewert:\n"
"    Der Rückgabewert ist 0, außer wenn eine ungültige Option angegeben oder "
"das aktuelle\n"
"    Verzeichnis nicht gelesen werden kann."

# colon
#: builtins.c:428
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Leeranweisung.\n"
"\n"
"    Leeranweisung; das Kommando hat keine Wirkung.\n"
"\n"
"    Rückgabewert:\n"
"    Das Kommando ist immer erfolgreich."

#: builtins.c:439
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""

#: builtins.c:448
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""

#: builtins.c:457
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke "
"commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p\tuse a default value for PATH that is guaranteed to find all of\n"
"    \tthe standard utilities\n"
"      -v\tprint a description of COMMAND similar to the `type' builtin\n"
"      -V\tprint a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""

#: builtins.c:476
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \tsource file when debugging)\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert NAMEs to lower case on assignment\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert NAMEs to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the "
"`local'\n"
"    command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""

#: builtins.c:512
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Obsolete.  See `help declare'."
msgstr ""
"Setzt Variablen Werte und Eigenschaften\n"
"\n"
"    Veraltet.  Siehe `help declare'."

#: builtins.c:520
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, an error occurs,\n"
"    or the shell is not executing a function."
msgstr ""
"Definiert lokale Vatiablen.\n"
"    \n"
"    Erzeugt eine Lokale Variable NAME und weist ihr den Wert VALUE zu.  "
"OPTION\n"
"    kann eine beliebige von `declare' akzeptierte Option sein.\n"
"\n"
"    Lokale Variablen können nur innerhalb einer Funktion benutzt werden. "
"Sie\n"
"    sind nur in der sie erzeugenden Funktion und ihren Kindern "
"sichtbar.    \n"
"    \n"
"    Rückgabewert:\n"
"    Liefert \"Erfolg\" außer bei einer ungültigen Option, einem Fehler oder\n"
"    die Shell führt keine Funktion aus."

#: builtins.c:537
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \tcan be one or two hex digits\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""

#: builtins.c:571
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""

#: builtins.c:586
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""

#: builtins.c:614
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the "
"shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""

#: builtins.c:626
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters ($0 - $9), but if\n"
"    more arguments are given, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""

#: builtins.c:668
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not "
"specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\t\texecute COMMAND with an empty environment\n"
"      -l\t\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, "
"unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error "
"occurs."
msgstr ""

# exit
#: builtins.c:689
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Beendet die aktuelle Shell.\n"
"\n"
"    Beendt die die aktuelle Shell mit dem Rückgabewert N.  Wenn N nicht "
"angegeben ist,\n"
"    wird der Rückgabewert des letzten ausgeführten Kommandos übernommen."

#: builtins.c:698
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not "
"executed\n"
"    in a login shell."
msgstr ""

#: builtins.c:708
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history "
"list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then "
"EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error "
"occurs."
msgstr ""

#: builtins.c:738
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""

#: builtins.c:753
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if "
"they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's "
"notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""

#: builtins.c:767
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is "
"displayed.\n"
"    \n"
"    Options:\n"
"      -d\t\tforget the remembered location of each NAME\n"
"      -l\t\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME is the full pathname of NAME\n"
"      -r\t\tforget all remembered locations\n"
"      -t\t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\t\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""

#: builtins.c:792
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifiying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is "
"given."
msgstr ""

#: builtins.c:816
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at offset OFFSET.\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"      -r\tread the history file and append the contents to the history\n"
"    \tlist\n"
"      -w\twrite the current history to the history file\n"
"    \tand append them to the history list\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if $HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the $HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed "
"otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""

#: builtins.c:852
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlist only processes that have changed status since the last\n"
"    \tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""

#: builtins.c:879
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""

#: builtins.c:898
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \tassumed to be signal numbers for which names should be listed\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""

#: builtins.c:921
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are "
"listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise.."
msgstr ""

#: builtins.c:966
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with "
"word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as "
"word\n"
"    delimiters.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY "
"variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\t\tuse Readline to obtain the line in an interactive shell\n"
"      -i text\tUse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\t\tdo not allow backslashes to escape any characters\n"
"      -s\t\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of input "
"is\n"
"    \t\tnot read withint TIMEOUT seconds.  The value of the TMOUT\n"
"    \t\tvariable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns success only\n"
"    \t\tif input is available on the specified file descriptor.  The\n"
"    \t\texit status is greater than 128 if the timeout is exceeded\n"
"      -u fd\t\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times "
"out,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""

#: builtins.c:1006
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""

#: builtins.c:1019
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero "
"status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not follow symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG trap is inherited by shell functions.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""

#: builtins.c:1101
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that "
"fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""

#: builtins.c:1121
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before "
"exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""

#: builtins.c:1140
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""

#: builtins.c:1161
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""

#: builtins.c:1173 builtins.c:1188
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""

#: builtins.c:1204
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""

#: builtins.c:1220
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators as well, and numeric comparison operators.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last "
"read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 "
"lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""

#: builtins.c:1296
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""

#: builtins.c:1305
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of "
"its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""

#: builtins.c:1317
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives "
"signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  "
"If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands "
"associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal "
"number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is "
"given."
msgstr ""

#: builtins.c:1349
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \tincludes aliases, builtins, and functions, if and only if\n"
"    \tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \tbuiltin, or function, and returns the name of the disk file\n"
"    \tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \tor nothing if `type -t NAME' would not return `file'.\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t`function', `builtin', `file' or `', if NAME is an alias, shell\n"
"    \treserved word, shell function, shell builtin, disk file, or not\n"
"    \tfound, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not "
"found."
msgstr ""

#: builtins.c:1380
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and "
"processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""

#: builtins.c:1425
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""

#: builtins.c:1445
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for the process identified by ID, which may be a process ID or a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a a job specification, waits for all "
"processes\n"
"    in the job's pipeline.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of ID; fails if ID is invalid or an invalid option "
"is\n"
"    given."
msgstr ""

#: builtins.c:1463
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for the specified process and reports its termination status.  If\n"
"    PID is not given, all currently active child processes are waited for,\n"
"    and the return code is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of ID; fails if ID is invalid or an invalid option "
"is\n"
"    given."
msgstr ""

#: builtins.c:1478
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1492
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1510
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1531
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""

#: builtins.c:1548
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1560
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then "
"the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list "
"is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  "
"Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of "
"the\n"
"    entire construct is the exit status of the last command executed, or "
"zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1577
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS as long as the final command in the\n"
"    `while' COMMANDS has an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1589
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS as long as the final command in the\n"
"    `until' COMMANDS has an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1601
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of COMMAND."
msgstr ""

#: builtins.c:1615
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is "
"invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""

#: builtins.c:1629
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1641
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""

#: builtins.c:1656
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to \"let EXPRESSION\".\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""

#: builtins.c:1668
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the "
"conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries "
"used\n"
"    by the `test' builtin, and may be combined using the following "
"operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""

#: builtins.c:1694
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""

#: builtins.c:1751
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""

#: builtins.c:1785
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""

#: builtins.c:1815
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""

#: builtins.c:1844
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list all shell options with an indication of whether or not "
"each\n"
"    is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""

#: builtins.c:1865
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: "
"plain\n"
"    characters, which are simply copied to standard output; character "
"escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next "
"successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in printf"
"(1)\n"
"    and printf(3), printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or "
"assignment\n"
"    error occurs."
msgstr ""

#: builtins.c:1892
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no "
"options\n"
"    are supplied, existing completion specifications are printed in a way "
"that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \tNAMEs are supplied, all completion specifications\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""

#: builtins.c:1915
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches "
"against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""

#: builtins.c:1930
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are "
"supplied,\n"
"    the completion currently begin executed.  If no OPTIONs are givenm, "
"print\n"
"    the completion options for each NAME or the current completion "
"specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""

#: builtins.c:1958
msgid ""
"Read lines from the standard input into an array variable.\n"
"    \n"
"    Read lines from the standard input into the array variable ARRAY, or "
"from\n"
"    file descriptor FD if the -u option is supplied.  The variable MAPFILE "
"is\n"
"    the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are "
"copied.\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default "
"index is 0.\n"
"      -s count \tDiscard the first COUNT lines read.\n"
"      -t\t\tRemove a trailing newline from each line read.\n"
"      -u fd\t\tRead lines from file descriptor FD instead of the standard "
"input.\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read.\n"
"      -c quantum\tSpecify the number of lines read between each call to "
"CALLBACK.\n"
"    \n"
"    Arguments:\n"
"      ARRAY\t\tArray variable name to use for file data.\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned as an additional argument.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY "
"before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly."
msgstr ""

#: builtins.c:1990
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""

#~ msgid "Missing `}'"
#~ msgstr "Fehlende `}'."

#~ msgid "brace_expand> "
#~ msgstr "Klammererweiterung>"

#~ msgid "Attempt to free unknown command type `%d'.\n"
#~ msgstr "Versuche den unbekannten Kommandotyp `%d' zu freizugeben.\n"

#~ msgid "Report this to %s\n"
#~ msgstr "Schicke eine Fehlermeldung an: %s\n"

#~ msgid "Stopping myself..."
#~ msgstr "Abbruch ..."

#~ msgid "Tell %s to fix this someday.\n"
#~ msgstr "Schicke eine Fehlermeldung an: %s\n"

# Programmierfehler
#~ msgid "execute_command: bad command type `%d'"
#~ msgstr "execute_command: Falscher Kommandotyp `%d'."

#~ msgid "real\t"
#~ msgstr "Gesamt\t"

#~ msgid "user\t"
#~ msgstr "Nutzer\t"

#~ msgid "sys\t"
#~ msgstr "System\t"

#~ msgid ""
#~ "real\t0m0.00s\n"
#~ "user\t0m0.00s\n"
#~ "sys\t0m0.00s\n"
#~ msgstr ""
#~ "Gesamt\t0m0.00s\n"
#~ "Nutzer\t0m0.00s\n"
#~ "System\t0m0.00s\n"

#~ msgid "cannot duplicate fd %d to fd 1: %s"
#~ msgstr "Kann fd %d nicht auf fd 1 verdoppeln: %s"

#~ msgid "%s: output redirection restricted"
#~ msgstr "%s: Das Umlenken der Ausgabe ist verboten."

#~ msgid "Out of memory!"
#~ msgstr "Arbeitsspeicher erschöpft!"

# Debug Ausgabe
#~ msgid "You have already added item `%s'\n"
#~ msgstr "You have already added item `%s'.\n"

# Debug Ausgabe
#~ msgid "You have entered %d (%d) items.  The distribution is:\n"
#~ msgstr "You have entered %d (%d) items. The distribution is:\n"

#~ msgid "<unknown>"
#~ msgstr "<unbekannt>"

#~ msgid "%s: bg background job?"
#~ msgstr "%s: bg Hintergrundprozeß?"

# Programmierfehler
#~ msgid ""
#~ "Redirection instruction from yyparse () '%d' is\n"
#~ "out of range in make_redirection ()."
#~ msgstr ""
#~ "Umlenkung von yyparse() `%d' in make_redirection\n"
#~ "ist außerhalb des zulässigen Bereichs."

# Programmierfehler
#~ msgid "clean_simple_command () got a command with type %d."
#~ msgstr "clean_simple_command () erhielt ein Kommando vom Typ %d."

#~ msgid "got errno %d while waiting for %d"
#~ msgstr "Erhielt Fehlernummer %d beim Warten auf %d."

#~ msgid "syntax error near unexpected token `%c'"
#~ msgstr "Syntaxfehler beim unerwarteten Zeichen `%c'"

#~ msgid "print_command: bad command type `%d'"
#~ msgstr "print_command: Falscher Kommandotyp `%d'."

#~ msgid "cprintf: bad `%%' argument (%c)"
#~ msgstr "cprintf: Falsches `%%' Argument (%c)"

#~ msgid "option `%s' requires an argument"
#~ msgstr "Option `%s' erfordert ein Argument."

#~ msgid "%s: unrecognized option"
#~ msgstr "%s: Option nicht erkannt."

#~ msgid "`-c' requires an argument"
#~ msgstr "`-c' erfordert ein Argument."

#~ msgid "%s: cannot execute directories"
#~ msgstr "%s: Kann Verzeichnisse nicht ausführen."

# interner Fehler
#~ msgid "Bad code in sig.c: sigprocmask"
#~ msgstr "Falscher Code in sig.c: Sigprocmask."

#~ msgid "can't make pipes for process substitution: %s"
#~ msgstr "Kann keine Pipes für die Prozeßersetzung erzeugen: %s."

#~ msgid "reading"
#~ msgstr "lese"

#~ msgid "process substitution"
#~ msgstr "Prozeßersetzung"

#~ msgid "command substitution"
#~ msgstr "Kommandoersetzung"

# interner Fehler
#~ msgid "Can't reopen pipe to command substitution (fd %d): %s"
#~ msgstr "Kann Pipe für Kommandoersetzung nicht wieder öffnen (fd %d): %s."

#~ msgid "$%c: unbound variable"
#~ msgstr "$%c ist nicht gesetzt."

#~ msgid "%s: bad arithmetic substitution"
#~ msgstr "%s: Falsche arithmetische Ersetzung."

#~ msgid "-%s: binary operator expected"
#~ msgstr "-%s: Zweistelliger (binärer) Operator erwartet."

#~ msgid "%s[%s: bad subscript"
#~ msgstr "%s[%s: Falscher Index."

#~ msgid "[%s: bad subscript"
#~ msgstr "[%s: Falscher Index."

# Testprogramm für sh_getopts
#~ msgid "digits occur in two different argv-elements.\n"
#~ msgstr "Ziffer taucht in zwei verschiedenen Elementen von argv auf.\n"

#~ msgid "option %c\n"
#~ msgstr "Option %c\n"

#~ msgid "option a\n"
#~ msgstr "Option a\n"

#~ msgid "option b\n"
#~ msgstr "Option b\n"

#~ msgid "option c with value `%s'\n"
#~ msgstr "Option c mit Wert `%s'\n"

# Testprogramm für sh_getopts
#~ msgid "?? sh_getopt returned character code 0%o ??\n"
#~ msgstr "?? sh_getopt gab Code 0%o zurück??\n"

# Testprogramm für sh_getopts
#~ msgid "non-option ARGV-elements: "
#~ msgstr "Elemente von ARGV, die keine Optionen sind: "

# mkbuilltins Hilfsprogramm
#~ msgid "%s: Unknown flag %s.\n"
#~ msgstr "%s: Unbekannter Schalter %s.\n"

# mkbuiltins Hilfsprogramm
#~ msgid "Unknown directive `%s'"
#~ msgstr "Unbekannte Anweisung `%s'."

#~ msgid "%s requires an argument"
#~ msgstr "%s erfordert ein Argument."

#~ msgid "%s must be inside of a $BUILTIN block"
#~ msgstr "%s muß innerhalb eines $BUILTIN Blocks stehen."

#~ msgid "%s found before $END"
#~ msgstr "%s vor $END gefunden."

#~ msgid "%s already has a function (%s)"
#~ msgstr "%s hat schon eine Funktion (%s)."

# docname --> Bezeichnung ??
#~ msgid "%s already had a docname (%s)"
#~ msgstr "%s hat schon eine Bezeichnung (%s)."

#~ msgid "%s already has short documentation (%s)"
#~ msgstr "%s hat schon eine Kurzbeschreibung (%s)."

#~ msgid "%s already has a %s definition"
#~ msgstr "%s ist schon  %s definiert."

# mkbuildins Hilfsprogramm
#~ msgid "mkbuiltins: Out of virtual memory!\n"
#~ msgstr "mkbuiltins: Virtueller Speicher erschöpft!\n"

#~ msgid "read [-r] [-p prompt] [-a array] [-e] [name ...]"
#~ msgstr ""
#~ "read [-r] [-p Eingabeaufforderung] [-a Feldvariable] [-e] [Name ...]"

#~ msgid "%[DIGITS | WORD] [&]"
#~ msgstr "%[Ziffern | Wort] [&]"

#~ msgid "variables - Some variable names and meanings"
#~ msgstr "Variablen - Einige Variablennamen und ihre Bedeutung"

# alias
#~ msgid "`alias' with no arguments or with the -p option prints the list"
#~ msgstr "`alias' ohne Argumente oder mit der Option -p gibt die Liste der"

#~ msgid "of aliases in the form alias NAME=VALUE on standard output."
#~ msgstr "Synonyme in der Form NAME=WERT auf die Standardausgabe aus."

#~ msgid "Otherwise, an alias is defined for each NAME whose VALUE is given."
#~ msgstr ""
#~ "Sonst wird ein Synonym für jeden NAMEN definiert, dessen WERT angegeben "
#~ "wird."

#~ msgid "A trailing space in VALUE causes the next word to be checked for"
#~ msgstr ""
#~ "Ein Leerzeichen nach WERT bewirkt, daß das nächste WORT auf ein Synonym"

#~ msgid "alias substitution when the alias is expanded.  Alias returns"
#~ msgstr ""
#~ "untersucht wird wenn SYNONYM ausgewertet wird. `Alias' gibt wahr zurück,"

#~ msgid "true unless a NAME is given for which no alias has been defined."
#~ msgstr ""
#~ "außer wenn ein NAME angegeben wurde, für den kein SYNONYM vorhanden ist."

# unalias
#~ msgid ""
#~ "Remove NAMEs from the list of defined aliases.  If the -a option is given,"
#~ msgstr "Entfernt NAMEn aus der Liste der Synonyme. Wenn die Option -a"

#~ msgid "then remove all alias definitions."
#~ msgstr "angegeben ist, werden alle Synonyme gelöscht."

# readline
#~ msgid "Bind a key sequence to a Readline function, or to a macro.  The"
#~ msgstr ""
#~ "Verbindet eine Tastenfolge mit einer Readline-Funktion oder einem Makro. "
#~ "Die"

#~ msgid "syntax is equivalent to that found in ~/.inputrc, but must be"
#~ msgstr ""
#~ "Syntax entspricht der der Datei `~/.inputrc', sie muß jedoch als Argument"

#~ msgid ""
#~ "passed as a single argument: bind '\"\\C-x\\C-r\": re-read-init-file'."
#~ msgstr "angegeben werden. Z.B.: bind '\"\\C-x\\C-r\": re-read-init-file'."

#~ msgid "Arguments we accept:"
#~ msgstr "Gültige Argumente:"

#~ msgid ""
#~ "  -m  keymap         Use `keymap' as the keymap for the duration of this"
#~ msgstr ""
#~ "  -m Tastaturtabelle wählt die Tastaturtabelle für die Dauer dieses "
#~ "Kommandos."

#~ msgid "                     command.  Acceptable keymap names are emacs,"
#~ msgstr ""
#~ "                     Mögliche Namen für Tastaturtabellen sind: emacs"

#~ msgid ""
#~ "                     emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,"
#~ msgstr ""
#~ "                     emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,"

#~ msgid "                     vi-command, and vi-insert."
#~ msgstr "                     vi-command, und vi-insert."

#~ msgid "  -l                 List names of functions."
#~ msgstr "  -l                 Listet die Namen der Funktionen."

#~ msgid "  -P                 List function names and bindings."
#~ msgstr ""
#~ "  -P                 Listet die Namen der Funktion und deren "
#~ "Tastenzuordnung."

#~ msgid ""
#~ "  -p                 List functions and bindings in a form that can be"
#~ msgstr ""
#~ "  -p                 Listet die Funktionsnamen und deren Tastenzuordnung "
#~ "so,"

#~ msgid "                     reused as input."
#~ msgstr ""
#~ "                     daß sie als Eingabe wiederverwendet werden können."

#~ msgid "  -r  keyseq         Remove the binding for KEYSEQ."
#~ msgstr "  -r  Tastenfolge    Entfernt die Zuordnung für Tastenfolge."

#~ msgid "  -f  filename       Read key bindings from FILENAME."
#~ msgstr "  -f  Dateiname      Liest die Tastenzuordnungen von Dateiname."

#~ msgid ""
#~ "  -q  function-name  Query about which keys invoke the named function."
#~ msgstr ""
#~ "  -q  Funktionsname  Gibt die Tastenzuordnung für den Funktionsnamen aus."

#~ msgid "  -V                 List variable names and values"
#~ msgstr "  -V                 Gibt Variablennamen und deren Werte aus."

#~ msgid ""
#~ "  -v                 List variable names and values in a form that can"
#~ msgstr ""
#~ "  -v                 Gibt Variablennamen und deren Werte in einer Form "
#~ "aus,"

#~ msgid "                     be reused as input."
#~ msgstr "                     die als Eingabe wiederverwendet werden kann."

#~ msgid ""
#~ "  -S                 List key sequences that invoke macros and their "
#~ "values"
#~ msgstr "  -S                 Gibt Tastenfolgen aus, die Makros aufrufen."

#~ msgid ""
#~ "  -s                 List key sequences that invoke macros and their "
#~ "values in"
#~ msgstr "  -s                 Gibt Tastenfolgen aus, die Makros aufrufen."

#~ msgid "                     a form that can be reused as input."
#~ msgstr ""
#~ "                     Die Ausgabe kann als Eingabe wiederverwendet werden."

# break
#~ msgid "Exit from within a FOR, WHILE or UNTIL loop.  If N is specified,"
#~ msgstr ""
#~ "Bricht eine for, while oder until Schleife ab. Wenn N angegeben ist, dann"

#~ msgid "break N levels."
#~ msgstr "werden N Schleifenebenen verlassen."

# continue
#~ msgid "Resume the next iteration of the enclosing FOR, WHILE or UNTIL loop."
#~ msgstr ""
#~ "Springt zur nächsten Iteration der for, while oder until Schleife. Wenn N"

#~ msgid "If N is specified, resume at the N-th enclosing loop."
#~ msgstr ""
#~ "angegeben ist, wird mit der N-ten übergeordneten Schleife fortgefahren."

# builtin
#~ msgid "Run a shell builtin.  This is useful when you wish to rename a"
#~ msgstr ""
#~ "Führt eine Shellfunktion aus. Das ist nützlich, wenn eine Shellfunktion"

#~ msgid "shell builtin to be a function, but need the functionality of the"
#~ msgstr "umbenannt wurde, aber das ursprüngliche Verhalten benötigt wird."

#~ msgid "builtin within the function itself."
#~ msgstr " "

# cd
#~ msgid "Change the current directory to DIR.  The variable $HOME is the"
#~ msgstr ""
#~ "Setzt das Arbeitsverzeichnis auf Verz. Wenn Verz. nicht angegeben ist, "
#~ "dann"

#~ msgid "default DIR.  The variable $CDPATH defines the search path for"
#~ msgstr ""
#~ "wird in das $HOME-Verzeichnis gewechselt. In der Variable $CDPATH kann "
#~ "eine"

#~ msgid "the directory containing DIR.  Alternative directory names in CDPATH"
#~ msgstr ""
#~ "durch Doppelpunkt (:) getrennte Liste angegeben werden, in denen Verz. "
#~ "gesucht"

#~ msgid "are separated by a colon (:).  A null directory name is the same as"
#~ msgstr "wird. Beginnt Verz. mit einem `/', wird $CDPATH nicht benutzt."

#~ msgid "the current directory, i.e. `.'.  If DIR begins with a slash (/),"
#~ msgstr ""
#~ "Wenn das Verzeichnis nicht gefunden wird und die Shelloption `cdable_vars'"

#~ msgid "then $CDPATH is not used.  If the directory is not found, and the"
#~ msgstr ""
#~ "gesetzt ist, dann wird Verz. als ein Variablenname interpretiert. Ergibt"

#~ msgid "shell option `cdable_vars' is set, then try the word as a variable"
#~ msgstr "dies einen Wert für die Variable, dann wird das aktuelle"

#~ msgid "name.  If that variable has a value, then cd to the value of that"
#~ msgstr ""
#~ "Verzeichnis auf diesen Wert gesetzt. Option -P veranlaßt cd symbolische"

#~ msgid ""
#~ "variable.  The -P option says to use the physical directory structure"
#~ msgstr "Verweise zu ignorieren;  -L erzwingt das Benutzen symbolischer"

#~ msgid ""
#~ "instead of following symbolic links; the -L option forces symbolic links"
#~ msgstr "Verweise."

#~ msgid "to be followed."
#~ msgstr " "

# pwd
#~ msgid "Print the current working directory.  With the -P option, pwd prints"
#~ msgstr ""
#~ "Gibt das Arbeitsverzeichnis aus. Die Angabe von -P ignoriert symbolische"

#~ msgid "the physical directory, without any symbolic links; the -L option"
#~ msgstr "Verweise. Mit -L wird das Verwenden von symbolischen Verweisen"

#~ msgid "makes pwd follow symbolic links."
#~ msgstr "erzwungen."

# command
#~ msgid ""
#~ "Runs COMMAND with ARGS ignoring shell functions.  If you have a shell"
#~ msgstr ""
#~ "Führt das Kommando mit den Argumenten aus, ohne die Shellfunktionen zu"

#~ msgid "function called `ls', and you wish to call the command `ls', you can"
#~ msgstr "berücksichtigen.  Wenn eine Shellfunktion `ls' definiert ist, führt"

#~ msgid ""
#~ "say \"command ls\".  If the -p option is given, a default value is used"
#~ msgstr "\"command ls\" das Kommando `ls' aus.  Mit der Option -p wird ein"

#~ msgid ""
#~ "for PATH that is guaranteed to find all of the standard utilities.  If"
#~ msgstr "Standardwert für PATH verwendet.  -v gibt eine kurze Beschreibung"

#~ msgid ""
#~ "the -V or -v option is given, a string is printed describing COMMAND."
#~ msgstr "des Kommandos aus; -V eine ausführliche."

#~ msgid "The -V option produces a more verbose description."
#~ msgstr " "

# declare
#~ msgid "Declare variables and/or give them attributes.  If no NAMEs are"
#~ msgstr ""
#~ "Deklariert Variablen oder weist ihnen Werte zu.  Wenn kein Name angegeben"

#~ msgid "given, then display the values of variables instead.  The -p option"
#~ msgstr ""
#~ "ist, dann wird der Wert der Variablen ausgegeben.  Option -p gibt die"

#~ msgid "will display the attributes and values of each NAME."
#~ msgstr "Merkmale und Werte der Namen aus."

#~ msgid "The flags are:"
#~ msgstr "Die Schalter sind:"

#~ msgid "  -a\tto make NAMEs arrays (if supported)"
#~ msgstr "  -a\tDeklariert Name als Feldvariable (wenn unterstützt)."

#~ msgid "  -f\tto select from among function names only"
#~ msgstr "  -f\tZeigt nur Funktionsnamen."

#~ msgid "  -F\tto display function names without definitions"
#~ msgstr "  -F\tZeigt Funktionsnamen ohne Definition an."

#~ msgid "  -r\tto make NAMEs readonly"
#~ msgstr "  -r\tSetzt Name auf `nur Lesen'-Status."

#~ msgid "  -x\tto make NAMEs export"
#~ msgstr "  -x\tMarkiert Name für automatischen Export in alle Subshells."

#~ msgid "  -i\tto make NAMEs have the `integer' attribute set"
#~ msgstr "  -i\tSetzt den Typ von Name auf Ganzzahl."

#~ msgid "Variables with the integer attribute have arithmetic evaluation (see"
#~ msgstr ""
#~ "Wenn der Variablen ein Wert zugewiesen wird (siehe `let'), findet eine"

#~ msgid "`let') done when the variable is assigned to."
#~ msgstr "arithmetische Auswertung statt."

#~ msgid "When displaying values of variables, -f displays a function's name"
#~ msgstr ""
#~ "Wenn Variablenwerte angezeigt werden, gibt die Option -f Funktionsnamen"

#~ msgid "and definition.  The -F option restricts the display to function"
#~ msgstr "und -definitionen aus. Die Option -F beschränkt die Ausgabe auf"

#~ msgid "name only."
#~ msgstr "Funktionsnamen."

#~ msgid ""
#~ "Using `+' instead of `-' turns off the given attribute instead.  When"
#~ msgstr "`+' statt `-' schaltet das angegebene Merkmal ab. `declare'"

#~ msgid "used in a function, makes NAMEs local, as with the `local' command."
#~ msgstr "innerhalb einer Funktion wirkt wie `local'."

# typset
#~ msgid "Obsolete.  See `declare'."
#~ msgstr "Veraltet. Siehe `declare'."

# local
#~ msgid "Create a local variable called NAME, and give it VALUE.  LOCAL"
#~ msgstr ""
#~ "Erzeugt eine lokale Variable Name und weist ihr Wert zu. Die Anweisung "
#~ "kann"

#~ msgid "have a visible scope restricted to that function and its children."
#~ msgstr "nur innerhalb dieser Funktion und allen Unterfunktionen zugänglich."

# echo
#~ msgid "Output the ARGs.  If -n is specified, the trailing newline is"
#~ msgstr ""
#~ "Gibt die Argumente aus. Wenn -n angegeben ist, wird kein Zeilenumbruch"

#~ msgid "suppressed.  If the -e option is given, interpretation of the"
#~ msgstr ""
#~ "angefügt. Die Option -e interpretiert folgende Sonderzeichen zur "
#~ "Formatierung"

#~ msgid "following backslash-escaped characters is turned on:"
#~ msgstr "der Ausgabe:"

#~ msgid "\t\\a\talert (bell)"
#~ msgstr "\t\\a\tAlarm (Glocke)."

#~ msgid "\t\\b\tbackspace"
#~ msgstr "\t\\b\tSchritt zurück."

#~ msgid "\t\\c\tsuppress trailing newline"
#~ msgstr "\t\\c\tKein Zeilenumbruch."

#~ msgid "\t\\E\tescape character"
#~ msgstr "\t\\E\tEscape-Zeichen."

#~ msgid "\t\\f\tform feed"
#~ msgstr "\t\\f\tSeitenvorschub."

#~ msgid "\t\\n\tnew line"
#~ msgstr "\t\\n\tZeilenumbruch."

#~ msgid "\t\\r\tcarriage return"
#~ msgstr "\t\\r\tWagenrücklauf."

#~ msgid "\t\\t\thorizontal tab"
#~ msgstr "\t\\t\tHorizontaler Tabulator."

#~ msgid "\t\\v\tvertical tab"
#~ msgstr "\t\\v\tVertikaler Tabulator."

#~ msgid "\t\\\\\tbackslash"
#~ msgstr "\t\\\\\tDas Zeichen `\\'."

#~ msgid "\t\\num\tthe character whose ASCII code is NUM (octal)."
#~ msgstr "\t\\num\tDas Zeichen mit dem (oktalen) ASCII-Code num."

#~ msgid ""
#~ "You can explicitly turn off the interpretation of the above characters"
#~ msgstr ""
#~ "Die Option -E schaltet die Auswertung der oben angegebenen Sonderzeichen"

#~ msgid "with the -E option."
#~ msgstr "ab."

#~ msgid ""
#~ "Output the ARGs.  If -n is specified, the trailing newline is suppressed."
#~ msgstr ""
#~ "Gibt ARGUMENTE aus. Die Option -n verhindert den abschließenden "
#~ "Zeilenumbruch."

# enable
#~ msgid "Enable and disable builtin shell commands.  This allows"
#~ msgstr "Schaltet Shellfunktionen ab und an. Damit kann ein gleichnamiges"

#~ msgid "you to use a disk command which has the same name as a shell"
#~ msgstr "externes Kommando anstatt des Shellkommandos benutzt werden."

#~ msgid "builtin.  If -n is used, the NAMEs become disabled; otherwise"
#~ msgstr "-n schaltet Namen ab, sonst werden NAMEn angeschaltet."

#~ msgid "NAMEs are enabled.  For example, to use the `test' found on your"
#~ msgstr "Um z.B. die externe Funktion `test' zu verwenden,"

#~ msgid "path instead of the shell builtin version, type `enable -n test'."
#~ msgstr ""
#~ "muß `enable -n test' eingegeben werden. Auf Systemen, die Bibiliotheken"

#~ msgid "On systems supporting dynamic loading, the -f option may be used"
#~ msgstr ""
#~ "dynamisch nachladen können, kann die Option -f genutzt werden, um neue"

#~ msgid "to load new builtins from the shared object FILENAME.  The -d"
#~ msgstr ""
#~ "Shellfunktionen aus der dynamischen Bibiliothek Dateiname zu laden. -d"

#~ msgid "option will delete a builtin previously loaded with -f.  If no"
#~ msgstr "entlädt dynamisch geladene Shellfunktionen wieder. Wenn"

#~ msgid "non-option names are given, or the -p option is supplied, a list"
#~ msgstr "keine Option oder -p angegeben ist, wird eine Liste der"

#~ msgid "of builtins is printed.  The -a option means to print every builtin"
#~ msgstr "Shellfunktionen ausgegeben. -a gibt eine Liste der Shellfunktionen"

#~ msgid "with an indication of whether or not it is enabled.  The -s option"
#~ msgstr ""
#~ "aus, in der ein- und ausgeschaltete Funktionen gekennzeichnet sind; -s"

#~ msgid "restricts the output to the Posix.2 `special' builtins.  The -n"
#~ msgstr "beschränkt die Ausgabe auf Posix.2-Shellfunktionen. -n"

#~ msgid "option displays a list of all disabled builtins."
#~ msgstr "zeigt eine Liste aller abgeschalteter Funktionen an."

# eval
#~ msgid ""
#~ "Read ARGs as input to the shell and execute the resulting command(s)."
#~ msgstr "Verbindet die Argumente zu einer Kommandozeile und führt sie aus."

# getopts
#~ msgid "Getopts is used by shell procedures to parse positional parameters."
#~ msgstr "Shellprozeduren benutzen getopts, um die Kommandozeole auszuwerten."

#~ msgid "OPTSTRING contains the option letters to be recognized; if a letter"
#~ msgstr ""
#~ "Optstring enthält die zu erkennenden Buchstaben. Folgt einem Buchstaben "
#~ "ein"

#~ msgid "is followed by a colon, the option is expected to have an argument,"
#~ msgstr "Doppelpunkt, dann erwartet die Funktion ein Argument, das durch ein"

#~ msgid "which should be separated from it by white space."
#~ msgstr "Leerzeichen vom Optionszeichen getrennt ist."

#~ msgid "Each time it is invoked, getopts will place the next option in the"
#~ msgstr ""
#~ "Bei jedem Aufruf weist getopt die nächste Option der Shell-Variablen "
#~ "$name zu,"

#~ msgid "shell variable $name, initializing name if it does not exist, and"
#~ msgstr "erzeugt sie gegebenenfalls und setzt den Zeiger in der"

#~ msgid "the index of the next argument to be processed into the shell"
#~ msgstr "Shellvariablen OPTIND auf die nächste abzuarbeitende Option."

#~ msgid "variable OPTIND.  OPTIND is initialized to 1 each time the shell or"
#~ msgstr "OPTIND wird beim Start der Shell mit 1 initialisiert."

#~ msgid "a shell script is invoked.  When an option requires an argument,"
#~ msgstr "Erwartet eine Option ein Argument, wird dieses Argument in der"

#~ msgid "getopts places that argument into the shell variable OPTARG."
#~ msgstr "Shellvariablen OPTARG zurückgegeben."

#~ msgid "getopts reports errors in one of two ways.  If the first character"
#~ msgstr ""
#~ "Es gibt zwei Möglichkeiten der Fehlerbehandlung.  Wenn das erste Zeichen "
#~ "von"

#~ msgid "of OPTSTRING is a colon, getopts uses silent error reporting.  In"
#~ msgstr ""
#~ "OPTSTRING ein Doppelpunkt ist, wird keine Fehlermeldung angezeigt "
#~ "(\"stille"

#~ msgid "this mode, no error messages are printed.  If an illegal option is"
#~ msgstr ""
#~ "Fehlermeldung\") Wenn ein ungültiges Optionszeichen erkannt wird, dann "
#~ "wird"

#~ msgid "seen, getopts places the option character found into OPTARG.  If a"
#~ msgstr ""
#~ "es der Shellvariablen OPTARG zugewiesen.  Wenn ein Argument fehlt, dann"

#~ msgid "required argument is not found, getopts places a ':' into NAME and"
#~ msgstr "wird der Shellvariablen NAME ein ':' zugewiesen und an OPTARG das "

#~ msgid "sets OPTARG to the option character found.  If getopts is not in"
#~ msgstr ""
#~ "Optionszeichen übergeben.  Wenn getopt sich nicht im \"stillen\" Modus"

#~ msgid "silent mode, and an illegal option is seen, getopts places '?' into"
#~ msgstr ""
#~ "befindet und ein ungültiges Optionszeichen erkannt wird, weist getopt der"

#~ msgid "NAME and unsets OPTARG.  If a required option is not found, a '?'"
#~ msgstr ""
#~ "Variable Name '?' zu und löscht OPTARG.  Wenn eine erforderliche Option "
#~ "nicht"

#~ msgid "is placed in NAME, OPTARG is unset, and a diagnostic message is"
#~ msgstr ""
#~ "gefunden wurde, wird `?` an NAME zugewiesen, OPTARG gelöscht und eine "
#~ "Fehler-"

#~ msgid "printed."
#~ msgstr "meldung ausgegeben."

#~ msgid "If the shell variable OPTERR has the value 0, getopts disables the"
#~ msgstr ""
#~ "Wenn die Shellvariable OPTERR den Wert 0 besitzt, unterdrückt getopts die "
#~ "Aus-"

#~ msgid "printing of error messages, even if the first character of"
#~ msgstr ""
#~ "gabe von Fehlermeldungen, auch dann, wenn das erste Zeichen von OPTSTRING "
#~ "kein"

#~ msgid "OPTSTRING is not a colon.  OPTERR has the value 1 by default."
#~ msgstr "Doppelpunkt ist.  OPTERR hat standardmäßig den Wert 1."

#~ msgid "Getopts normally parses the positional parameters ($0 - $9), but if"
#~ msgstr ""
#~ "Getopts wertet normalerweise die übergebenen Parameter $0 - $9 aus, aber "
#~ "wenn"

#~ msgid "more arguments are given, they are parsed instead."
#~ msgstr "mehr Argumente angegeben sind, werden diese auch ausgewertet."

# exec
#~ msgid "Exec FILE, replacing this shell with the specified program."
#~ msgstr "Fürt Datei aus und ersetzt die Shell durch das angegebene Programm."

#~ msgid "If FILE is not specified, the redirections take effect in this"
#~ msgstr ""
#~ "Wenn kein Kommando angegeben ist, werden die Ein-/Ausgabeumleitungen auf "
#~ "die"

#~ msgid "shell.  If the first argument is `-l', then place a dash in the"
#~ msgstr ""
#~ "aufrufende Shell angewendet.  Wenn das erste Argument -l ist, dann wird "
#~ "dieses"

#~ msgid "zeroth arg passed to FILE, as login does.  If the `-c' option"
#~ msgstr ""
#~ "als nulltes Argument an die Datei übergeben (wie login).  Mit der -c "
#~ "Option"

#~ msgid "is supplied, FILE is executed with a null environment.  The `-a'"
#~ msgstr ""
#~ "wird die Datei ohne gesetzte Umgebungsvariablen ausgeführt.  Die -a Option"

#~ msgid "option means to make set argv[0] of the executed process to NAME."
#~ msgstr "setzt argv[0] des ausgeführten Prozeßes auf Name."

#~ msgid "If the file cannot be executed and the shell is not interactive,"
#~ msgstr ""
#~ "Wenn die Datei nicht ausgeführt werden kann und die Shell nicht "
#~ "interaktiv ist,"

#~ msgid "then the shell exits, unless the variable \"no_exit_on_failed_exec\""
#~ msgstr ""
#~ "dann wird sie verlassen, außer die Variable \"no_exit_on_failed_exec\" ist"

#~ msgid "is set."
#~ msgstr "gesetzt."

#~ msgid "is that of the last command executed."
#~ msgstr "der Rückkehrstatus des zuletzt ausgeführten Kommandos verwendet."

# fc
#~ msgid ""
#~ "FIRST and LAST can be numbers specifying the range, or FIRST can be a"
#~ msgstr ""
#~ "Anfang und Ende bezeichnen einen Bereich oder, wenn Anfang eine "
#~ "Zeichenkette"

#~ msgid "string, which means the most recent command beginning with that"
#~ msgstr "ist, das letzte Kommando welches mit dieser Zeichkette beginnt."

#~ msgid "string."
#~ msgstr " "

#~ msgid ""
#~ "   -e ENAME selects which editor to use.  Default is FCEDIT, then EDITOR,"
#~ msgstr ""
#~ "   -e Editor ist der aufzurufende Texteditor.  Standardmäßig wird FCEDIT, "
#~ "dann"

#~ msgid ""
#~ "      then the editor which corresponds to the current readline editing"
#~ msgstr ""
#~ "      EDITOR, anschließend der dem readline Modus entsprechende Editor"

#~ msgid "      mode, then vi."
#~ msgstr "      und sonst vi aufgerufen."

#~ msgid "   -l means list lines instead of editing."
#~ msgstr "   -l zeigt nur die Zeilen an."

#~ msgid "   -n means no line numbers listed."
#~ msgstr "   -n unterdrückt das Anzeigen von Zeilennummern."

#~ msgid ""
#~ "   -r means reverse the order of the lines (making it newest listed "
#~ "first)."
#~ msgstr ""
#~ "   -r dreht die Sortierreihenfolge um (jüngster Eintrag wird zuerst "
#~ "angezeigt)."

#~ msgid "With the `fc -s [pat=rep ...] [command]' format, the command is"
#~ msgstr ""
#~ "Mit `fc -s [Muster=Ersetzung ...] [command]' wird das Kommando wiederholt,"

#~ msgid "re-executed after the substitution OLD=NEW is performed."
#~ msgstr "nachdem die Substitution Alt=Neu durchgeführt wurde."

#~ msgid "A useful alias to use with this is r='fc -s', so that typing `r cc'"
#~ msgstr ""
#~ "Eine nützliche Aliasersetzung kann r='fc -s' sein, mit der z.B. durch `r "
#~ "cc`"

#~ msgid "runs the last command beginning with `cc' and typing `r' re-executes"
#~ msgstr ""
#~ "das letzte Kommando welches mit `cc' beginnt aufgerufen wird und die "
#~ "Eingabe"

# fg
#~ msgid "Place JOB_SPEC in the foreground, and make it the current job.  If"
#~ msgstr "Bringt den mit `^Z' angehaltenen Job in den Vordergrund.  Wenn eine"

#~ msgid "JOB_SPEC is not present, the shell's notion of the current job is"
#~ msgstr ""
#~ "Jobbezeichnung angegeben ist, dann wird der zuletzt angehaltene Job im"

#~ msgid "used."
#~ msgstr "Vordergrund gestartet."

# bg
#~ msgid "Place JOB_SPEC in the background, as if it had been started with"
#~ msgstr ""
#~ "Startet einen mit `^Z' angehaltenen Job im Hintergrund, als ob er mit `&'"

#~ msgid "`&'.  If JOB_SPEC is not present, the shell's notion of the current"
#~ msgstr ""
#~ "gestartet worden wäre. Ist keine Jobbezeichnung angegeben, wird der "
#~ "zuletzt"

#~ msgid "job is used."
#~ msgstr "angehaltene Job im Hintergrund gestartet."

# hash
#~ msgid "For each NAME, the full pathname of the command is determined and"
#~ msgstr ""
#~ "Für jeden angegebenen Namen wird der vollständige Pfadname des Kommandos"

#~ msgid "remembered.  If the -p option is supplied, PATHNAME is used as the"
#~ msgstr ""
#~ "ermittelt und gemerkt.  Wenn die -p Option angegeben wird, dann wird der"

#~ msgid "full pathname of NAME, and no path search is performed.  The -r"
#~ msgstr ""
#~ "Pfadname verwendet und keine Suche durchgeführt.  Die -r Option löscht die"

#~ msgid "option causes the shell to forget all remembered locations.  If no"
#~ msgstr ""
#~ "gespeicherten Pfade.  Wenn keine Option angegeben ist, dann werden alle"

#~ msgid ""
#~ "arguments are given, information about remembered commands is displayed."
#~ msgstr "gespeicherten Kommandos angezeigt."

# help
#~ msgid "Display helpful information about builtin commands.  If PATTERN is"
#~ msgstr ""
#~ "Gibt Hilfetexte für die eingebauten Kommandos aus.  Wenn ein Muster "
#~ "angegeben"

#~ msgid "specified, gives detailed help on all commands matching PATTERN,"
#~ msgstr ""
#~ "ist, dann wird eine detailierte Beschreibung der Kommandos angezeigt, die "
#~ "dem"

#~ msgid "otherwise a list of the builtins is printed."
#~ msgstr ""
#~ "Muster entsprechen.  Sonst werden die eingebauten Kommandos gelistet."

# history
#~ msgid "Display the history list with line numbers.  Lines listed with"
#~ msgstr ""
#~ "Zeigt den Kommandozeilenspeicher mit Zeilennummern an.  Mit `*' markierte"

#~ msgid "with a `*' have been modified.  Argument of N says to list only"
#~ msgstr ""
#~ "Zeilen wurden verändert.  Mit einer Zahl als Argument wird nur die "
#~ "angegebene"

#~ msgid "the last N lines.  The -c option causes the history list to be"
#~ msgstr ""
#~ "Anzahl Zeilen ausgegeben.  Mit der `-c' Option kann der "
#~ "Kommandozeilenspeicher"

#~ msgid ""
#~ "cleared by deleting all of the entries.  The `-w' option writes out the"
#~ msgstr ""
#~ "gelöscht werden.  Ist die `-w' Option angegeben,  wird der Kommandozeilen-"

#~ msgid ""
#~ "current history to the history file;  `-r' means to read the file and"
#~ msgstr ""
#~ "speicher in die history Datei geschrieben. `-r' liest diese Datei und fügt"

#~ msgid "append the contents to the history list instead.  `-a' means"
#~ msgstr ""
#~ "ihren Inhalt an den Kommandozeilenspeicher an.  Durch die Option `-a' "
#~ "kann der"

#~ msgid "to append history lines from this session to the history file."
#~ msgstr ""
#~ "Kommandozeilenspeicher der Sitzung an die history Datei angefügt werden."

#~ msgid "Argument `-n' means to read all history lines not already read"
#~ msgstr ""
#~ "Das Argument `-n' bewirkt, daß alle Zeilen die noch nicht aus der history "
#~ "Datei"

#~ msgid "from the history file and append them to the history list.  If"
#~ msgstr ""
#~ "gelesen wurden an den Kommandozeilenspeicher angefügt werden.  Wenn ein "
#~ "Datei-"

#~ msgid "FILENAME is given, then that is used as the history file else"
#~ msgstr ""
#~ "name angegeben ist, dann wird dieser als Name der history Datei "
#~ "verwendet.  Sonst"

#~ msgid "if $HISTFILE has a value, that is used, else ~/.bash_history."
#~ msgstr ""
#~ "wird der Inhalt der Variablen $HISTFILE und anschließend ~/.bash_history "
#~ "verwendet."

#~ msgid "If the -s option is supplied, the non-option ARGs are appended to"
#~ msgstr ""
#~ "Durch die -s Option wird bewirkt, daß die Nicht-Options-Argumente als "
#~ "eigene"

#~ msgid "the history list as a single entry.  The -p option means to perform"
#~ msgstr ""
#~ "Zeile an den Kommandospeicher angefügt werden.  Mit -p wird für jedes "
#~ "Argument"

#~ msgid ""
#~ "history expansion on each ARG and display the result, without storing"
#~ msgstr ""
#~ "die Kommandosubstitution durchgeführt und das Ergebnis angezeigt,  ohne "
#~ "jedoch"

#~ msgid "anything in the history list."
#~ msgstr "etwas im Kommandozeilenspeicher abzulegen."

# jobs
#~ msgid "Lists the active jobs.  The -l option lists process id's in addition"
#~ msgstr ""
#~ "Gibt eine Liste der aktiven Jobs aus.  Mit der -l Option werden "
#~ "zusätzlich die"

#~ msgid "to the normal information; the -p option lists process id's only."
#~ msgstr ""
#~ "Prozeßnummern und mit der -p Option nur die Prozeßnummern ausgsgegeben."

#~ msgid ""
#~ "If -n is given, only processes that have changed status since the last"
#~ msgstr ""
#~ "Die Option -n bewirkt, daß nur Jobs angezeigt werden, die ihren Status "
#~ "seid dem"

#~ msgid ""
#~ "notification are printed.  JOBSPEC restricts output to that job.  The"
#~ msgstr ""
#~ "letzten Aufruf geändert haben. Jobbez. beschränkt die Anzeige auf diesen "
#~ "Job."

#~ msgid "-r and -s options restrict output to running and stopped jobs only,"
#~ msgstr ""
#~ "-r zeigt nur laufende und -s nur gestoppte Jobs an.  Wenn keine Optionen"

#~ msgid "respectively.  Without options, the status of all active jobs is"
#~ msgstr "angegeben sind, dann wird der Status aller aktiven Jobs angezeigt."

#~ msgid ""
#~ "printed.  If -x is given, COMMAND is run after all job specifications"
#~ msgstr ""
#~ "Wenn -x in der Kommandozeile angegeben ist, wird das Kommando ausgeführt "
#~ "und"

#~ msgid ""
#~ "that appear in ARGS have been replaced with the process ID of that job's"
#~ msgstr "vorher alle vorkommenden Jobspezifikationen durch ihre Prozeßnummer"

#~ msgid "process group leader."
#~ msgstr "ersetzt."

# disown
#~ msgid "Removes each JOBSPEC argument from the table of active jobs."
#~ msgstr "Entfernt die angegebenen Jobs von der Liste der aktiven Jobs."

# kill
#~ msgid "Send the processes named by PID (or JOB) the signal SIGSPEC.  If"
#~ msgstr ""
#~ "Sendet den durch pid (oder job) angegebenen Prozessen das Signal "
#~ "SIGSPEC.  Wenn"

#~ msgid ""
#~ "SIGSPEC is not present, then SIGTERM is assumed.  An argument of `-l'"
#~ msgstr ""
#~ "kein Signal angegeben ist wird SIGTERM gesendet.  Mit der Option -l kann "
#~ "eine"

#~ msgid "lists the signal names; if arguments follow `-l' they are assumed to"
#~ msgstr ""
#~ "Liste der möglichen Signalnamen angezeigt werden.  Wenn Zahlen nach der "
#~ "Option"

#~ msgid "be signal numbers for which names should be listed.  Kill is a shell"
#~ msgstr ""
#~ "angegeben werden,  wird deren Signalbezeichnung angezeigt.  Kill ist aus "
#~ "zwei"

#~ msgid "builtin for two reasons: it allows job IDs to be used instead of"
#~ msgstr ""
#~ "Gründen eine Shellfunktion: es können Jobbezeichnungen anstatt "
#~ "Prozeßnummern"

#~ msgid "process IDs, and, if you have reached the limit on processes that"
#~ msgstr ""
#~ "genutzt werden und, wenn die maximale Anzahl laufender Prozesse erreicht "
#~ "ist"

#~ msgid ""
#~ "you can create, you don't have to start a process to kill another one."
#~ msgstr ""
#~ "braucht kein weiterer Prozeß gestartet zu werden, um einen anderen zu "
#~ "beenden."

# let
#~ msgid "Each ARG is an arithmetic expression to be evaluated.  Evaluation"
#~ msgstr ""
#~ "Jedes Argument ist ein auszuwertender arithmetischer Ausdruck.  Es werden "
#~ "long"

#~ msgid "is done in long integers with no check for overflow, though division"
#~ msgstr ""
#~ "integer Variablen verwendet.  Ein Überlauftest wird nicht ausgeführt, "
#~ "jedoch"

#~ msgid "by 0 is trapped and flagged as an error.  The following list of"
#~ msgstr ""
#~ "wird eine Division durch 0 erkannt und als Fehler gekennzeichnet.  Die"

#~ msgid "operators is grouped into levels of equal-precedence operators."
#~ msgstr "Liste von Operatoren ist in Gruppen gleichen Vorrangs geordnet."

#~ msgid "The levels are listed in order of decreasing precedence."
#~ msgstr "Die Gruppen selbst sind nach abnehmendem Vorrang sortiert."

#~ msgid "\t-, +\t\tunary minus, plus"
#~ msgstr "\t-, +\t\tVorzeichen."

#~ msgid "\t!, ~\t\tlogical and bitwise negation"
#~ msgstr "\t!, ~\t\tLogische und bitweise Negation."

#~ msgid "\t*, /, %\t\tmultiplication, division, remainder"
#~ msgstr "\t*, /, %\t\tMultiplikation, Division und Modulo."

#~ msgid "\t+, -\t\taddition, subtraction"
#~ msgstr "\t+, -\t\tAddition und Subtraktion."

#~ msgid "\t<<, >>\t\tleft and right bitwise shifts"
#~ msgstr "\t<<, >>\t\tBitweise Links- und Rechtsverschiebung."

#~ msgid "\t<=, >=, <, >\tcomparison"
#~ msgstr "\t<=, >=, <, >\tVergleichsoperatoren."

#~ msgid "\t==, !=\t\tequality, inequality"
#~ msgstr "\t==, !=\t\tGleich und ungleich."

#~ msgid "\t&\t\tbitwise AND"
#~ msgstr "\t&\t\tBitweises UND."

#~ msgid "\t^\t\tbitwise XOR"
#~ msgstr "\t^\t\tBitweises XOR."

#~ msgid "\t|\t\tbitwise OR"
#~ msgstr "\t|\t\tBitweises OR."

#~ msgid "\t&&\t\tlogical AND"
#~ msgstr "\t&&\t\tLogisches UND."

#~ msgid "\t||\t\tlogical OR"
#~ msgstr "\t||\t\tLogisches ODER."

#~ msgid "\texpr ? expr : expr"
#~ msgstr "\tAusdruck1 ? Ausdruck2 : Ausdruck3"

#~ msgid "\t\t\tconditional expression"
#~ msgstr "\t\t\tBedingte Befehlsausführung."

#~ msgid "\t=, *=, /=, %=,"
#~ msgstr "\t=, *=, /=, %=,"

#~ msgid "\t+=, -=, <<=, >>=,"
#~ msgstr "\t+=, -=, <<=, >>=,"

#~ msgid "\t&=, ^=, |=\tassignment"
#~ msgstr "\t&=, ^=, |=\tZuweisungen."

#~ msgid "is replaced by its value (coerced to a long integer) within"
#~ msgstr ""
#~ "Ausdruck durch ihren in long integer umgewandelten Wert ersetzt. Um "

#~ msgid "an expression.  The variable need not have its integer attribute"
#~ msgstr "die Variable in einem Ausdruck verwenden zu können, muß ihr "

#~ msgid "turned on to be used in an expression."
#~ msgstr "Integerattribut nicht aktiviert sein."

#~ msgid "Operators are evaluated in order of precedence.  Sub-expressions in"
#~ msgstr "Die Operatoren werden in Reihenfolge ihres Vorrangs ausgewertet."

#~ msgid "parentheses are evaluated first and may override the precedence"
#~ msgstr ""
#~ "Geklammerte Teilausdrücke werden zuerst ausgewertet und können von den"

#~ msgid "rules above."
#~ msgstr "oben angegebenen Vorrangregeln abweichen."

#~ msgid "If the last ARG evaluates to 0, let returns 1; 0 is returned"
#~ msgstr "Wenn das zuletzt ausgewertete Argument 0 ergibt, liefert let "

#~ msgid "otherwise."
#~ msgstr "1 als Rückgabewert, sonst 0."

# read
#~ msgid "One line is read from the standard input, and the first word is"
#~ msgstr ""
#~ "Es wird eine Zeile von der Standardeingabe gelesen und das erste Wort der"

#~ msgid ""
#~ "assigned to the first NAME, the second word to the second NAME, and so"
#~ msgstr ""
#~ "ersten Variablen NAME zugewiesen, das zweite Wort der zweiten Variablen "
#~ "und so"

#~ msgid ""
#~ "on, with leftover words assigned to the last NAME.  Only the characters"
#~ msgstr ""
#~ "weiter,  bis ein Wort der letzten Variablen zugewiesen wurde.  Nur die in "
#~ "$IFS"

#~ msgid "found in $IFS are recognized as word delimiters.  The return code is"
#~ msgstr ""
#~ "angegebenen Zeichen werden als Trennzeichen erkannt.  Wenn kein EOF "
#~ "Zeichen"

#~ msgid ""
#~ "zero, unless end-of-file is encountered.  If no NAMEs are supplied, the"
#~ msgstr ""
#~ "aufgetreten ist, ist der Rückgabewert Null.  Wenn kein NAME angegeben "
#~ "wurde,"

#~ msgid ""
#~ "line read is stored in the REPLY variable.  If the -r option is given,"
#~ msgstr ""
#~ "verwendet read die REPLY Variable.  Durch die Option -r wird das "
#~ "Auswerten von"

#~ msgid "this signifies `raw' input, and backslash escaping is disabled.  If"
#~ msgstr ""
#~ "mit `\\' markierten  Sonderzeichen unterdrückt.  Wenn die Option -r "
#~ "angegeben"

#~ msgid "the `-p' option is supplied, the string supplied as an argument is"
#~ msgstr ""
#~ "ist, dann wird die Eingabeaufforderung ohne einen abschließenden "
#~ "Zeilenumbruch"

#~ msgid ""
#~ "output without a trailing newline before attempting to read.  If -a is"
#~ msgstr ""
#~ "angezeigt.  Wenn die Option -a angegeben ist, dann wird die Eingabe an die"

#~ msgid ""
#~ "supplied, the words read are assigned to sequential indices of ARRAY,"
#~ msgstr ""
#~ "Feldvariable ARRAY übergeben und für jeden Eintrag der Index von Null "
#~ "beginnend"

#~ msgid "starting at zero.  If -e is supplied and the shell is interactive,"
#~ msgstr ""
#~ "um Eins erhöht wird.  Mit der -e Option wird bei einer interaktiven Shell "
#~ "die"

#~ msgid "readline is used to obtain the line."
#~ msgstr ""
#~ "die readline Funktionen aktiviert, um die Eingabezeile zu editieren."

# return
#~ msgid ""
#~ "Causes a function to exit with the return value specified by N.  If N"
#~ msgstr ""
#~ "Beendet eine Shellfunktion und setzt den Rückgabewert auf N.  Wenn kein "
#~ "Rückga-"

#~ msgid "is omitted, the return status is that of the last command."
#~ msgstr ""
#~ "bewert angegeben ist, wird der des zuletzt ausgeführten Kommandos "
#~ "verwendet."

# set
#~ msgid "    -a  Mark variables which are modified or created for export."
#~ msgstr ""
#~ "    -a  Markiert erzeugte oder veränderte Variablen als exportierbar."

#~ msgid "    -b  Notify of job termination immediately."
#~ msgstr "    -b  Zeigt das Beenden von Prozessen sofort an."

#~ msgid "    -e  Exit immediately if a command exits with a non-zero status."
#~ msgstr ""
#~ "    -e  Beendet die Shell sofort, wenn ein Kommando ein Fehler "
#~ "zurückliefert."

#~ msgid "    -f  Disable file name generation (globbing)."
#~ msgstr "    -f  Unterdrückt das Erzeugen von Dateinamen."

#~ msgid "    -h  Remember the location of commands as they are looked up."
#~ msgstr "    -h  Speichert die eingegebenen Kommandos sofort."

#~ msgid ""
#~ "    -i  Force the shell to be an \"interactive\" one.  Interactive shells"
#~ msgstr ""
#~ "    -i  Erzwingt, daß die Shell interaktiv arbeitet.  Interaktive Shells"

#~ msgid "        always read `~/.bashrc' on startup."
#~ msgstr ""
#~ "        interpretieren beim Aufrufen den Inhalt der Datei  `~/.bashrc'."

#~ msgid "    -k  All assignment arguments are placed in the environment for a"
#~ msgstr ""
#~ "    -k  Die komplette Kommandozeile wird in die Umgebung der Funktion"

#~ msgid "        command, not just those that precede the command name."
#~ msgstr ""
#~ "        geschrieben, nicht bloß die Argumente nach dem Funktionsnamen."

#~ msgid "    -m  Job control is enabled."
#~ msgstr "    -m  Jobsteuerung wird aktiviert."

#~ msgid "    -n  Read commands but do not execute them."
#~ msgstr "    -n  Kommandos werden gelesen aber nicht ausgeführt."

#~ msgid "    -o option-name"
#~ msgstr "    -o Option"

#~ msgid "        Set the variable corresponding to option-name:"
#~ msgstr "        Setzt die angegebene Option:"

#~ msgid "            allexport    same as -a"
#~ msgstr "            allexport    Wie die Option -a."

#~ msgid "            braceexpand  same as -B"
#~ msgstr "            braceexpand  Wie die Option -B."

#~ msgid "            emacs        use an emacs-style line editing interface"
#~ msgstr ""
#~ "            emacs        Schaltet den Kommandozeileneditor in den emacs-"
#~ "Stil."

#~ msgid "            errexit      same as -e"
#~ msgstr "            errexit      Wie die Option -e."

#~ msgid "            hashall      same as -h"
#~ msgstr "            hashall      Wie die Option -h."

#~ msgid "            histexpand   same as -H"
#~ msgstr "            histexpand   Wie die Option -H."

#~ msgid "            ignoreeof    the shell will not exit upon reading EOF"
#~ msgstr ""
#~ "            ignoreeof    Shell wird nach dem  Lesen von EOF nicht "
#~ "verlassen ."

#~ msgid "            interactive-comments"
#~ msgstr "            interactive-comments"

#~ msgid ""
#~ "                         allow comments to appear in interactive commands"
#~ msgstr ""
#~ "                         Kommentare werden auch in der Kommandozeile "
#~ "erlaubt."

#~ msgid "            keyword      same as -k"
#~ msgstr "            keyword      Wie die Option -k."

#~ msgid "            monitor      same as -m"
#~ msgstr "            monitor      Wie die Option -m."

#~ msgid "            noclobber    same as -C"
#~ msgstr "            noclobber    Wie die Option -C."

#~ msgid "            noexec       same as -n"
#~ msgstr "            noexec       Wie die Option -n."

#~ msgid "            noglob       same as -f"
#~ msgstr "            noglob       Wie die Option -f."

#~ msgid "            notify       save as -b"
#~ msgstr "            notify       Wie die Option -b."

#~ msgid "            nounset      same as -u"
#~ msgstr "            nounset      Wie die Option -u."

#~ msgid "            onecmd       same as -t"
#~ msgstr "            onecmd       Wie die Option -t."

#~ msgid "            physical     same as -P"
#~ msgstr "            physical     Wie die Option -P."

#~ msgid ""
#~ "            posix        change the behavior of bash where the default"
#~ msgstr ""
#~ "            posix        Ändert das Verhalten der Shell, wo sie vom,"

#~ msgid ""
#~ "                         operation differs from the 1003.2 standard to"
#~ msgstr "                         1003.2 Standard abweicht, zu einem POSIX "

#~ msgid "                         match the standard"
#~ msgstr "                         kompatibelen Verhalten."

#~ msgid "            privileged   same as -p"
#~ msgstr "            privileged   Wie die Option -p."

#~ msgid "            verbose      same as -v"
#~ msgstr "            verbose      Wie die Option -v."

#~ msgid "            vi           use a vi-style line editing interface"
#~ msgstr ""
#~ "            vi           Schaltet den Kommandozeileneditor in den vi-Stil."

#~ msgid "            xtrace       same as -x"
#~ msgstr "            xtrace       Wie die Option -x."

#~ msgid ""
#~ "    -p  Turned on whenever the real and effective user ids do not match."
#~ msgstr ""
#~ "    -p  Ist aktiviert, wenn die reale und effektive Nutzer ID nicht "
#~ "überein-"

#~ msgid "        Disables processing of the $ENV file and importing of shell"
#~ msgstr ""
#~ "        stimmen.  Die $ENV Datei wird nicht ausgeführt und keine "
#~ "Shellfunk-"

#~ msgid ""
#~ "        functions.  Turning this option off causes the effective uid and"
#~ msgstr ""
#~ "        tionen importiert.  Das Deaktivieren dieser Option setzt die "
#~ "Effektive"

#~ msgid "        gid to be set to the real uid and gid."
#~ msgstr "        uid und gid auf die Reale uid und gid."

#~ msgid "    -t  Exit after reading and executing one command."
#~ msgstr ""
#~ "    -t  Beendet die Shell sofort nach Ausfühern eines einzelnen Kommandos."

#~ msgid "    -u  Treat unset variables as an error when substituting."
#~ msgstr ""
#~ "    -u  Der Versuch leere (ungesetzte) Variablen zu erweitern erzeugt "
#~ "einen Fehler."

#~ msgid "    -v  Print shell input lines as they are read."
#~ msgstr "    -v  Gibt die Kommandozeilen aus wie sie gelesenen wurden."

#~ msgid "    -x  Print commands and their arguments as they are executed."
#~ msgstr ""
#~ "    -x  Gibt die Kommandos mit ihren Argumenten aus wie es ausgeführt "
#~ "wird."

#~ msgid "    -B  the shell will perform brace expansion"
#~ msgstr "    -B  Schaltet die Klammernerweiterung der Shell ein."

#~ msgid "    -H  Enable ! style history substitution.  This flag is on"
#~ msgstr ""
#~ "    -H  Schaltet den Zugriff auf den Kommandozeilenspeicher durch `!' ein."

#~ msgid "        by default."
#~ msgstr "        Diese Option ist standardmäßig aktiviert."

#~ msgid "    -C  If set, disallow existing regular files to be overwritten"
#~ msgstr ""
#~ "    -C  Verhindert das Überschreiben von existierenden Dateien durch"

#~ msgid "        by redirection of output."
#~ msgstr "        Umleiten der Ausgabe (wie noclobber)."

#~ msgid "    -P  If set, do not follow symbolic links when executing commands"
#~ msgstr ""
#~ "    -P  Symbolische Verweise werden beim Ausführen von Kommandos, wie z."
#~ "B. cd"

#~ msgid "        such as cd which change the current directory."
#~ msgstr "        welches das aktuelle Arbeitsverzeichnis ändert, ignoriert."

#~ msgid "Using + rather than - causes these flags to be turned off.  The"
#~ msgstr ""
#~ "Durch `+' an Stelle von `-' kann eine Option deaktiviert werden.  Die "
#~ "Optionen"

#~ msgid "flags can also be used upon invocation of the shell.  The current"
#~ msgstr ""
#~ "können auch beim Aufruf der Shell benutzt werden.  Die gegenwärtig "
#~ "aktivierten"

#~ msgid ""
#~ "set of flags may be found in $-.  The remaining n ARGs are positional"
#~ msgstr ""
#~ "Optionen sind in der Variablen $- gespeichert.  Die verbleibenden n "
#~ "Argumente"

#~ msgid "parameters and are assigned, in order, to $1, $2, .. $n.  If no"
#~ msgstr ""
#~ "sind Parameter und werden den Variablen $1, $2, .. $n zugewiesen.  Wenn "
#~ "kein"

#~ msgid "ARGs are given, all shell variables are printed."
#~ msgstr "Argument angegeben ist, dann werden alle Shellvariablen ausgegeben."

# unset
#~ msgid "For each NAME, remove the corresponding variable or function.  Given"
#~ msgstr ""
#~ "Für jeden angegebenen NAMEn wird die entsprechende Variable oder Funktion "
#~ "ge-"

#~ msgid "the `-v', unset will only act on variables.  Given the `-f' flag,"
#~ msgstr ""
#~ "löscht.  Mit `-v' werden nur Variablen und mit `-f' nur Funktionen "
#~ "gelöscht."

#~ msgid "unset will only act on functions.  With neither flag, unset first"
#~ msgstr ""
#~ "Wenn kein Schalter angegeben ist, wird zunächst eine Variable gesucht und "
#~ "wenn"

#~ msgid "tries to unset a variable, and if that fails, then tries to unset a"
#~ msgstr ""
#~ "eine solche nicht gefunden wurde, dann wird versucht eine Funktion zu "
#~ "löschen."

#~ msgid ""
#~ "function.  Some variables (such as PATH and IFS) cannot be unset; also"
#~ msgstr ""
#~ "Einige Variablen (z.B. PATH und IFS) können nicht gelöscht werden.  Siehe"

#~ msgid "see readonly."
#~ msgstr "diesbezüglich auch die Hilfe der Funktion readonly."

# export
#~ msgid "NAMEs are marked for automatic export to the environment of"
#~ msgstr ""
#~ "Die NAMEn werden für den automatischen Export in die Umgebung von der "
#~ "Shell"

#~ msgid "subsequently executed commands.  If the -f option is given,"
#~ msgstr ""
#~ "gestarteten Prozesse markiert.  Wenn die -f Option angegenen ist, dann "
#~ "bezeich-"

#~ msgid "the NAMEs refer to functions.  If no NAMEs are given, or if `-p'"
#~ msgstr ""
#~ "nen die NAME'n Funktionen.  Wenn keine NAMEn angegeben sind, oder die `-p'"

#~ msgid "is given, a list of all names that are exported in this shell is"
#~ msgstr ""
#~ "Option angegeben ist, dann wird eine Liste aller von der Shell "
#~ "exportierter"

#~ msgid "printed.  An argument of `-n' says to remove the export property"
#~ msgstr ""
#~ "Namen ausgegeben.  Mit dem Argument `-n' wird die Exporteigenschaft des "
#~ "NAMENs"

#~ msgid "from subsequent NAMEs.  An argument of `--' disables further option"
#~ msgstr ""
#~ "gelöscht.  Ein Argument `--' verhindert, daß nach diesem Zeichen weitere"

#~ msgid "processing."
#~ msgstr "Optionen ausgewertet werden."

# readonly
#~ msgid ""
#~ "The given NAMEs are marked readonly and the values of these NAMEs may"
#~ msgstr ""
#~ "Die angegebenen NAMEn werden als Nur-Lesen markiert.  Deren Inhalte können"

#~ msgid "not be changed by subsequent assignment.  If the -f option is given,"
#~ msgstr ""
#~ "nicht mehr geändert werden.  Wenn die -f Option angegeben wird, dann "
#~ "werden nur"

#~ msgid "then functions corresponding to the NAMEs are so marked.  If no"
#~ msgstr ""
#~ "Funktionen markiert.  Ohne oder mit dem `-p' Argument, werden alle auf "
#~ "Nur- "

#~ msgid ""
#~ "arguments are given, or if `-p' is given, a list of all readonly names"
#~ msgstr ""
#~ "Lesen gesetzte Namen ausgegeben.  Mit dem Argument `-n' kann die Nur-Lese"

#~ msgid ""
#~ "is printed.  An argument of `-n' says to remove the readonly property"
#~ msgstr ""
#~ "Eigenschaft für die angegebenen Namen entfernt werden.  Der `-a' Schalter"

#~ msgid "from subsequent NAMEs.  The `-a' option means to treat each NAME as"
#~ msgstr ""
#~ "bewirkt, daß jeder Name als Feldvariable behandelt wird.  Das Argument "
#~ "`--'"

#~ msgid "an array variable.  An argument of `--' disables further option"
#~ msgstr "unterdrückt das Auswerten weiterer Optionen."

# shift
#~ msgid ""
#~ "The positional parameters from $N+1 ... are renamed to $1 ...  If N is"
#~ msgstr ""
#~ "Die Positionsvariablen $N+1 ... werden nach $1 ... umbenannt.  Wenn N "
#~ "nicht"

#~ msgid "not given, it is assumed to be 1."
#~ msgstr "angegeben ist, dann wird 1 verwendet."

# source
#~ msgid "Read and execute commands from FILENAME and return.  The pathnames"
#~ msgstr ""
#~ "Liest und führt anschließend die Kommandos in DATEINAME aus.  $PATH wird"

#~ msgid "in $PATH are used to find the directory containing FILENAME."
#~ msgstr "als Suchpfad benutzt, um DATEINAME zu finden."

# suspend
#~ msgid "Suspend the execution of this shell until it receives a SIGCONT"
#~ msgstr ""
#~ "Hält das Ausführen der Shell solange an, bis sie das Signal SIGCONT "
#~ "empfängt."

#~ msgid "signal.  The `-f' if specified says not to complain about this"
#~ msgstr ""
#~ "Die `-f' Option unterdrückt eine Warnung, wenn es sich um eine Login Shell"

#~ msgid "being a login shell if it is; just suspend anyway."
#~ msgstr "handelt und hält auch deren Abarbeitung an."

# test
#~ msgid "Exits with a status of 0 (trueness) or 1 (falseness) depending on"
#~ msgstr ""
#~ "Liefert den Rückgabewert 0 (wahr) oder 1 (falsch), abhängig vom Ergebnis "
#~ "des"

#~ msgid "the evaluation of EXPR.  Expressions may be unary or binary.  Unary"
#~ msgstr ""
#~ "Ausdruckes EXPR.  Die Ausdrücke können ein- (unär) oder zweistellig "
#~ "(binär) sein."

#~ msgid "expressions are often used to examine the status of a file.  There"
#~ msgstr ""
#~ "Einstellige Ausdrücke werden oft zum Ermitteln eines Dateizustandes "
#~ "verwendet."

#~ msgid "are string operators as well, and numeric comparison operators."
#~ msgstr ""
#~ "Es gibt außerden Zeichenketten- und numerische Vergleichsoperatoren."

#~ msgid "File operators:"
#~ msgstr "Datei Operatoren:"

#~ msgid "    -b FILE        True if file is block special."
#~ msgstr ""
#~ "    -b DATEI       Wahr, wenn der Dateiname ein Blockgerät bezeichnet."

#~ msgid "    -c FILE        True if file is character special."
#~ msgstr ""
#~ "    -c DATEI       Wahr, wenn der Dateiname ein sequentielles Gerät "
#~ "bezeichnet."

#~ msgid "    -d FILE        True if file is a directory."
#~ msgstr "    -d DATEI       Wahr, wenn es ein Verzeichnis ist."

#~ msgid "    -e FILE        True if file exists."
#~ msgstr "    -e DATEI       Wahr, wenn die Datei existiert."

#~ msgid "    -f FILE        True if file exists and is a regular file."
#~ msgstr ""
#~ "    -f DATEI       Wahr, wenn die Datei existiert und eine reguläre Datei "
#~ "ist."

#~ msgid "    -g FILE        True if file is set-group-id."
#~ msgstr "    -g DATEI       Wahr, wenn das SGID Bit gesetzt ist."

#~ msgid "    -h FILE        True if file is a symbolic link.  Use \"-L\"."
#~ msgstr ""
#~ "    -h DATEI       Wahr, wenn FILE symbolischer Verweis ist. (Besser -L "
#~ "verw.)"

#~ msgid "    -L FILE        True if file is a symbolic link."
#~ msgstr "    -L DATEI       Wahr, wenn FIIE einen symbolischen Verweis ist."

#~ msgid "    -k FILE        True if file has its \"sticky\" bit set."
#~ msgstr ""
#~ "    -k DATEI       Wahr, wenn nur der Besitzer die Datei ändern darf "
#~ "(sticky)."

#~ msgid "    -p FILE        True if file is a named pipe."
#~ msgstr ""
#~ "    -p DATEI       Wahr, wenn FILE eine benannte Pipeline (named pipe) "
#~ "ist."

#~ msgid "    -r FILE        True if file is readable by you."
#~ msgstr ""
#~ "    -r DATEI       Wahr, wenn die Datei vom aktuellen Benutzer lesbar ist."

#~ msgid "    -s FILE        True if file exists and is not empty."
#~ msgstr ""
#~ "    -s DATEI       Wahr, wenn die Datei existiert und nicht leer ist."

#~ msgid "    -S FILE        True if file is a socket."
#~ msgstr "    -S DATEI       Wahr, wenn die Datei ein \"Socket\" ist."

#~ msgid "    -t FD          True if FD is opened on a terminal."
#~ msgstr ""
#~ "    -t FD          Wahr, wenn die Dateinummer FD für ein Terminal "
#~ "geöffnet ist."

#~ msgid "    -u FILE        True if the file is set-user-id."
#~ msgstr ""
#~ "    -u DATEI       Wahr, wenn für diese Datei das SUID Bit gesetzt ist."

#~ msgid "    -w FILE        True if the file is writable by you."
#~ msgstr ""
#~ "    -w DATEI       Wahr, wenn die Datei vom aktuellen Benutzer schreibbar "
#~ "ist."

#~ msgid "    -x FILE        True if the file is executable by you."
#~ msgstr ""
#~ "    -x DATEI       Wahr, wenn die Datei vom aktuellen Benutzer ausführbar "
#~ "ist."

#~ msgid "    -O FILE        True if the file is effectively owned by you."
#~ msgstr ""
#~ "    -O DATEI       Wahr, wenn der aktuelle Benutzer Eigentümer der Datei "
#~ "ist."

#~ msgid ""
#~ "    -G FILE        True if the file is effectively owned by your group."
#~ msgstr ""
#~ "    -G DATEI       Wahr, wenn GID des Benutzers und der Datei "
#~ "übereinstimmen."

#~ msgid "  FILE1 -nt FILE2  True if file1 is newer than (according to"
#~ msgstr ""
#~ "  DATEI1 -nt DATEI2  Wahr, wenn der letzte Änderungszeitpunkt von DATEI1 "
#~ "jünger"

#~ msgid "                   modification date) file2."
#~ msgstr "                   ist als der von DATEI2."

#~ msgid "  FILE1 -ot FILE2  True if file1 is older than file2."
#~ msgstr "  DATEI1 -ot DATEI2  Wahr, wenn DATEI1 älter ist als DATEI2."

#~ msgid "  FILE1 -ef FILE2  True if file1 is a hard link to file2."
#~ msgstr ""
#~ "  DATEI1 -ef DATEI2  Wahr, wenn beide Inodes übereinstimmen (hard link)."

#~ msgid "String operators:"
#~ msgstr "Operatoren für Zeichenketten (Strings):"

#~ msgid "    -z STRING      True if string is empty."
#~ msgstr "    -z STRING      Wahr, wenn die Länge der Zeichenkette Null ist."

#~ msgid "    -n STRING"
#~ msgstr "    -n STRING"

#~ msgid "    STRING         True if string is not empty."
#~ msgstr ""
#~ "    STRING         Wahr, wenn die Länge der Zeichenkette größer als Null "
#~ "ist."

#~ msgid "    STRING1 = STRING2"
#~ msgstr "    STRING1 = STRING2"

#~ msgid "                   True if the strings are equal."
#~ msgstr "                   Wahr, wenn die Zeichenketten identisch sind."

#~ msgid "    STRING1 != STRING2"
#~ msgstr "    STRING1 != STRING2"

#~ msgid "                   True if the strings are not equal."
#~ msgstr ""
#~ "                   Wahr, wenn die Zeichenketten unterschiedlich sind."

#~ msgid "    STRING1 < STRING2"
#~ msgstr "    STRING1 < STRING2"

#~ msgid ""
#~ "                   True if STRING1 sorts before STRING2 lexicographically"
#~ msgstr ""
#~ "                   Wahr, wenn STRING1 vor STRING2 alphabetisch geordnet "
#~ "ist."

#~ msgid "    STRING1 > STRING2"
#~ msgstr "    STRING1 > STRING2"

#~ msgid ""
#~ "                   True if STRING1 sorts after STRING2 lexicographically"
#~ msgstr ""
#~ "                   Wahr, wenn STRING1 nach STRING2 alphabetisch geordnet "
#~ "ist."

#~ msgid "Other operators:"
#~ msgstr "Andere Operatoren:"

#~ msgid "    ! EXPR         True if expr is false."
#~ msgstr "    ! EXPR         Wahr, wenn der Ausdruck EXPR `falsch' liefert."

#~ msgid "    EXPR1 -a EXPR2 True if both expr1 AND expr2 are true."
#~ msgstr ""
#~ "    EXPR1 -a EXPR2 Wahr, wenn die Ausdrücke EXPR1 und EXPR2 `wahr' "
#~ "liefern."

#~ msgid "    EXPR1 -o EXPR2 True if either expr1 OR expr2 is true."
#~ msgstr ""
#~ "    EXPR1 -o EXPR2 Wahr, wenn entweder EXPR1 oder EXPR2 wahr liefern."

#~ msgid "    arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,"
#~ msgstr ""
#~ "    arg1 OP arg2   Arithmetische Operatoren. OP kann -eq, -ne, -lt, -le, -"
#~ "gt"

#~ msgid "                   -lt, -le, -gt, or -ge."
#~ msgstr "                   oder -ge sein."

#~ msgid "Arithmetic binary operators return true if ARG1 is equal, not-equal,"
#~ msgstr ""
#~ "Diese binären arithmetischen Operatoren liefern Wahr, wenn ARG1 gleich,"

#~ msgid ""
#~ "less-than, less-than-or-equal, greater-than, or greater-than-or-equal"
#~ msgstr ""
#~ "ungleich, kleiner als, kleiner gleich, größer als oder größer gleich"

#~ msgid "than ARG2."
#~ msgstr "ARG2 ist."

# [
#~ msgid "This is a synonym for the \"test\" builtin, but the last"
#~ msgstr ""
#~ "Dies ist ein Synonym für die Shellfunktion test.  Das letzte Argument muß "
#~ "ein"

#~ msgid "argument must be a literal `]', to match the opening `['."
#~ msgstr "`]' sein, das mit dem öffnenden `[' korrespondiert."

# times
#~ msgid "Print the accumulated user and system times for processes run from"
#~ msgstr ""
#~ "Gibt die verbrauchte Benutzer- und Systemzeit für die Shell und der von"

#~ msgid "the shell."
#~ msgstr "ihr gestarteten Prozesse aus."

# trap
#~ msgid "The command ARG is to be read and executed when the shell receives"
#~ msgstr ""
#~ "Die Shell fängt die in SIG_SPEC angegebenen Signale ab führt das Kommando "
#~ "ARG"

#~ msgid "signal(s) SIGNAL_SPEC.  If ARG is absent all specified signals are"
#~ msgstr ""
#~ "aus.  Wenn kein ARG angegeben ist, werden alle bezeichneten Signale "
#~ "zurück-"

#~ msgid "reset to their original values.  If ARG is the null string each"
#~ msgstr ""
#~ "gesetzt.  Ist ARG eine leere Zeichenkette, dann wird jedes angegebne Sig-"

#~ msgid "SIGNAL_SPEC is ignored by the shell and by the commands it invokes."
#~ msgstr ""
#~ "nal von der Shell und den von ihr aufgerufenen Kommandos ignoriert.  Wenn "
#~ "das"

#~ msgid "If SIGNAL_SPEC is EXIT (0) the command ARG is executed on exit from"
#~ msgstr ""
#~ "Signal EXIT (0) abgefangen wird, dann wird ARG bei Verlassen der Shell "
#~ "ausge-"

#~ msgid "the shell.  If SIGNAL_SPEC is DEBUG, ARG is executed after every"
#~ msgstr ""
#~ "führt.  Durch Abfangen des Signals DEBUG, wird ARG nach jedem Kommando"

#~ msgid "command.  If ARG is `-p' then the trap commands associated with"
#~ msgstr ""
#~ "aufgerufen.  Mit `-p' werden Kommandos angezeigt, die für jedes "
#~ "abgefangene"

#~ msgid "each SIGNAL_SPEC are displayed.  If no arguments are supplied or if"
#~ msgstr ""
#~ "Signal ausgeführt werden.  Wenn keine Argumente angegeben sind, oder wenn "
#~ "das"

#~ msgid "only `-p' is given, trap prints the list of commands associated with"
#~ msgstr ""
#~ "Argument `-p' angegeben ist, wird eine  Liste der Kommandos für jedes "
#~ "abgefan-"

#~ msgid ""
#~ "each signal number.  SIGNAL_SPEC is either a signal name in <signal.h>"
#~ msgstr ""
#~ "gene Signal angezeigt.  SIGNAL_SPEC ist entweder ein Signalname (aus "
#~ "signal.h)"

#~ msgid ""
#~ "or a signal number.  `trap -l' prints a list of signal names and their"
#~ msgstr ""
#~ "oder eine Signalnummer.  `trap -l' gibt eine Liste der Signalnamen und "
#~ "der ent-"

#~ msgid "corresponding numbers.  Note that a signal can be sent to the shell"
#~ msgstr ""
#~ "sprechenden Nummern aus.  Ein Signal kann an eine Shell mit dem Befehl "
#~ "\"kill"

#~ msgid "with \"kill -signal $$\"."
#~ msgstr "-signal $$\" gesendet werden."

# type
#~ msgid "For each NAME, indicate how it would be interpreted if used as a"
#~ msgstr ""
#~ "Gibt aus, wie der angegebene NAME interpretiert würde, wenn er in der"

#~ msgid "If the -t option is used, returns a single word which is one of"
#~ msgstr ""
#~ "Die Option -t bewirkt, daß eins der Worte: `alias', `keyword', `function',"

#~ msgid ""
#~ "`alias', `keyword', `function', `builtin', `file' or `', if NAME is an"
#~ msgstr ""
#~ "`file' oder `' ausgegeben wird, wenn NAME ein Alias, ein in der Shell "
#~ "reser-"

#~ msgid ""
#~ "alias, shell reserved word, shell function, shell builtin, disk file,"
#~ msgstr ""
#~ "viertes Wort, eine Skriptfunktion, eine eingebaute Shellfunktion, eine "
#~ "Datei"

#~ msgid "or unfound, respectively."
#~ msgstr "ist oder kein Kommandotyp gefunden wurde."

#~ msgid "If the -p flag is used, either returns the name of the disk file"
#~ msgstr ""
#~ "Wenn der -p Schalter angegeben ist, dann wird, wenn eine entsprechende "
#~ "Datei"

#~ msgid "that would be executed, or nothing if -t would not return `file'."
#~ msgstr "existiert, ihr Name ausgegegeben,"

#~ msgid "If the -a flag is used, displays all of the places that contain an"
#~ msgstr ""
#~ "Mit dem -a Schalter werden alle ausführbaren Dateien mit dem Namen `file'"

#~ msgid ""
#~ "executable named `file'.  This includes aliases and functions, if and"
#~ msgstr ""
#~ "angezeigt.  Dieses schließt Aliase und Funktionen ein, aber nur dann"

#~ msgid "only if the -p flag is not also used."
#~ msgstr "wenn nicht gleichzeitig der -p Schalter gesetzt ist."

#~ msgid "Type accepts -all, -path, and -type in place of -a, -p, and -t,"
#~ msgstr ""
#~ "Type akzeptiert auch die Argumente -all, -path und -type an Stelle von -a,"

#~ msgid "respectively."
#~ msgstr "-p und -t."

# ulimit
#~ msgid "Ulimit provides control over the resources available to processes"
#~ msgstr ""
#~ "Ulimit steuert die Ressourcen, die den von der Shell aufgerufenen "
#~ "Prozessen"

#~ msgid "started by the shell, on systems that allow such control.  If an"
#~ msgstr ""
#~ "zur Verfügung stehen, wenn das System Ressourcensteuerung unterstützt.  "
#~ "Wenn"

#~ msgid "option is given, it is interpreted as follows:"
#~ msgstr "eine Option angegebe ist, dann wird sie wie folgt interpretiert:"

#~ msgid "    -S\tuse the `soft' resource limit"
#~ msgstr "    -S\tNutze die `weiche (soft)' Ressourceneinstellung."

#~ msgid "    -H\tuse the `hard' resource limit"
#~ msgstr "    -H\tNutze die `harte (hard)' Ressourceneinstellung."

#~ msgid "    -a\tall current limits are reported"
#~ msgstr "    -a\tDie gegenwärtige Ressourceneinstellung wird ausgegeben."

#~ msgid "    -c\tthe maximum size of core files created"
#~ msgstr "    -c\tDie maximale Größe der erzeugten core-Dateien."

# für ein Prozeß oder für alle?
#~ msgid "    -d\tthe maximum size of a process's data segment"
#~ msgstr "    -d\tDie maximale Größe des Datensegmentes eines Prozesses."

#~ msgid "    -m\tthe maximum resident set size"
#~ msgstr ""
#~ "    -m\tMaximale Größe des nicht auszulagenden (residenten) "
#~ "Prozeßspeichers."

#~ msgid "    -s\tthe maximum stack size"
#~ msgstr "    -s\tDie maximale Größe des Stapelspeichers."

#~ msgid "    -t\tthe maximum amount of cpu time in seconds"
#~ msgstr "    -t\tDie maximal verfügbare CPU-Zeit (in Sekunden)."

#~ msgid "    -f\tthe maximum size of files created by the shell"
#~ msgstr ""
#~ "    -f\tDie maximal erlaubte Größe für von der Shell erzeugte Dateien."

#~ msgid "    -p\tthe pipe buffer size"
#~ msgstr "    -p\tDie Größe des Pipeline-Puffers."

#~ msgid "    -n\tthe maximum number of open file descriptors"
#~ msgstr "    -n\tDie maximale Anzahl gleichzeitig geöffneter Dateien."

#~ msgid "    -u\tthe maximum number of user processes"
#~ msgstr "    -u\tDie maximale Anzahl von Prozessen des Benutzers."

#~ msgid "    -v\tthe size of virtual memory"
#~ msgstr "    -v\tDie Größe des virtuellen Arbeitsspeichers."

#~ msgid "If LIMIT is given, it is the new value of the specified resource."
#~ msgstr ""
#~ "Wenn eine Grenze angegeben ist, wird die Resouce auf diesen Wert gesetzt."

#~ msgid "Otherwise, the current value of the specified resource is printed."
#~ msgstr ""
#~ "Sonst wird der gegenwärtig eingestellte Wert ausgegeben.  Wenn keine "
#~ "Option"

#~ msgid "If no option is given, then -f is assumed.  Values are in 1k"
#~ msgstr ""
#~ "angegeben ist wird -f verwendet.  Die Einheit ist 1k außer für -t, deren"

#~ msgid "increments, except for -t, which is in seconds, -p, which is in"
#~ msgstr ""
#~ "Wert in Sekunden angegeben wird,  -p, dessen Einheit 512 bytes ist und -u,"

#~ msgid "increments of 512 bytes, and -u, which is an unscaled number of"
#~ msgstr "für das die Anzahl der Prozesse verwendet"

#~ msgid "processes."
#~ msgstr "wird."

# umask
#~ msgid ""
#~ "The user file-creation mask is set to MODE.  If MODE is omitted, or if"
#~ msgstr ""
#~ "Die Dateierzeugungsmaske wird auf MODE gesetzt.  Wenn MODE nicht, oder -S"

#~ msgid ""
#~ "`-S' is supplied, the current value of the mask is printed.  The `-S'"
#~ msgstr ""
#~ "angegeben ist, dann wird die aktuelle Dateierzeugungsmaske ausgegeben."

#~ msgid ""
#~ "option makes the output symbolic; otherwise an octal number is output."
#~ msgstr ""
#~ "Die `-S' Option bewirkt, daß die symbolische Entsprechung ausgegeben "
#~ "wird. "

#~ msgid "If MODE begins with a digit, it is interpreted as an octal number,"
#~ msgstr ""
#~ "Wenn MODE mit einer Ziffer beginnt, wird diese als Oktalzahl "
#~ "interpretiert."

#~ msgid ""
#~ "otherwise it is a symbolic mode string like that accepted by chmod(1)."
#~ msgstr ""
#~ "Ansonsten wird eine symbolische Notation (analog chmod(1)) angenommen."

# wait
#~ msgid ""
#~ "Wait for the specified process and report its termination status.  If"
#~ msgstr ""
#~ "Wartet auf das Beenden der angegebenen Prozesse und gibt deren "
#~ "Rückgabewert"

#~ msgid "N is not given, all currently active child processes are waited for,"
#~ msgstr "aus.  Wenn keine Prozesse angegeben sind, wird auf alle aktiven"

#~ msgid "and the return code is zero.  N may be a process ID or a job"
#~ msgstr ""
#~ "Hintergrundprozesse gewartet und Null zurückgegeben.  An wait können"

#~ msgid "specification; if a job spec is given, all processes in the job's"
#~ msgstr ""
#~ "Prozeßnummern und Jobbezeichnungen übergeben werden.  Wenn "
#~ "Jobbezeichnungen"

#~ msgid "pipeline are waited for."
#~ msgstr ""
#~ "angegeben sind, dann wird auf alle Prozesse in der Job-Pipeline gewartet "
#~ "und"

#~ msgid "and the return code is zero.  N is a process ID; if it is not given,"
#~ msgstr "Null zurückgegeben."

#~ msgid "all child processes of the shell are waited for."
#~ msgstr " "

# for
#~ msgid "The `for' loop executes a sequence of commands for each member in a"
#~ msgstr ""
#~ "`for' führt eine Reihe von Kommandos für jeden Eintrag einer Liste aus."

#~ msgid ""
#~ "list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is"
#~ msgstr "Ohne `in WORTLISTE' wird als Argument `in \"$@\"' verwendet."

#~ msgid ""
#~ "assumed.  For each element in WORDS, NAME is set to that element, and"
#~ msgstr "NAME wird nacheinander ein Element aus WORTLISTE zugewiesen"

#~ msgid "the COMMANDS are executed."
#~ msgstr "und die KOMMANDOS ausgeführt."

# select
#~ msgid "The WORDS are expanded, generating a list of words.  The"
#~ msgstr ""
#~ "Die WORTE werden erweitert und erzeugen eine Wortliste.  Diese wird als"

#~ msgid "set of expanded words is printed on the standard error, each"
#~ msgstr "numerierte Liste auf dem Standardfehlerkanal ausgegeben."

#~ msgid "preceded by a number.  If `in WORDS' is not present, `in \"$@\"'"
#~ msgstr ""
#~ "Wenn `in WORTE' nicht angegeben ist, dann wird `in \"$@\"' verwendet."

#~ msgid "is assumed.  The PS3 prompt is then displayed and a line read"
#~ msgstr ""
#~ "Das PS3-Promt wird angezeigt und eine Zeile von der Standardeingabe "
#~ "gelesen."

#~ msgid "from the standard input.  If the line consists of the number"
#~ msgstr ""
#~ "Wenn die gelesene Zeile eine Zeilennummer der angezeigten Liste enhält, "
#~ "dann"

#~ msgid "corresponding to one of the displayed words, then NAME is set"
#~ msgstr "wird NAME entsprechend dem WORT in der bezeichneten Zeile gesetzt."

#~ msgid "to that word.  If the line is empty, WORDS and the prompt are"
#~ msgstr ""
#~ "Wird eine leere Zeichenkette gelesen,  dann wird die Liste erneut "
#~ "angezeigt."

#~ msgid "redisplayed.  If EOF is read, the command completes.  Any other"
#~ msgstr ""
#~ "Mir einem EOF Zeichen wird die Eingabe abgebrochen.  Jeder andere Inhalt "
#~ "der"

#~ msgid "value read causes NAME to be set to null.  The line read is saved"
#~ msgstr ""
#~ "Zeichenkette bewirkt, daß NAME auf Null gesetzt wird.  Die gelesene Zeile "
#~ "wird"

#~ msgid "in the variable REPLY.  COMMANDS are executed after each selection"
#~ msgstr ""
#~ "in der Variable REPLY gespeichert.  Die KOMMANDOS werden so lange "
#~ "wiederholt,"

#~ msgid "until a break or return command is executed."
#~ msgstr "bis die Schleife mit break oder return verlassen wird."

# case
#~ msgid "Selectively execute COMMANDS based upon WORD matching PATTERN.  The"
#~ msgstr "Führt KOMMANDOS abhängig von einem WORT aus, das MUSTER entspricht."

#~ msgid "`|' is used to separate multiple patterns."
#~ msgstr "Das Zeichen `|' trennt mehrere Muster."

# if
#~ msgid ""
#~ "The if COMMANDS are executed.  If the exit status is zero, then the then"
#~ msgstr ""
#~ "Die KOMMANDOS werden ausgewertet. Ist der Rückgabewert Null, dann werden "
#~ "die"

#~ msgid ""
#~ "COMMANDS are executed.  Otherwise, each of the elif COMMANDS are executed"
#~ msgstr ""
#~ "then KOMMANDOS ausgeführt. Ansonsten werden die elif KOMMANDOS der Reihe "
#~ "nach"

#~ msgid ""
#~ "in turn, and if the exit status is zero, the corresponding then COMMANDS"
#~ msgstr ""
#~ "ausgewertet und bei einem Rückgabewert Null die dazugehörigen KOMMANDOS"

#~ msgid ""
#~ "are executed and the if command completes.  Otherwise, the else COMMANDS"
#~ msgstr "ausgeführt und if beendet. Sonst wird, wenn ein else Kommandozweig"

#~ msgid ""
#~ "are executed, if present.  The exit status is the exit status of the last"
#~ msgstr ""
#~ "existiert, dieser ausgeführt. Der Exitstatus ist der des letzten Kommandos"

#~ msgid "command executed, or zero if no condition tested true."
#~ msgstr "oder Null, wenn keine Bedingung wahr ergab."

# while
#~ msgid "Expand and execute COMMANDS as long as the final command in the"
#~ msgstr ""
#~ "Wiederholt den Schleifenkörper `do KOMMANDOS done' so lange die letzte"

#~ msgid "`while' COMMANDS has an exit status of zero."
#~ msgstr "Kommando `while KOMMANDOS' einen Rückkehrstatus Null liefert."

# until
#~ msgid "`until' COMMANDS has an exit status which is not zero."
#~ msgstr ""
#~ "Kommando in `until KOMMANDOS' einen Rückkehrstatus ungleich Null liefert."

# function
#~ msgid "Create a simple command invoked by NAME which runs COMMANDS."
#~ msgstr "Erzeugt eine neue Shellfunktion NAME, die KOMMANDOS ausführt. "

#~ msgid "Arguments on the command line along with NAME are passed to the"
#~ msgstr "NAME und Kommandozeilenagumente werden an die Funktion als $0 .. $n"

#~ msgid "function as $0 .. $n."
#~ msgstr "übergeben."

# grouping_braces
#~ msgid "Run a set of commands in a group.  This is one way to redirect an"
#~ msgstr ""
#~ "Führt Kommandos in einer Gruppe aus.  Das ist eine Möglichkeit die "
#~ "Ausgabe von"

#~ msgid "entire set of commands."
#~ msgstr "einer Gruppe Kommandos umzuleiten."

# fg_percent
#~ msgid "This is similar to the `fg' command.  Resume a stopped or background"
#~ msgstr ""
#~ "Ist ähnlich dem `fg' Kommando.  Nimmt einen angehaltenen oder hintergrund "
#~ "Job"

#~ msgid "job.  If you specifiy DIGITS, then that job is used.  If you specify"
#~ msgstr ""
#~ "wieder auf.  Wenn eine Jobnummer angegeben ist, dann wird dieser "
#~ "aufgenommen."

#~ msgid ""
#~ "WORD, then the job whose name begins with WORD is used.  Following the"
#~ msgstr ""
#~ "Wenn eine Zeichenkette angegeben ist, dann wird der Job der mit diesen "
#~ "Zeichen"

#~ msgid "job specification with a `&' places the job in the background."
#~ msgstr "beginnt wieder aufgenommen.  `&' bringt den Job in den Hintergrund."

# variable_help
#~ msgid "BASH_VERSION    The version numbers of this Bash."
#~ msgstr "BASH_VERSION    Versionsnummer der Bash."

#~ msgid "CDPATH          A colon separated list of directories to search"
#~ msgstr ""
#~ "CDPATH          Eine durch Doppelpunkt getrennte Liste von "
#~ "Verzeichnissen, die"

#~ msgid "\t\twhen the argument to `cd' is not found in the current"
#~ msgstr "\t\tdurchsucht werden, wenn das Argument von `cd' nicht im"

#~ msgid "\t\tdirectory."
#~ msgstr "\t\taktuellen Verzeichnis gefunden wird."

#~ msgid ""
#~ "HISTFILE        The name of the file where your command history is stored."
#~ msgstr "HISTFILE        Datei, die den Kommandozeilenspeicher enthält.  "

#~ msgid "HISTFILESIZE    The maximum number of lines this file can contain."
#~ msgstr ""
#~ "HISTFILESIZE    Maximale Zeilenanzahl, die diese Datei enthalten darf."

#~ msgid "HISTSIZE        The maximum number of history lines that a running"
#~ msgstr ""
#~ "HISTSIZE        Maximale Anzahl von Zeilen, auf die der Historymechanismus"

#~ msgid "\t\tshell can access."
#~ msgstr "\t\tder Shell zurückgreifen kann."

#~ msgid "HOME            The complete pathname to your login directory."
#~ msgstr "HOME            Heimatverzeichnis des aktuellen Benutzers."

#~ msgid ""
#~ "HOSTTYPE        The type of CPU this version of Bash is running under."
#~ msgstr ""
#~ "HOSTTYPE        CPU-Typ des Rechners, auf dem die Bash gegenwärtig läuft."

#~ msgid ""
#~ "IGNOREEOF       Controls the action of the shell on receipt of an EOF"
#~ msgstr ""
#~ "IGNOREEOF       Legt die Reaktion der Shell auf ein EOF-Zeichen fest."

#~ msgid "\t\tcharacter as the sole input.  If set, then the value"
#~ msgstr "\t\tWenn die Variable eine ganze Zahl enthält, wird diese Anzahl"

#~ msgid "\t\tof it is the number of EOF characters that can be seen"
#~ msgstr "\t\tEOF Zeichen (Ctrl-D) abgewartet, bis die Shell verlassen wird."

#~ msgid "\t\tin a row on an empty line before the shell will exit"
#~ msgstr "\t\tDer Vorgabewert ist 10. Ist IGNOREEOF nicht gesetzt,"

#~ msgid "\t\t(default 10).  When unset, EOF signifies the end of input."
#~ msgstr "\t\tsignalisiert EOF das Ende der Eingabe."

#~ msgid "MAILCHECK\tHow often, in seconds, Bash checks for new mail."
#~ msgstr ""
#~ "MAILCHECK\tZeitintervall [s], in dem nach angekommener Post gesucht wird."

#~ msgid "MAILPATH\tA colon-separated list of filenames which Bash checks"
#~ msgstr ""
#~ "MAILPATH\tEine durch Doppelpunkt getrennte Liste von Dateien, die nach"

#~ msgid "\t\tfor new mail."
#~ msgstr "\t\tneu angekommener Post durchsucht werden."

#~ msgid "OSTYPE\t\tThe version of Unix this version of Bash is running on."
#~ msgstr ""
#~ "OSTYPE\t\tBetriebssystemversion, auf der die Bash gegenwärtig läuft."

#~ msgid "PATH            A colon-separated list of directories to search when"
#~ msgstr "PATH\t\tDurch Doppelpunkt getrennte Liste von Verzeichnissen, die "

#~ msgid "\t\tlooking for commands."
#~ msgstr "\t\tnach Kommandos durchsucht werden."

#~ msgid "PROMPT_COMMAND  A command to be executed before the printing of each"
#~ msgstr ""
#~ "PROMPT_COMMAND  Kommando, das vor der Anzeige einer primären "
#~ "Eingabeaufforderung"

#~ msgid "\t\tprimary prompt."
#~ msgstr "\t\t(PS1) ausgeführt wird."

#~ msgid "PS1             The primary prompt string."
#~ msgstr ""
#~ "PS1             Zeichenkette, die die primäre Eingabeaufforderung enthält."

#~ msgid "PS2             The secondary prompt string."
#~ msgstr ""
#~ "PS2             Zeichenkette, die die sekundäre Eingabeaufforderung "
#~ "enthält."

#~ msgid "TERM            The name of the current terminal type."
#~ msgstr "TERM            Name des aktuellen Terminaltyps."

#~ msgid "auto_resume     Non-null means a command word appearing on a line by"
#~ msgstr ""
#~ "auto_resume     Ein Wert ungleich Null bewirkt, daß ein einzelnes "
#~ "Kommando auf"

#~ msgid "\t\titself is first looked for in the list of currently"
#~ msgstr "\t\teiner Zeile zunächst in der Liste gegenwärtig gestoppter Jobs"

#~ msgid "\t\tstopped jobs.  If found there, that job is foregrounded."
#~ msgstr "\t\tgesucht und dieser in den Vordergrund geholt wird. `exact'"

#~ msgid "\t\tA value of `exact' means that the command word must"
#~ msgstr "\t\tbewirkt, daß das Kommando genau dem Kommando in der"

#~ msgid "\t\texactly match a command in the list of stopped jobs.  A"
#~ msgstr "\t\tListe der gestoppten Jobs entsprechen muß. Wenn die Variable"

#~ msgid "\t\tvalue of `substring' means that the command word must"
#~ msgstr "\t\tden Wert `substring' enthält, muß das Kommando einem Substring"

#~ msgid "\t\tmatch a substring of the job.  Any other value means that"
#~ msgstr "\t\tder Jobbezeichnung entsprechen. Bei einem anderen Wert müssen"

#~ msgid "\t\tthe command must be a prefix of a stopped job."
#~ msgstr "\t\tdie ersten Zeichen übereinstimmen."

#~ msgid "command_oriented_history"
#~ msgstr "command_oriented_history"

#~ msgid ""
#~ "                Non-null means to save multiple-line commands together on"
#~ msgstr "\t\tMehrzeilige Kommandos werden im Kommandozeilenspeicher in einer"

#~ msgid "                a single history line."
#~ msgstr "\t\tZeile abgelegt, wenn die Variable ungleich Null gesetzt ist."

#~ msgid "histchars       Characters controlling history expansion and quick"
#~ msgstr ""
#~ "histchars       Zeichen, die die Befehlswiederholung und die "
#~ "Schnellersetzung"

#~ msgid "\t\tsubstitution.  The first character is the history"
#~ msgstr "\t\tsteuern. An erster Stelle steht das Befehlswiederholungszeichen"

#~ msgid "\t\tsubstitution character, usually `!'.  The second is"
#~ msgstr "\t\t(normalerweise `!'); an zweiter das `Schnell-Ersetzen-Zeichen'"

#~ msgid "\t\tthe `quick substitution' character, usually `^'.  The"
#~ msgstr "\t\t(normalerweise `^'). Das dritte Zeichen ist das"

#~ msgid "\t\tthird is the `history comment' character, usually `#'."
#~ msgstr "\t\t`Kommentarzeichen' (normalerweise `#')."

#~ msgid "HISTCONTROL\tSet to a value of `ignorespace', it means don't enter"
#~ msgstr "HISTCONTROL\tGesetzt auf `ignorespace' werden keine mit einem"

#~ msgid "\t\tlines which begin with a space or tab on the history"
#~ msgstr ""
#~ "\t\tLeerzeichen oder Tabulator beginnenden Zeilen im Kommandospeicher"

#~ msgid "\t\tlist.  Set to a value of `ignoredups', it means don't"
#~ msgstr "\t\tabgelegt. Der Wert `ignoredups' verhindert das Speichern"

#~ msgid "\t\tenter lines which match the last entered line.  Set to"
#~ msgstr "\t\taufeinanderfolgender identischer Zeilen. `ignoreboth'"

#~ msgid "\t\t`ignoreboth' means to combine the two options.  Unset,"
#~ msgstr "\t\tkombiniert beide Einstellungen. Wenn die Variable"

#~ msgid "\t\tor set to any other value than those above means to save"
#~ msgstr "\t\tnicht oder auf einen anderen Wert gesetzt ist, werden alle"

#~ msgid "\t\tall lines on the history list."
#~ msgstr "\t\teingegebenen Zeilen im Kommandospeicher abgelegt."

# pushd
#~ msgid "Adds a directory to the top of the directory stack, or rotates"
#~ msgstr ""
#~ "Legt ein Verzeichnisnamen auf den Verzeichnisstapel oder rotiert diesen "
#~ "so,"

# Gibt's denn auch andere als "aktuelle" Arbeitsverzeichnisse?
# "Arbeit" impliziert .m.E. "aktuell"
# ck
#~ msgid "the stack, making the new top of the stack the current working"
#~ msgstr "daß das Arbeitsverzeichnis auf der Spitze des Stapels liegt. Ohne"

#~ msgid "directory.  With no arguments, exchanges the top two directories."
#~ msgstr ""
#~ "Argumente werden die obersten zwei Verzeichnisse auf dem Stapel "
#~ "vertauscht."

#~ msgid "+N\tRotates the stack so that the Nth directory (counting"
#~ msgstr ""
#~ "+N\tRotiert den Stapel so, daß das N'te Verzeichnis (angezeigt von `dirs',"

#~ msgid "\tfrom the left of the list shown by `dirs') is at the top."
#~ msgstr "gezählt von links) sich an der Spitze des Stapels befindet."

#~ msgid "-N\tRotates the stack so that the Nth directory (counting"
#~ msgstr ""
#~ "-N\tRotiert den Stapel so, daß das N'te Verzeichnis (angezeigt von `dirs',"

#~ msgid "\tfrom the right) is at the top."
#~ msgstr "gezählt von rechts) sich an der Spitze des Stapels befindet."

#~ msgid "-n\tsuppress the normal change of directory when adding directories"
#~ msgstr "-n\tunterdrückt das Wechseln in das Verzeichnis beim Hinzufügen zum"

#~ msgid "\tto the stack, so only the stack is manipulated."
#~ msgstr "\tStapel, so daß nur der Stapel verändert wird."

#~ msgid "dir\tadds DIR to the directory stack at the top, making it the"
#~ msgstr "DIR\tLegt DIR auf die Spitze des Verzeichnisstapels und wechselt"

#~ msgid "You can see the directory stack with the `dirs' command."
#~ msgstr ""
#~ "Der Verzeichnisstapel kann mit dem Kommando `dirs' angezeigt werden."

# pushd
#~ msgid "Removes entries from the directory stack.  With no arguments,"
#~ msgstr ""
#~ "Entfernt Einträge vom Verzeichnisstapel. Ohne Argumente wird die Spitze "
#~ "des"

#~ msgid "removes the top directory from the stack, and cd's to the new"
#~ msgstr "Stapels entfernt und in das Verzeichnis gewechselt, das dann an der"

#~ msgid "+N\tremoves the Nth entry counting from the left of the list"
#~ msgstr ""
#~ "+N\tEntfernt den N'ten Eintrag vom Stapel,  gezählt von Null von der "
#~ "Liste,"

#~ msgid "\tshown by `dirs', starting with zero.  For example: `popd +0'"
#~ msgstr "\tdie `dirs' anzeigt. Beispielsweise entfernen `popd +0' das"

#~ msgid "\tremoves the first directory, `popd +1' the second."
#~ msgstr "\terste Verzeichnis und `popd +1' das zweite."

#~ msgid "-N\tremoves the Nth entry counting from the right of the list"
#~ msgstr ""
#~ "-N\tEntfernt den N'ten Eintrag vom Stapel, beginend rechts bei Null in der"

#~ msgid "\tshown by `dirs', starting with zero.  For example: `popd -0'"
#~ msgstr "\tListe, die `dirs' angeigt. Beispielsweise entfernen `popd -0'"

#~ msgid "\tremoves the last directory, `popd -1' the next to last."
#~ msgstr "\tdas letzte Verzeichnis und `popd -1' das vorletzte."

#~ msgid ""
#~ "-n\tsuppress the normal change of directory when removing directories"
#~ msgstr ""
#~ "-n\tVerhindert das Wechseln des Arbeitsverzeichnisses wenn Verzeichnisse"

#~ msgid "\tfrom the stack, so only the stack is manipulated."
#~ msgstr "\tvom Stapel entfernt werden, so daß nur der Stapel verändert wird."

# dirs
#~ msgid "Display the list of currently remembered directories.  Directories"
#~ msgstr ""
#~ "Zeigt die Liste der gegenwärtig gespeicherten Verzeichnisse an.  "
#~ "Gespeichert"

#~ msgid "find their way onto the list with the `pushd' command; you can get"
#~ msgstr ""
#~ "werden die Verzeichnisse durch das `popd' Kommando und können durch das "
#~ "`pushd'"

#~ msgid "back up through the list with the `popd' command."
#~ msgstr "Kommando wieder vom Stapel entfernt werden."

#~ msgid ""
#~ "The -l flag specifies that `dirs' should not print shorthand versions"
#~ msgstr ""
#~ "Wenn die -l Option angegeben ist, dann werden keine Kurzversionen der "
#~ "Verzeich-"

#~ msgid ""
#~ "of directories which are relative to your home directory.  This means"
#~ msgstr ""
#~ "nisse angezeigt, die relativ zum Heimatverzeichnis sind.  Es wird also an"

#~ msgid "that `~/bin' might be displayed as `/homes/bfox/bin'.  The -v flag"
#~ msgstr ""
#~ "Stelle von `~/bin' der absolute Pfad `/home/foo/bin' angezeigt.  Mit der -"
#~ "v"

#~ msgid "causes `dirs' to print the directory stack with one entry per line,"
#~ msgstr ""
#~ "Option wird von `dirs' ein Eintrag pro Zeile ausgegeben.  Die Position im"

#~ msgid ""
#~ "prepending the directory name with its position in the stack.  The -p"
#~ msgstr ""
#~ "Stapel wird vorangestellt.  Die -p Option wirkt ähnlich, es wird "
#~ "allerdings"

#~ msgid "flag does the same thing, but the stack position is not prepended."
#~ msgstr ""
#~ "nicht die Position im Stapel angezeigt.  Wenn -c angegeben ist, damm "
#~ "werden"

#~ msgid ""
#~ "The -c flag clears the directory stack by deleting all of the elements."
#~ msgstr "alle Einträge vom Verzeichnisstapel gelöscht."

#~ msgid ""
#~ "+N\tdisplays the Nth entry counting from the left of the list shown by"
#~ msgstr ""
#~ "+N\tZeigt den N'ten Eintrag, gezählt von links begginnend bei Null, aus"

#~ msgid "\tdirs when invoked without options, starting with zero."
#~ msgstr "\tder Liste, die von `dirs' ohne Optionen angezeigt wird."

#~ msgid ""
#~ "-N\tdisplays the Nth entry counting from the right of the list shown by"
#~ msgstr ""
#~ "-N\tZeigt den N'ten Eintrag, gezählt von rechts begginnend bei Null, aus"

# shopt_builtin
#~ msgid "Toggle the values of variables controlling optional behavior."
#~ msgstr ""
#~ "Ändert die Werte von Variablen die zusätzliche Eigenschaften der Shell "
#~ "steuern."

#~ msgid "The -s flag means to enable (set) each OPTNAME; the -u flag"
#~ msgstr ""
#~ "Mit der -s Option wird jeder OPTIONSMAME gesetzt.  Die -u Option setzt "
#~ "jeden"

#~ msgid "unsets each OPTNAME.  The -q flag suppresses output; the exit"
#~ msgstr ""
#~ "OPTIONSNAMEN zurück.  Die -q Option unterdrückt Ausgaben.  Der "
#~ "Rückgabewert"

#~ msgid "status indicates whether each OPTNAME is set or unset.  The -o"
#~ msgstr ""
#~ "des Kommandos gibt an ob der OPTIONSNAME ein- oder ausgeschalten wurde.  "
#~ "Die"

#~ msgid "option restricts the OPTNAMEs to those defined for use with"
#~ msgstr ""
#~ "Option beschränkt die OPTIONSNAMEN auf jene die mit `set -o' benutzt "
#~ "werden"

#~ msgid "`set -o'.  With no options, or with the -p option, a list of all"
#~ msgstr ""
#~ "können.  Ohne oder mit der -p Option wird eine Liste aller `settable' "
#~ "Optionen"

#~ msgid "settable options is displayed, with an indication of whether or"
#~ msgstr ""
#~ "mit einer Markierung ob die angegebene Option gesetzt oder nicht gesetzt"

#~ msgid "not each is set."
#~ msgstr "ist angezeigt."
